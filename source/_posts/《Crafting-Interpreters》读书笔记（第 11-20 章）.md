---
title: 《Crafting Interpreters》读书笔记（第 11-20 章）
intro: 书接上文。
comments: false
date: 2023-09-04 17:39:00
tags:
- Interpreter
- Compiler
---

书接上文。


### Chapter 11 - Resolving and Binding

1. For Closure, when a function is declared, it captures a reference to the current environment. **The function should capture a frozen snapshot of the environment as it existed at the moment the function was declared**. In this way, we can match the rules of static scope - a variable usage always resolves to the same declaration, which can be determined just by looking at the text.

```lox
var a = "global";
{
  fun showA() {
    print a;
  }

  showA();  // Should be "global".
  var a = "block";
  showA();  // Should be "global" too.
}
```

2. **Semantic analysis**: write a chunk of code that inspects the user’s program, finds every variable mentioned, and figures out which declaration each refers to. A parser tells only if a program is grammatically correct (a syntactic analysis), semantic analysis goes farther and starts to figure out what pieces of the program actually mean. 

* This process could be done in separate passes.
* The type checker for statically typed language could be done based on AST generated by the parser.
* The resolution information can be saved inside the syntax tree node itself direclty, or in a "side map".

3. 
4. 
5. 

