---
title: 《Crafting Interpreters》读书笔记（第 11-20 章）
intro: 书接上文。
comments: false
date: 2023-09-04 17:39:00
tags:
- Interpreter
- Compiler
---

书接上文。


### Chapter 11 - Resolving and Binding

1. For Closure, when a function is declared, it captures a reference to the current environment. The function should capture a frozen snapshot of the environment as it existed at the moment the function was declared. In this way, we can match the rules of static scope - **a variable usage always resolves to the same declaration, which can be determined just by looking at the text**.

```lox
var a = "global";
{
  fun showA() {
    print a;
  }

  showA();  // Should be "global".
  var a = "block";
  showA();  // Should be "global" too.
}
```

* Ways to achieve this correctly:
  * Immutable data structure: every time we declared a variable it could return a new environment that contained all of the previously declared variables along with the one new name.
  * Calculate how many “hops” away the declared variable will be in the environment chain. 

2. **Semantic analysis**: write a chunk of code that inspects the user’s program, finds every variable mentioned, and figures out which declaration each refers to. A parser tells only if a program is grammatically correct (a syntactic analysis), semantic analysis goes farther and starts to figure out what pieces of the program actually mean. 

* This process could be done in separate passes.
* The type checker for statically typed language could be done based on AST generated by the parser here.
* The resolution information can be saved inside the syntax tree node itself direclty, or in a "side map".

3. Available improvements:

* Extend the resolver to associate a unique index for each local variable declared in a scope. When resolving a variable access, look up both the scope the variable is in and its index and store that. In the interpreter, use that to quickly access a variable by its index instead of using a map.

### Chapter 12 - Classes

4. There are three broad paths to object-oriented programming: **classes**, **prototypes**, and **multi-methods**. 
5. Classes:

* Lifecycle:

![](1.png)

* Syntax grammar for "class declaration":

```bnf
declaration    → classDecl
               | funDecl
               | varDecl
               | statement ;
classDecl      → "class" IDENTIFIER "{" function* "}" ;
function       → IDENTIFIER "(" parameters? ")" block ;
parameters     → IDENTIFIER ( "," IDENTIFIER )* ;
```

* Syntax grammar for "get expressions": after a primary expression, we allow a series of any mixture of parenthesized calls and dotted property accesses. That dot has the same precedence as the parentheses in a function call expression.

```bnf
call           → primary ( "(" arguments? ")" | "." IDENTIFIER )* ;
```
 
* Syntax grammar for "set expressions": 

![](2.png)

```bnf
assignment     → ( call "." )? IDENTIFIER "=" assignment
               | logic_or ;
```

* "properties" V.S. "fields": fields are named bits of state stored directly in an instance. Properties are the named things, that a get expression may return. 
* **Bound methods**: have methods “bind” `this` to the original instance when the method is first grabbed. 
* “Constructing” an object is a pair of operations:
  * The runtime allocates the memory required for a fresh instance.
  * Then, a user-provided chunk of code is called which initializes the unformed object.

6. Many of the optimizations invented to make dynamic languages fast rest on the observation that: **even in those languages, most code is fairly static in terms of the types of objects it works with and their fields**.

### Chapter 13 - Inheritance

7. Syntax grammar for inheritance:

```bnf
classDecl      → "class" IDENTIFIER ( "<" IDENTIFIER )?
                 "{" function* "}" ;
primary        → "true" | "false" | "nil" | "this"
               | NUMBER | STRING | IDENTIFIER | "(" expression ")"
               | "super" "." IDENTIFIER ;
```

* For function calls on `super`, the method lookup should start on the superclass of the class containing the `super` expression.

### Chapter 14 - Inheritance

8. 
9. 
10. 
11. 
12. 
13. 
14. 
15. 
