---
title: GeekBank C++ 线下班学习心得（二）
intro: 今天是“GeekBand 极客班线下 C++ 培训”的第二周课程，浦东12路依旧挤得不行。上午先是产品经理部分的课程答疑与培训，一些课程重点的总结如下。
comments: false
date: 2015-07-25 21:08:31
tags:
- 日记
---

今天是“GeekBand 极客班线下 C++ 培训的第二周课程”，浦东12路依旧挤得不行。上午先是产品经理部分的课程答疑与培训，一些课程重点的总结如下：

* **用户：**使用产品的人（不一定付钱）；
* **客户：**通常是付钱的人（用户从来不买单）；
* **调查问卷：**尽量用电话，微信语音相比较更好，不要让用户看到你要问什么问题；
* **AB 测试：**A用户群使用第一个版本，B用户群使用第二个版本；
* **灰度发布：**对一小部分人群进行产品发布（相对成熟的产品），并及时了解反馈建议；
* **MVP：**产品可以使用，虽然用户体验并不一定好，但是却可以解决用户的问题；
* **快速迭代：**一周到两周发布一个新的版本；

#### 产品经理必读书：

* 《系统化思维导论》（Jerry Weinberg 著）：训练逻辑思维。
* 《精英数据分析》；
* 《从0到1》；

#### 产品经验总结：

1. 策划产品时要对产品面向的用户群体进行细分（必须进行量化），不能使用模糊的群体分类（比如极客），要有明确的定位，并在生活中可以找到实例；
2. 表达能力重要性和逻辑推理的重要性；
3. 从创意去思考背后的问题，99%的用户的主意都是无用的；
4. 走出办公楼，去面对自己的用户；



#### “IOS 应用开发与实战”课总结：

1. 写代码：代码整体的干净程度，像说明文，易于后来人接手，代码的优美；
2. 不要去死记硬背，写得多自然就记住了；



#### “C++辅导课培训”总结：

**栈：**

* 由系统自动管理，以执行函数为单位；MyClass c(10)；
* 空间大小编译时确定（参数 + 局部变量）；
* 函数执行时，系统自动分配一个 Stack；
* 函数执行结束时，系统立即回收 Stact；


**堆：**

* 在 C++ 中由程序员手动控制 “new” 出来的对象在堆上；
* 手动分配 `new` 和 `malloc`；
* 手动释放 `delete` 和 `free`；
* 具有全局性，总体大小无限制；
* 容易造成内存泄露；



**避免悬浮指针：**

```cpp
MyClass* func() {
  MyClass c(10);
  return &c;
}
```

**栈是属于函数的：指向栈对象的指针比较危险：**

```cpp
MyClass func() {
  MyClass c(10);
  AClass a(100);
  c.pa = $a;
  return c;
}
```

**返回值尽量不要返回指针，谁分配内存谁释放内存：**

```cpp
MyClass* func() {
  MyClass * pa = new MyClass();
  return pa;
}
MyClass *p = func();
```

* 栈上存放指针，堆上存储真正的对象；
* 栈对象：对象内存直接存储于栈对象；


#### C++ 变量模型与使用：

**传参：**

```cpp
// 传对象不好，对象较大，只要传参就是拷贝；
void func1(MyClass c) {
  // 这里 “c” 的大小依赖于各个字段的大小，32位机器若有虚函数加 4byte，64位则加 8byte；
}
void func2(MyClass *pc) {
  // 尽量不用，不能 delete 栈对象；
}
```

**后续删除指针：**

```cpp
MyClass *pc = new MyClass();
func2(pc);
delete(pc);
```

```cpp
void func3(MyClass &mc) {
  // 传参成本低，效率高，背后是指针，不用考虑是栈对象还是堆对象；
}
void func3(MyClass &mc) {
  // 若 “mc” 是堆对象，则函数没问题，但 “mc” 是外部参数，函数不负责释放；
  MyClass *p = &mc;
  delete p;
}
// ByValue 的替代，传 const 引用；
void func3(const MyClass &mc) {}
```

**传参：**


```cpp
MyClass c1；
func1(c1);
func2(&c1);
func3(c1);	
```

**返回值：**

```cpp
MyClass func1() {
  MyClass c1;
  return c1;

   MyClass* pc2 = new MyClass();
  return *pc2;
  // 返回对象常见；
  // 这里 “pc2” 指针不会被释放；
}

MyClass *func2() {
  MyClass c1;
  return &c1;
  // OR；
  MyClass *pc2 = new MyClass();
  return pc2;
  // 只能返回堆对象的指针；
}

MyClass& func4(MyClass &c) {
  return c;
}	
```

* 栈的大小是确定的，堆具有灵活性，大小可以随意分配，没有栈就没有函数，没有变量；

**总结：**

* 掌握内存模型的分析方法 — 画运行时内存图；
* 掌握堆、栈的概念；
* 掌握指针、引用、对象；
* 探微知著：魔鬼尽在细节中；
