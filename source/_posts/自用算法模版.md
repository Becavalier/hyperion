---
title: è‡ªç”¨ç®—æ³•æ¨¡ç‰ˆï¼ˆC++ï¼‰
intro: è‡ªç”¨ç®—æ³•æ¨¡ç‰ˆï¼ˆC++ï¼‰ã€‚
comments: true
date: 2025-04-08 10:34:00
tags:
- Algorithm
- ç®—æ³•
---

## æ•°ç»„é“¾è¡¨

* **æ•°ç»„**ï¼š
  * å†…å­˜è¿ç»­ âœ…ï¼›
  * æ”¯æŒå…ƒç´ çš„éšæœºè®¿é—®ï¼Œæ—¶é—´å¤æ‚åº¦ O(1) âœ…ã€‚
  * ä¸é€‚ç”¨äºéœ€è¦é¢‘ç¹æ’å…¥ \ åˆ é™¤çš„æ“ä½œ âŒï¼›
  * å¤§å°å›ºå®šï¼Œæ‰©å®¹éœ€æ¬ç§»å…ƒç´  âŒã€‚
  * åŠ¨æ€æ•°ç»„åº•å±‚è¿˜æ˜¯é™æ€æ•°ç»„ï¼Œä¼šä½¿ç”¨åŠ¨æ€æ‰©å®¹æœºåˆ¶è‡ªåŠ¨æ‰©å®¹ã€‚
* **é“¾è¡¨**ï¼š
  * é€‚ç”¨äºéœ€è¦é¢‘ç¹æ’å…¥ \ åˆ é™¤çš„æ“ä½œ âœ…ï¼›
  * å¤§å°å¯ä»¥åŠ¨æ€æ‰©å±• âœ…ã€‚
  * åœ¨å†…å­˜çš„ç¼“å­˜ç©ºé—´å±€éƒ¨æ€§ï¼ˆSpatial Localityï¼‰ä¸Šç›¸è¾ƒæ•°ç»„æ›´å·® âŒï¼›
  * ä¸æ”¯æŒéšæœºè®¿é—®ï¼Œéœ€ä»å¤´ \ å°¾éå†ï¼Œæ—¶é—´å¤æ‚åº¦ O(N) âŒã€‚
* **ç¯å½¢æ•°ç»„**ï¼šç”¨æ±‚æ¨¡è¿ç®—ï¼Œå°†æ™®é€šæ•°ç»„å˜æˆé€»è¾‘ä¸Šçš„ç¯å½¢æ•°ç»„ï¼Œè®©æˆ‘ä»¬å¯ä»¥ç”¨ O(1) çš„æ—¶é—´åœ¨æ•°ç»„å¤´éƒ¨å¢åˆ å…ƒç´ ã€‚

```cpp
#include <iostream>
#include <stdexcept>
#include <ostream>
#include <memory>

class CircularArray {
  // åŒºé—´ [start, end)ã€‚
  std::unique_ptr<int[]> arr = nullptr;
  size_t start; 
  size_t end;
  size_t count;
public:
  CircularArray(size_t size) : count(0), start(0), end(0) {
    arr = std::make_unique<int[]>(size);
  }
  void addFirst(int n) {
    // å…ˆå·¦ç§»ï¼Œå†èµ‹å€¼ï¼›
    start = (start + count - 1) % count;
    arr[start] = n;
    ++count;
  }
  void addLast(int n) {
    // å…ˆèµ‹å€¼ï¼Œå†å³ç§»ï¼›
    arr[end] = n;
    end = (end + 1) % count;
    ++count;
  }
  int removeFirst() {
    // å…ˆä¿å­˜å€¼ï¼Œå†å³ç§»ï¼›
    auto v = arr[start];
    start = (start + 1) % count;
    return v;
  }
  int removeLast() {
    // å…ˆå·¦ç§»ï¼Œå†è¿”å›å€¼ï¼›
    end = (end + count - 1) % count;
    return arr[end];
  }
};  
```

## å“ˆå¸Œè¡¨

* **è´Ÿè½½å› å­**ï¼ˆLoad Factorï¼‰ï¼š`Î± = å­˜å‚¨çš„é”®å€¼å¯¹æ•°é‡ / åº•å±‚æ•°ç»„å¤§å°`ï¼Œè¡¨ç¤ºå“ˆå¸Œè¡¨è£…æ»¡çš„ç¨‹åº¦çš„åº¦é‡ï¼Œå€¼è¶Šå¤§ï¼Œè¯´æ˜å­˜å‚¨çš„é”®å€¼å¯¹è¶Šå¤šã€‚Î± è¿‡å¤§ä¼šå¯¼è‡´å“ˆå¸Œè¡¨æ‰©å®¹ï¼›
* **å“ˆå¸Œå†²çª**ï¼šä¸¤ä¸ªä¸åŒçš„ key é€šè¿‡å“ˆå¸Œå‡½æ•°å¾—åˆ°äº†ç›¸åŒçš„ç´¢å¼•ï¼›
  * ***æ‹‰é“¾æ³•***ï¼ˆChainingï¼‰ï¼šæ¯ä¸ªå“ˆå¸Œæ¡¶ï¼ˆæ§½ï¼‰ä¸ç›´æ¥å­˜å‚¨ä¸€ä¸ªå€¼ï¼Œè€Œæ˜¯å­˜å‚¨ä¸€ä¸ªé“¾è¡¨æˆ–å…¶ä»–æ•°æ®ç»“æ„ï¼ˆå¦‚é“¾è¡¨ã€é“¾è¡¨æ ‘ã€åŠ¨æ€æ•°ç»„ç­‰ï¼‰ï¼Œè¯¥é“¾è¡¨ä¸­ä¿å­˜æ‰€æœ‰æ˜ å°„åˆ°åŒä¸€ä½ç½®çš„å…ƒç´ ã€‚è´Ÿè½½å› å­å¯ä»¥æ— é™å¢å¤§ï¼›
  * ***çº¿æ€§æ¢æŸ¥æ³•***ï¼ˆLinear Probingï¼‰ï¼šåœ¨å†²çªå‘ç”Ÿæ—¶ï¼ŒæŒ‰ç…§å›ºå®šçš„æ­¥é•¿ï¼Œé€æ­¥æ£€æŸ¥ä¸‹ä¸€ä¸ªæ¡¶ï¼Œç›´åˆ°æ‰¾åˆ°ä¸€ä¸ªç©ºæ§½æ¥å­˜å‚¨å…ƒç´ ã€‚è´Ÿè½½å› å­æœ€å¤§ä¸º 1ã€‚
* **å“ˆå¸Œè¡¨ä¸­é”®çš„éå†é¡ºåºæ˜¯æ— åºçš„**ï¼Œå› ä¸ºéå†è¿‡ç¨‹å®é™…ä¸Šæ˜¯éå†å“ˆå¸Œè¡¨çš„åº•å±‚æ•°ç»„ï¼Œæ•°ç»„ä¸­å…ƒç´ çš„å­˜æ”¾é¡ºåºå¯èƒ½ä¼šç”±äºå“ˆå¸Œè¡¨æ‰©å®¹è€Œå‘ç”Ÿæ”¹å˜ï¼›
* **å“ˆå¸Œè¡¨ä¸­çš„ key å¿…é¡»æ˜¯ä¸å¯å˜ç±»å‹**ï¼Œå› ä¸º key çš„å˜åŒ–ä¼šä½¿åŸæœ‰çš„ç´¢å¼•å¤±æ•ˆï¼Œå¯¼è‡´æ— æ³•æ‰¾åˆ°ä¹‹å‰å­˜å‚¨çš„æ•°æ®ï¼›
* LinkedHashMapï¼šä½¿ç”¨åŒå‘é“¾è¡¨è®°å½•å“ˆå¸Œè¡¨ä¸­é”®å€¼å¯¹çš„æ’å…¥é¡ºåºã€‚åŒå‘é“¾è¡¨å¯ä»¥ä¿è¯å“ˆå¸Œè¡¨å€¼åˆ é™¤çš„ O(1) å¤æ‚åº¦ã€‚

![](1.png)

* ArrayHashMapï¼šä½¿ç”¨æ•°ç»„ç»´æŠ¤åŠ å…¥åˆ°å“ˆå¸Œè¡¨ä¸­çš„æ‰€æœ‰é”®å€¼å¯¹ï¼Œå“ˆå¸Œè¡¨ä¸­å­˜æ”¾ (key, index)ï¼Œæ•°ç»„ä¸­æŒ‰ç…§ index å­˜æ”¾é”®å€¼å¯¹çš„å®é™… Nodeã€‚å¯ç”¨äºä»å“ˆå¸Œè¡¨ä¸­ä»¥ O(1) å¤æ‚åº¦éšæœºè·å¾— keyã€‚<u>ä¸‹è¿°å®ä¾‹ä»£ç æ²¡æœ‰è¿›è¡Œè¶Šç•Œæ£€æŸ¥</u>ã€‚

```cpp
#include <vector>
#include <unordered_map>
#include <random>

struct Node {
  int key;
  int val;
};
class ArrayHashMap {
  std::unordered_map<int, int> map;
  std::vector<Node> arr;
  std::mt19937 gen;  // Mersenne Twister 19937 ä¼ªéšæœºæ•°ç”Ÿæˆå™¨ï¼ˆPRNGï¼‰ï¼Œæä¾›é«˜è´¨é‡çš„ä¼ªéšæœºæ•°ï¼›
public:
  ArrayHashMap() : gen(std::random_device{}()) {}  // éšæœºç§å­ï¼Œå†³å®šéšæœºæ•°çš„èµ·å§‹çŠ¶æ€ï¼›
  void put(int key, int val) {
    arr.push_back({ key, val });
    map[key] = arr.size() - 1;
  }
  int get(int key) {
    auto index = map[key];
    return arr[index].val;
  }
  void remove(int key) {
    // è°ƒæ¢å¾…åˆ é™¤å…ƒç´ å’Œæ•°ç»„å°¾éƒ¨å…ƒç´ ï¼›
    auto index = map[key];
    auto& node = arr.back();
    std::swap(arr[index], node);
    // è°ƒæ•´å°¾éƒ¨å…ƒç´ å­˜å‚¨åœ¨å“ˆå¸Œè¡¨ä¸­çš„ç´¢å¼•ä½ç½®ï¼›
    map[node.key] = index;
    // åˆ é™¤æ•°ç»„å°¾éƒ¨å…ƒç´ ï¼›
    arr.pop_back();
    // åˆ é™¤å“ˆå¸Œè¡¨ä¸­çš„å…ƒç´ ï¼›
    map.erase(key);
  }
  int randomKey() { 
    std::uniform_int_distribution<int> dist(0, arr.size() - 1);
    return arr[dist(gen)].key;
  }
};
```

## äºŒå‰æ ‘

### ç±»åˆ«

* **æ»¡äºŒå‰æ ‘**ï¼ˆPerfect Binary Treeï¼‰ï¼šæ¯ä¸€å±‚èŠ‚ç‚¹éƒ½æ˜¯æ»¡çš„ï¼›
* **å®Œå…¨äºŒå‰æ ‘**ï¼ˆComplete Binary Treeï¼‰ï¼š**æ¯ä¸€å±‚çš„èŠ‚ç‚¹éƒ½ç´§å‡‘é å·¦æ’åˆ—**ï¼Œä¸”é™¤äº†æœ€åä¸€å±‚ï¼Œå…¶ä»–æ¯å±‚éƒ½å¿…é¡»æ˜¯æ»¡çš„ï¼›
  * å®Œå…¨äºŒå‰æ ‘çš„å·¦å³å­æ ‘ä¸­ï¼Œè‡³å°‘æœ‰ä¸€æ£µæ˜¯æ»¡äºŒå‰æ ‘ã€‚
* **äºŒå‰æœç´¢æ ‘**ï¼ˆBinary Search Treeï¼‰ï¼šæ ‘ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹ï¼Œå…¶å·¦å­æ ‘çš„æ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½è¦å°äºè¿™ä¸ªèŠ‚ç‚¹çš„å€¼ï¼Œå³å­æ ‘çš„æ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½è¦å¤§äºè¿™ä¸ªèŠ‚ç‚¹çš„å€¼ã€‚ä½ å¯ä»¥ç®€å•è®°ä¸ºã€Œå·¦å°å³å¤§ã€ã€‚**äºŒå‰æœç´¢æ ‘çš„æ€§èƒ½å–å†³äºæ ‘çš„é«˜åº¦ï¼Œæ ‘çš„é«˜åº¦å–å†³äºæ ‘çš„å¹³è¡¡æ€§**ã€‚
  * ä¸»è¦çš„å®é™…åº”ç”¨æ˜¯ TreeMap å’Œ TreeSetï¼ŒTreeMap ç±»ä¼¼äºå“ˆå¸Œè¡¨ï¼Œå®ƒæŠŠé”®å€¼å¯¹å­˜å‚¨åœ¨ä¸€æ£µäºŒå‰æœç´¢æ ‘çš„èŠ‚ç‚¹é‡Œã€‚TreeMap ä¸­çš„é”®å€¼å¯¹æŒ‰ç…§ key è‡ªåŠ¨æ’åºï¼Œæ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾çš„æ—¶é—´å¤æ‚åº¦ä¸º O(logN)ã€‚
* **å¹³è¡¡äºŒå‰æ ‘**ï¼ˆBalanced Binary Treeï¼‰ï¼š**å®ƒçš„ã€Œæ¯ä¸ªèŠ‚ç‚¹ã€çš„å·¦å³å­æ ‘çš„é«˜åº¦å·®ä¸è¶…è¿‡ 1**ã€‚å‡è®¾å¹³è¡¡äºŒå‰æ ‘ä¸­å…±æœ‰ N ä¸ªèŠ‚ç‚¹ï¼Œé‚£ä¹ˆå¹³è¡¡äºŒå‰æ ‘çš„é«˜åº¦æ˜¯ O(logN)ã€‚

### æ ‘çš„å„ç§éå†

* åœ¨å®é™…çš„ç®—æ³•é—®é¢˜ä¸­ï¼Œ**DFS ç®—æ³•å¸¸ç”¨æ¥ç©·ä¸¾æ‰€æœ‰è·¯å¾„ï¼ŒBFS ç®—æ³•å¸¸ç”¨æ¥å¯»æ‰¾æœ€çŸ­è·¯å¾„**ã€‚

#### é€’å½’éå†ï¼ˆDFSï¼‰

* å‰åºä½ç½®ï¼šåœ¨åˆšåˆšè¿›å…¥ä¸€ä¸ªäºŒå‰æ ‘èŠ‚ç‚¹çš„æ—¶å€™æ‰§è¡Œï¼›
* ä¸­åºä½ç½®ï¼šåœ¨ä¸€ä¸ªäºŒå‰æ ‘èŠ‚ç‚¹å·¦å­æ ‘éƒ½éå†å®Œï¼Œå³å°†å¼€å§‹éå†å³å­æ ‘çš„æ—¶å€™æ‰§è¡Œã€‚BST çš„ä¸­åºéå†ç»“æœæ˜¯æœ‰åºçš„ï¼›
* ååºä½ç½®ï¼šåœ¨å°†è¦ç¦»å¼€ä¸€ä¸ªäºŒå‰æ ‘èŠ‚ç‚¹çš„æ—¶å€™æ‰§è¡Œã€‚

```cpp
struct TreeNode {
  TreeNode* left;
  TreeNode* right;
  int val;
  TreeNode(int val) : left(nullptr), right(nullptr), val(val) {}
};
void traverse(TreeNode* root) {
  if (!root) return;
  // å‰åºä½ç½®ï¼›
  traverse(root->left);
  // ä¸­åºä½ç½®ï¼›
  traverse(root->right);
  // ååºä½ç½®ï¼›
}
```

#### å±‚åºéå†ï¼ˆBFSï¼‰

* å¯ä»¥è®°å½•éå†å±‚çº§çš„å†™æ³•æ¡†æ¶ï¼š

```cpp
void bfsBinaryTreeTraverse(TreeNode* root) {
  if (!root) return;
  std::queue<TreeNode*> q;
  q.push(root);

  size_t depth = 1;
  while (!q.empty()) {
    int sz = q.size();
    while (sz-- > 0) {  // å¤„ç†å½“å‰å±‚çš„æ‰€æœ‰èŠ‚ç‚¹ï¼›
      auto& node = q.front();
      q.pop();
      if (node->left) {
        q.push(node->left);
      }
      if (node->right) {
        q.push(node->right);
      }
    }
    ++depth;
  }
}
```

* å¸¦æœ‰èŠ‚ç‚¹è·¯å¾„æƒé‡å’Œçš„å†™æ³•æ¡†æ¶ï¼š

```cpp
struct State {
  TreeNode* node;
  size_t depth;
};
void bfsBinaryTreeTraverseWithPriority(TreeNode* root) {
  if (!root) return;
  std::queue<State> q;
  q.push({ root, 1 });
  while (!q.empty()) {
    auto& cur = q.front();
    q.pop();
    if (cur.node->left) {
      q.push({ cur.node->left, cur.depth + 1 });
    }
    if (cur.node->right) {
      q.push({ cur.node->right, cur.depth + 1 });
    }
  }
}
```

## å¤šå‰æ ‘

* æ£®æ—æ˜¯å¤šä¸ªå¤šå‰æ ‘çš„é›†åˆã€‚ä¸€æ£µå¤šå‰æ ‘ä¹Ÿæ˜¯ä¸€ä¸ªç‰¹æ®Šçš„æ£®æ—ã€‚

### é€’å½’éå†ï¼ˆDFSï¼‰

```cpp
struct TreeNode {
  int val;
  std::vector<TreeNode*> children;
};
void traverse(TreeNode* root) {
  if (!root) return;
  // å‰åºä½ç½®ï¼›
  for (auto child : root->children) {
    traverse(child);
  }
  // ååºä½ç½®ï¼›
}
```

### å±‚åºéå†ï¼ˆBFSï¼‰

```cpp
void bfsTraverse(TreeNode* root) {
  if (!root) return;
  std:queue<TreeNode*> q;
  q.push(root);
  while (!q.empty()) {
    auto node = q.front();
    q.pop();
    for (auto child : node->children) {
      q.push(child);
    }
  }
}

void bfsBinaryTreeTraverseWithPriority(TreeNode* root) {
  if (!root) return;
  std::queue<TreeNode*> q;
  q.push(root);
  size_t depth = 1;
  while (!q.empty()) {
    size_t sz = q.size();
    while (sz-- > 0) {
      auto cur = q.front();
      q.pop();
      for (auto child : cur->children) {
        q.push(child);
      }
    }
    ++depth;
  }
}

struct State {
  TreeNode* node;
  size_t depth;
};
void bfsBinaryTreeTraverseWithPriorityAsState(TreeNode* root) {
  if (!root) return;
  std::queue<State> q;
  q.push({ root, 1 });
  while (!q.empty()) {
    auto cur = q.front();
    q.pop();
    for (auto child : cur.node->children) {
      q.push({ child, cur.depth + 1 });
    }
  }
}
```

## äºŒå‰å †

* äºŒå‰å †æ˜¯ä¸€ç§æ‹¥æœ‰ç‰¹æ®Šæ€§è´¨çš„å®Œå…¨äºŒå‰æ ‘ï¼Œè¿™æ£µäºŒå‰æ ‘ä¸Šçš„ä»»æ„èŠ‚ç‚¹çš„å€¼ï¼Œéƒ½å¿…é¡»å¤§äºç­‰äºï¼ˆæˆ–å°äºç­‰äºï¼‰å…¶å·¦å³å­æ ‘æ‰€æœ‰èŠ‚ç‚¹çš„å€¼ã€‚å¦‚æœæ˜¯å¤§äºç­‰äºï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºã€Œ**å¤§é¡¶å †**ã€ï¼Œå¦‚æœæ˜¯å°äºç­‰äºï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºã€Œ**å°é¡¶å †**ã€ï¼›
* ä¸€ä¸ªäºŒå‰å †çš„å·¦å³å­å †ï¼ˆå­æ ‘ï¼‰ä¹Ÿæ˜¯ä¸€ä¸ªäºŒå‰å †ã€‚è¿™ä¸ªæ€§è´¨ä¸»è¦åœ¨å †æ’åºç®—æ³•çš„ä¼˜åŒ–ä¸­æœ‰ç”¨åˆ°ï¼›
* ä¸»è¦æ“ä½œå°±ä¸¤ä¸ªï¼šsinkï¼ˆä¸‹æ²‰ï¼‰ã€swimï¼ˆä¸Šæµ®ï¼‰ï¼Œç”¨ä»¥ç»´æŠ¤äºŒå‰å †çš„æ€§è´¨ã€‚
* ä¸»è¦åº”ç”¨æœ‰ä¸¤ä¸ªï¼š
  * ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ˆPriority Queueï¼‰ï¼Œå¢åˆ å…ƒç´ çš„å¤æ‚åº¦æ˜¯ O(logN)ï¼›
  * å †æ’åºï¼ˆHeap Sortï¼‰ã€‚

### ä¼˜å…ˆçº§é˜Ÿåˆ—

* [ğŸ”´ <b>[åˆå¹¶ K ä¸ªå‡åºé“¾è¡¨](https://leetcode.cn/problems/merge-k-sorted-lists/)</b>]ï¼šä¼˜å…ˆé˜Ÿåˆ—ï¼ˆæœ€å°å †ï¼‰ + è™šæ‹Ÿå¤´ç»“ç‚¹éå†ï¼›
* [ğŸŸ  <b>[æœ‰åºçŸ©é˜µä¸­ç¬¬ K å°çš„å…ƒç´ ](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/)</b>]ï¼šåç»­åŠ å…¥ä¼˜å…ˆé˜Ÿåˆ—çš„å…ƒç´ éœ€è¦é€šè¿‡çŸ©é˜µçš„ xã€y åæ ‡è·å–ï¼Œè¿™äº›ä¿¡æ¯éœ€è¦è¢«åŒæ—¶ä¿å­˜åœ¨é˜Ÿåˆ—å…ƒç´ ä¸­ï¼›

```cpp
// ç®€åŒ–å°é¡¶å †å®ç°ï¼›
#include<vector>
#include<iostream>
#include<algorithm>
class PriorityQueue {
  std::vector<int> heap;
  size_t size = 0;

  static int parent(size_t node) {
    return (node - 1) / 2;
  }
  static int left(size_t node) {
    return node * 2 + 1;
  }
  static int right(size_t node) {
    return node * 2 + 2;
  }
  void swim(size_t node) {
    while (node > 0 && heap[node] < heap[parent(node)]) {
      std::swap(heap[node], heap[parent(node)]);
      node = parent(node);
    }
  }
  void sink(size_t node) {
    while (left(node) < size) {  // å®Œå…¨äºŒå‰æ ‘ï¼Œåªè¦æœ‰å·¦å­èŠ‚ç‚¹å°±ç»§ç»­ï¼›
      // æ¯”è¾ƒè‡ªå·±å’Œå·¦å³å­èŠ‚ç‚¹ï¼Œçœ‹çœ‹è°æœ€å°ï¼›
      auto min = node;
      if (left(node) < size && heap[left(node)] < heap[min]) {
        min = left(node);
      }
      if (right(node) < size && heap[right(node)] < heap[min]) {
        min = right(node);
      }
      if (min == node) break;
      std::swap(heap[node], heap[min]);  // å¦‚æœå·¦å³å­èŠ‚ç‚¹ä¸­æœ‰æ¯”è‡ªå·±å°çš„ï¼Œå°±äº¤æ¢ï¼›
      node = min;
    }
  }
public:
  PriorityQueue(int capacity) {
    heap.resize(capacity);
  }
  auto peak() {
    return heap[0];
  }
  // å‘å †ä¸­æ’å…¥ä¸€ä¸ªå…ƒç´ ï¼Œæ—¶é—´å¤æ‚åº¦ O(logN)ï¼›
  auto push(int x) {
    heap[size] = x;  // æŠŠæ–°å…ƒç´ è¿½åŠ åˆ°æœ€åï¼ˆæœ€åä¸€å±‚çš„æœ€å³ï¼Œä¿æŒå®Œå…¨äºŒå‰æ ‘ï¼‰ï¼›
    ++size;
    swim(size - 1);  // å‘å †é¡¶ä¸Šæµ®å…ƒç´ ï¼›
  }
  // åˆ é™¤æ ˆé¡¶å…ƒç´ ï¼Œæ—¶é—´å¤æ‚åº¦ O(logN)ï¼›
  auto pop() {
    int n = heap[0];
    heap[0] = heap[size - 1];  // æŠŠå †åº•å…ƒç´ æ”¾åˆ°å †é¡¶ï¼›
    --size;
    sink(0);  // ä¸‹æ²‰ä½äºå †é¡¶çš„å…ƒç´ ï¼Œä½¿å…¶ä½äºæ­£ç¡®ä½ç½®ï¼›
    return n;
  }
};
```

## é˜Ÿåˆ— / æ ˆ

* [ğŸŸ  <b>[é‡æ’é“¾è¡¨](https://leetcode.cn/problems/reorder-list/description/)</b>]ï¼šç”¨æ ˆå­˜å‚¨èŠ‚ç‚¹ï¼Œç„¶åé€†åºå–å‡ºé‡æ–°æ’åˆ—ï¼›
* åº•å±‚å‡æ˜¯æ•°ç»„æˆ–é“¾è¡¨å®ç°ï¼Œå¯ä»¥ç”¨ä¸¤ä¸ªæ ˆå®ç°é˜Ÿåˆ—ï¼š

```cpp
class Queue {
  stack<int> s1, s2;  // ä¸¤ä¸ªèƒŒå¯¹æ–¹å‘çš„æ ˆï¼›
public:
  void push(int x) {
    s2.push(x);  // æ–°å…ƒç´ æ°¸è¿œ push å…¥å³ä¾§çš„æ ˆï¼›
  }
  int pop() {
    peek();  // å·¦ä¾§æ ˆæ˜¯å¦è¿˜æœ‰å…ƒç´ ï¼Œæ²¡æœ‰åˆ™ä»å³ä¾§æ ˆæ¬ç§»è¿‡æ¥ï¼›
    auto r = s1.top();
    s1.pop();
    return r;
  }
  int peek() {
    if (s1.empty()) {
      while (!s2.empty()) {  // å°†å³ä¾§æ ˆä¸­çš„å…ƒç´ ä¾æ¬¡æ¬å…¥å·¦ä¾§æ ˆï¼›
        const auto v = s2.top();
        s1.push(v);
        s2.pop();
      }
    }
    return s1.top();
  }
  auto empty() {
    return s1.empty() && s2.empty();
  }
};
```

### å•è°ƒæ ˆï¼ˆMonotonic Stackï¼‰

![](4.png)

* æ–°å…ƒç´ å…¥æ ˆåï¼Œæ ˆå†…çš„å…ƒç´ éƒ½ä¿æŒæœ‰åºï¼ˆå•è°ƒé€’å¢æˆ–å•è°ƒé€’å‡ï¼‰ã€‚
* å¸¸ç”¨äºè§£å†³çš„é—®é¢˜ï¼š
  * æ¯ä¸ªå…ƒç´ å·¦ / å³è¾¹ç¬¬ä¸€ä¸ªå¤§ / å°çš„å…ƒç´ ï¼›
  * æ¯æ—¥æ¸©åº¦ï¼›

```cpp
vector<int> dailyTemperatures(vector<int>& temperatures) {
  int n = temperatures.size();
  vector<int> res(n);
  stack<int> stk; // å­˜æ”¾ä¸‹æ ‡ï¼Œä¿è¯æ ˆå†… temperatures[stk.top()] å•è°ƒé€’å‡ï¼›

  for (int i = n - 1; i >= 0; --i) {  // ä»åå¾€å‰éå†ï¼Œå¾—åˆ°æ¯ä¸€ä¸ªå·¦ä¾§å…ƒç´ å³ä¾§æœ€è¿‘çš„å¤§äºå…ƒç´ ï¼›
    /**
     * æƒ³æ‰¾å¤§å…ƒç´ ï¼Œå°±åœ¨å…¥æ ˆå‰æŠŠæ ˆé‡Œæ¯”å®ƒå°çš„å…ƒç´ è¸¢æ‰ã€‚
     * æƒ³æ‰¾å°å…ƒç´ ï¼Œå°±åœ¨å…¥æ ˆå‰æŠŠæ ˆé‡Œæ¯”å®ƒå¤§çš„å…ƒç´ è¸¢æ‰ã€‚
     */
    // å¼¹å‡ºæ‰€æœ‰æ¯”å½“å‰æ¸©åº¦å°æˆ–ç›¸ç­‰çš„ç´¢å¼•ï¼›
    while (!stk.empty() && temperatures[i] >= temperatures[stk.top()]) {
      stk.pop();
    }
    // å¦‚æœæ ˆä¸ä¸ºç©ºï¼Œè¯´æ˜æ‰¾åˆ°äº†ä¸‹ä¸€ä¸ªæ›´é«˜æ¸©åº¦çš„ä¸‹æ ‡ï¼›
    res[i] = stk.empty() ? 0 : stk.top() - i;
    stk.push(i); // å½“å‰ç´¢å¼•å…¥æ ˆï¼›
  }
  return res;
}
```

### å•è°ƒé˜Ÿåˆ—ï¼ˆMonotonic Queueï¼‰

* æ–°å…ƒç´ å…¥é˜Ÿåˆ—åï¼Œé˜Ÿåˆ—å†…çš„å…ƒç´ éƒ½ä¿æŒæœ‰åºï¼ˆå•è°ƒé€’å¢æˆ–å•è°ƒé€’å‡ï¼‰ã€‚
* ä¸»è¦ç”¨äº**è¾…åŠ©æ»‘åŠ¨çª—å£ç›¸å…³é—®é¢˜**ã€‚

```cpp
class MonotonicQueue {
  list<int> maxq;  // åŒå‘é“¾è¡¨ï¼Œå¯ä»¥å¿«é€Ÿåœ¨å¤´å°¾è¿›è¡Œæ“ä½œï¼›
public:
  void push(int n) {
    while (!maxq.empty() && maxq.back() < n) {
      maxq.pop_back();  // åœ¨é˜Ÿå°¾ç§»é™¤å°å…ƒç´ ï¼›
    }
    maxq.push_back(n);
  }
  auto max() {
    return maxq.front();  // é˜Ÿå¤´ä¸ºæœ€å¤§å…ƒç´ ï¼›
  }
  void pop(int n) {
    if (n == maxq.front()) {  // åˆ¤æ–­é˜Ÿå¤´å…ƒç´ æ˜¯å¦è¿˜å­˜åœ¨ï¼ˆå¯èƒ½åœ¨ä¸Šä¸€æ­¥ push æ—¶è¢«ç§»é™¤ï¼‰ï¼›
      maxq.pop_front();  // ç§»é™¤é˜Ÿå¤´çš„å…ƒç´ ï¼›
    }
  } 
};

```

## æ’åºç®—æ³•

### å¿«é€Ÿæ’åº

```cpp

```

## çº¿æ®µæ ‘

![](2.png)

* ç”¨äºé«˜æ•ˆè§£å†³**æ•°ç»„çš„åŒºé—´æŸ¥è¯¢å’ŒåŒºé—´åŠ¨æ€ä¿®æ”¹é—®é¢˜**ï¼›
* å¯ä»¥åœ¨ O(logN) çš„æ—¶é—´å¤æ‚åº¦æŸ¥è¯¢ä»»æ„é•¿åº¦çš„åŒºé—´å…ƒç´ èšåˆå€¼ï¼Œåœ¨ O(logN) çš„æ—¶é—´å¤æ‚åº¦å¯¹ä»»æ„é•¿åº¦çš„åŒºé—´å…ƒç´ è¿›è¡ŒåŠ¨æ€ä¿®æ”¹ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„ä¸­çš„å…ƒç´ ä¸ªæ•°ã€‚


### é“¾å¼ç»“æ„

```cpp
// çº¿æ®µæ ‘èŠ‚ç‚¹ï¼›
struct SegmentNode {
  size_t l, r;  // è¯¥èŠ‚ç‚¹è¡¨ç¤ºçš„åŒºé—´èŒƒå›´ [l, r]ï¼›
  int mergeVal;
  SegmentNode* left = nullptr;
  SegmentNode* right = nullptr;
  SegmentNode(int mergeVal, size_t l, size_t r) : mergeVal(mergeVal), l(l), r(r) {}
};
class SegmentTree {
  SegmentNode* root;
  std::function<int(int, int)> merger;
  SegmentNode* build(const std::vector<int>& nums, int l, int r) {
    if (l == r) {
      return new SegmentNode(nums[l], l, r);
    }
    int mid = l + (r - l) / 2;
    auto left = build(nums, l, mid);
    auto right = build(nums, mid + 1, r);
    auto node = new SegmentNode(merger(left->mergeVal, right->mergeVal), l, r);
    node->left = left;
    node->right = right;
    return node;
  }

  void update(SegmentNode* node, int index, int value) {
    // æ‰¾åˆ°ç›®æ ‡èŠ‚ç‚¹ï¼›
    if (node->l == node->r) {
      node->mergeVal = value;
      return;
    }
    int mid = node->l + (node->r - node->l) / 2;
    if (index <= mid) {
      // è‹¥ index è¾ƒå°ï¼Œåˆ™å»å·¦å­æ ‘æ›´æ–°ï¼›
      update(node->left, index, value);
    } else {
      // è‹¥ index è¾ƒå¤§ï¼Œåˆ™å»å³å­æ ‘æ›´æ–°ï¼›
      update(node->right, index, value);
    }
    // åœ¨åç»­ä½ç½®æ›´æ–°çˆ¶èŠ‚ç‚¹çš„å€¼ï¼›
    node->mergeVal = merger(node->left->mergeVal, node->right->mergeVal);
  }
  int query(SegmentNode* node, int qL, int qR) {
    if (node->l == qL && node->r == qR) {
      return node->mergeVal;
    }

    // æœªç›´æ¥å‘½ä¸­åŒºé—´ï¼Œéœ€è¦å‘ä¸‹æŸ¥æ‰¾ï¼›
    int mid = node->l + (node->r - node->l) / 2;
    if (qR <= mid) {
      return query(node->left, qL, qR);
    } else if (qL > mid) {
      return query(node->right, qL, qR);
    } else {
      // node.l <= qL <= mid < qR <= node.rï¼›
      // ç›®æ ‡åŒºé—´æ¨ªè·¨å·¦å³å­æ ‘ï¼›
      return merger(
        query(node->left, qL, mid),
        query(node->right, mid + 1, qR)
      );
    }
  }
public:
  SegmentTree(const std::vector<int>& nums, std::function<int(int, int)> merger) : merger(merger) {
    root = build(nums, 0, nums.size() - 1);
  }

  void update(int index, int value) {
    update(root, index, value);
  }

  int query(int qL, int qR) {
    return query(root, qL, qR);
  }
};
```

### æ•°ç»„å®ç°

```cpp

```


## æŠ€å·§

### åˆ†æ²»ç®—æ³• & åˆ†æ²»æ€æƒ³

* åˆ†æ²»æ€æƒ³ï¼šæŠŠä¸€ä¸ªé—®é¢˜åˆ†è§£æˆè‹¥å¹²ä¸ªå­é—®é¢˜ï¼Œç„¶ååˆ†åˆ«è§£å†³è¿™äº›å­é—®é¢˜ï¼Œæœ€ååˆå¹¶å­é—®é¢˜çš„è§£å¾—åˆ°åŸé—®é¢˜çš„è§£ï¼Œè¿™ç§æ€æƒ³å¹¿æ³›å­˜åœ¨äºé€’å½’ç®—æ³•ä¸­ã€‚

### é“¾è¡¨åŒæŒ‡é’ˆ

* å½“éœ€è¦åˆ›é€ ä¸€æ¡æ–°é“¾è¡¨çš„æ—¶å€™ï¼Œå¯ä»¥ä½¿ç”¨**è™šæ‹Ÿå¤´ç»“ç‚¹**ç®€åŒ–è¾¹ç•Œæƒ…å†µçš„å¤„ç†ã€‚

```cpp
// dummy.next æ°¸è¿œæŒ‡å‘æ–°é“¾è¡¨ï¼ŒdummyCursor ç”¨æ¥æ¸¸åŠ¨ï¼›
ListNode dummy(-1), *dummyCursor = &dummy;
```

* å¦‚æœéœ€è¦æŠŠåŸé“¾è¡¨çš„èŠ‚ç‚¹æ¥åˆ°æ–°é“¾è¡¨ä¸Šï¼Œè€Œä¸æ˜¯ new æ–°èŠ‚ç‚¹æ¥ç»„æˆæ–°é“¾è¡¨çš„è¯ï¼Œé‚£ä¹ˆæ–­å¼€èŠ‚ç‚¹å’ŒåŸé“¾è¡¨ä¹‹é—´çš„é“¾æ¥å¯èƒ½æ˜¯å¿…è¦çš„ï¼›
* **å¦‚ä½•åªéå†ä¸€æ¬¡é“¾è¡¨ï¼Œå°±å¾—åˆ°å€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹ï¼Ÿ**ç¬¬ä¸€ä¸ªæŒ‡é’ˆå…ˆèµ° k æ­¥ï¼Œç¬¬äºŒä¸ªæŒ‡é’ˆæ¥ç€ä»é“¾è¡¨å¤´éƒ¨ä¸ç¬¬ä¸€ä¸ªæŒ‡é’ˆåŒæ­¥å‘å°¾éƒ¨ç§»åŠ¨ã€‚å½“ç¬¬äºŒä¸ªæŒ‡é’ˆåˆ°è¾¾æœ€åä¸€ä¸ªèŠ‚ç‚¹åæ—¶ï¼Œç¬¬ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘çš„å°±æ˜¯é“¾è¡¨å€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹ï¼›
* **å¿«æ…¢æŒ‡é’ˆ**ï¼ˆFloyd ç®—æ³•ï¼‰ï¼šä¸¤ä¸ªæŒ‡é’ˆå‡ä»é“¾è¡¨å¤´å¼€å§‹ç§»åŠ¨ï¼Œæ¯å½“æ…¢æŒ‡é’ˆ slow å‰è¿›ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆ fast å°±å‰è¿› n æ­¥ï¼Œè¿™æ ·ï¼Œå½“ fast èµ°åˆ°é“¾è¡¨æœ«å°¾æ—¶ï¼Œslow å°±æŒ‡å‘äº†é“¾è¡¨ä½ 1/n å¤„çš„èŠ‚ç‚¹ã€‚è¯¥æŠ€å·§å¯ç”¨äºåˆ¤æ–­é“¾è¡¨æ˜¯å¦æœ‰ç¯ã€‚

```cpp
ListNode* middleNode(ListNode* head) {
  ListNode* slow = head;
  ListNode* fast = head;
  while (fast && fast->next) {
    slow = slow->next;
    fast = fast->next->next;
  }
  return slow;
}
```

### æ•°ç»„

* åŒæŒ‡é’ˆã€å¿«æ…¢æŒ‡é’ˆï¼›
* **æ»‘åŠ¨çª—å£**ï¼šå¿«æ…¢æŒ‡é’ˆçš„ä¸€ç§å˜ä½“ï¼Œä¸€å¿«ä¸€æ…¢ä¸¤ä¸ªæŒ‡é’ˆå‰åç›¸éšï¼Œä¸­é—´çš„éƒ¨åˆ†å°±æ˜¯çª—å£ã€‚è¯¥æŠ€å·§ä¸»è¦ç”¨æ¥è§£å†³å­æ•°ç»„é—®é¢˜ï¼Œæ¯”å¦‚ï¼š**å¯»æ‰¾ç¬¦åˆæŸä¸ªæ¡ä»¶çš„æœ€é•¿/æœ€çŸ­å­æ•°ç»„**ã€‚
  * [ğŸ”´ <b>[æœ€å°è¦†ç›–å­ä¸²](https://leetcode.cn/problems/minimum-window-substring/)</b>]ã€‚

```cpp
// ä¸€ä¸ªç»å…¸çš„æ»‘åŠ¨çª—å£ç»“æ„ï¼š
string minWindow(string s, string t) {
  std::unordered_map<char, size_t> win, need;
  for (const char ch : t) {
    need[ch]++;
  }
  size_t left = 0, right = 0;
  size_t valid = 0;
  size_t start = 0, len = INT_MAX;
  // çª—å£ç”± leftã€right ç»„æˆï¼Œå·¦é—­å³å¼€ï¼›
  while (right < s.size()) {
    // ç§»åŠ¨çª—å£å³è¾¹ï¼›
    const auto ch = s.at(right);
    if (need.count(ch)) {
      win[ch]++;
      if (win[ch] == need[ch]) {
        ++valid;
      }
    }
    ++right;

    while (valid == need.size()) {
      if (right - left < len) {
        start = left;
        len = right - left;
      }
      const auto ch = s.at(left);
      if (need.count(ch)) {
        if (win[ch] == need[ch])
          --valid;
        --win[ch];
      }
      ++left;
    }
  }
  return len == INT_MAX ? "" : s.substr(start, len);
}
```

* **äºŒåˆ†æœç´¢**ï¼š
  * [ğŸŸ  <b>[æœ€å°è¦†ç›–å­ä¸²](https://leetcode.cn/problems/koko-eating-bananas/)</b>]ï¼›
  * [ğŸŸ  <b>[åœ¨ D å¤©å†…é€è¾¾åŒ…è£¹çš„èƒ½åŠ›](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/description/)</b>]ï¼›
  * [ğŸ”´ <b>[åˆ†å‰²æ•°ç»„çš„æœ€å¤§å€¼](https://leetcode.cn/problems/split-array-largest-sum/description/)</b>]ï¼›
  * è§£é¢˜æ€è·¯ï¼š
    1. é¢˜ç›®é—®ä»€ä¹ˆï¼Œä»€ä¹ˆå°±æ˜¯è‡ªå˜é‡ xï¼Œç„¶åå†™å‡º f(x) çš„é€»è¾‘ã€‚target å¯¹åº”å‡½æ•°è¿”å›å€¼ï¼›
    2. æ‰¾åˆ° x çš„å·¦å³èŒƒå›´ï¼Œè®¾å®š left ä¸ right çš„è¾¹ç•Œï¼›
    3. ç¡®å®šæŸ¥æ‰¾ left-bound è¿˜æ˜¯ right-bound è§£é¢˜ã€‚

```cpp
// æ™®é€šç‰ˆï¼›
int binarySearch(vector<int>& nums, int target) {
  int left = 0, right = nums.size() - 1;
  while (left <= right) {  // æ­¤æ—¶ [left, right] å‡ä¸ºé—­åŒºé—´ï¼›
    const auto mid = left + (right - left) / 2;
    if (nums[mid] == target) return mid;
    else if (nums[mid] < target) {
      // target åœ¨å³ä¾§ï¼Œæ›´æ–° leftï¼›
      left = mid + 1;  // [left, right] éƒ½æ˜¯å¾…æœç´¢çš„é—­åŒºé—´ï¼›
    } else {
      right = mid - 1;
    }
  }
  return -1;
}
// æŸ¥æ‰¾ç›®æ ‡å·¦å³è¾¹ç•Œç‰ˆï¼›
int leftBound(vector<int>& nums, int target) {
  int left = 0, right = nums.size() - 1;
  while (left <= right) {  // æ­¤æ—¶ [left, right] å‡ä¸ºé—­åŒºé—´ï¼›
    const auto mid = left + (right - left) / 2;
    if (nums[mid] == target) {
      right = mid - 1;
    } else if (nums[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  if (left >= nums.size()) {
    return -1;
  }
  // è‹¥æ‰¾ä¸åˆ°ï¼Œå¯èƒ½è¿”å›å¤§äº target çš„æœ€å°å…ƒç´ ä½ç½®ï¼›
  return nums[left] == target ? left : -1;
}
int rightBound(vector<int>& nums, int target) {
  int left = 0, right = nums.size() - 1;
  while (left <= right) {  // æ­¤æ—¶ [left, right] å‡ä¸ºé—­åŒºé—´ï¼›
     const auto mid = left + (right - left) / 2;
     if (nums[mid] == target) {
       left = mid + 1;
     } else if (nums[mid] < target) {
       left = mid + 1; 
     } else {
       right = mid - 1;
     }
  }
  if (right < 0) {
    return -1;
  } 
  // è‹¥æ‰¾ä¸åˆ°ï¼Œå¯èƒ½è¿”å›å°äº target çš„æœ€å¤§å…ƒç´ ä½ç½®ï¼›
  return nums[right] == target ? right : -1; 
}
```

* **å‰ç¼€å’Œæ•°ç»„**ï¼š**æ•°ç»„æ¯ä¸€ä¸ªå…ƒç´ éƒ½æ˜¯å‰é¢æ‰€æœ‰å…ƒç´ çš„å’Œ**ï¼Œé€‚ç”¨äºå¿«é€Ÿã€é¢‘ç¹åœ°è®¡ç®—ä¸€ä¸ªç´¢å¼•åŒºé—´å†…çš„å…ƒç´ ä¹‹å’Œã€‚è¿™ä¸ªæŠ€å·§ä¹Ÿå¯ä»¥ç”¨äºäºŒç»´çŸ©é˜µã€‚

```cpp
class NumArray {
public:
  vector<int> prefixArray;
  NumArray(vector<int>& nums) {
    prefixArray.resize(nums.size() + 1);
    prefixArray[0] = 0;  // ä¾¿äºè®¡ç®—ç´¯åŠ å’Œï¼›
    for (size_t i = 1; i <= nums.size(); ++i) {  // æ³¨æ„ i çš„ç»“æŸæ¡ä»¶ï¼Œä¿è¯ nums çš„éå†èŒƒå›´æ˜¯å®Œæ•´çš„ï¼›
      prefixArray[i] = nums[i - 1] + prefixArray[i - 1];
    }
  }
  int sumRange(int left, int right) {
    return prefixArray[right + 1] - prefixArray[left];  // å¾—åˆ°ç´¢å¼•èŒƒå›´ [left, right] çš„æ•°ç»„å…ƒç´ å’Œï¼›
  }
};
```

* **å·®åˆ†æ•°ç»„**ï¼š**æ•°ç»„ä¿å­˜çš„æ˜¯æ¯ä¸ªå…ƒç´ ä¸å‰ä¸€ä¸ªå…ƒç´ çš„å·®å€¼**ï¼Œé€‚ç”¨äºé¢‘ç¹å¯¹åŸå§‹æ•°ç»„çš„æŸä¸ªåŒºé—´çš„å…ƒç´ è¿›è¡Œå¢å‡ã€‚

```cpp
class Difference {
  std::vector<int> diff;
public:
  Difference(std::vector<int>& nums) {
    diff = std::vector<int>(nums.size());
    diff[0] = nums[0];  // ç¬¬ä¸€ä¸ªå…ƒç´ ä¿æŒä¸å˜ï¼›
    for (auto i = 1; i < nums.size(); ++i) {
      diff[i] = nums[i] - nums[i - 1];  // æ„å»ºå·®åˆ†æ•°ç»„ï¼›
    }
  }
  void increment(int i, int j, int val) {  // ç»™æ•°ç»„åŒºé—´ [i, j] å¢åŠ  valï¼›
    diff[i] += val;
    if (j + 1 < diff.size())
      diff[j + 1] -= val;  // æ³¨æ„æ˜¯ç»™åŒºé—´åé¢ç¬¬ä¸€ä¸ªå…ƒç´ å‡å» valï¼›
  }
  auto result() {
    std::vector<int> res(diff.size());
    res[0] = diff[0];
    for (auto i = 1; i < diff.size(); ++i) {
      res[i] = res[i - 1] + diff[i];
    }
    return res;
  }
};
```


### äºŒå‰æ ‘

* **ç›´å¾„**ï¼šå°±æ˜¯æ ‘ä¸­æŸä¸ªèŠ‚ç‚¹çš„å·¦å³å­æ ‘çš„æœ€å¤§æ·±åº¦ä¹‹å’Œã€‚

#### é€’å½’çš„ä¸¤ç§æ€ç»´æ¨¡å¼

* [ğŸŸ¢ <b>[äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)</b>]ï¼šåˆ†åˆ«ç”¨ã€Œåˆ†è§£é—®é¢˜ã€ä¸ã€Œéå†ã€ä¸¤ç§é€’å½’æ€ç»´æ¨¡å¼è§£å†³ï¼›

```cpp
// åˆ†è§£é—®é¢˜çš„æ€ç»´æ¨¡å¼ï¼›
int maxDepth(TreeNode* root) {
  if (!root) return 0;
  // åˆ†è§£é—®é¢˜ï¼šæƒ³è®¡ç®—æ•´é¢—æ ‘çš„æœ€å¤§æ·±åº¦ï¼Œå…ˆè®¡ç®—å·¦å³å­æ ‘çš„æœ€å¤§æ·±åº¦ï¼Œç„¶åå†åŠ è‡ªå·±ï¼ˆ+1ï¼‰ï¼›
  int leftMax = maxDepth(root->left);
  int rightMax = maxDepth(root->right);
  return 1 + max(leftMax, rightMax);
}
```

```cpp
// éå†çš„æ€ç»´æ¨¡å¼ï¼šéå†æ•´æ£µæ ‘ï¼Œé€šè¿‡å…¨å±€çŠ¶æ€è®°å½•é«˜åº¦ï¼›
class Solution {
  int depth = 0;
  int result = 0;
public:
  auto maxDepth(TreeNode* root) {
    traverse(root);
    return result;
  }
  void traverse(TreeNode* root) {
    if (!root) return;
    ++depth;  // è¿›å…¥å½“å‰èŠ‚ç‚¹ï¼Œé«˜åº¦ +1ï¼›
    if (depth > result) result = depth;
    if (root->left) traverse(root->left);
    if (root->right) traverse(root->right);
    --depth;   // å³å°†é€€å‡ºå½“å‰èŠ‚ç‚¹ï¼Œé«˜åº¦ -1ï¼›
  }
};
```

#### äºŒå‰æ ‘æ„é€ 

* [ğŸŸ  <b>[ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)</b>]ï¼›
* [ğŸŸ  <b>[ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/)</b>]ï¼›
  * ç”¨å…ˆåº \ ååºéå†ç»“æœç¡®å®šäºŒå‰æ ‘ä¸­æ¯ä¸ªæ ¹èŠ‚ç‚¹çš„å€¼ï¼Œä¸­åºéå†ç»“æœç¡®å®šèŠ‚ç‚¹çš„å·¦å­æ ‘å’Œå³å­æ ‘ï¼›


### åŠ¨æ€è§„åˆ’ï¼ˆDynamic Programmingï¼‰

* [ğŸŸ  <b>[é¢†é’±å…‘æ¢](https://leetcode.cn/problems/coin-change/description/)</b>]ï¼›
* [ğŸŸ¢ <b>[æ–æ³¢é‚£å¥‘æ•°](https://leetcode.cn/problems/fibonacci-number/description/)</b>]ï¼š
  * **é‡å å­é—®é¢˜**ï¼šæ¯”å¦‚ f(5) çš„è®¡ç®—ä¸­ï¼Œf(3)ã€f(2) è¦é‡å¤è®¡ç®—å¤šæ¬¡ï¼›
  * **ä¼˜åŒ–æ–¹å¼**ï¼š
    * ä½¿ç”¨ã€Œå¤‡å¿˜å½•ã€å­˜å‚¨ä¸­é—´ç»“æœ - é€‚ç”¨äºè‡ªé¡¶å‘ä¸‹çš„è®¡ç®—æ–¹å¼ï¼Œåœ¨é€’å½’è¿‡ç¨‹ä¸­å­˜å‚¨å·²ç»è®¡ç®—è¿‡çš„ç»“æœï¼Œä»¥é¿å…é‡å¤è®¡ç®—ï¼›
    * ä½¿ç”¨ã€ŒDP Tableã€ä¼˜åŒ–ç©·ä¸¾è¿‡ç¨‹ - é€‚ç”¨äºè‡ªåº•å‘ä¸Šçš„è®¡ç®—æ–¹å¼ï¼Œæ˜¾å¼å­˜å‚¨æ‰€æœ‰å­é—®é¢˜çš„è§£ã€‚

```cpp
// è‡ªé¡¶å‘ä¸‹ + å¤‡å¿˜å½•ï¼›
class Solution {
  vector<int> memo;
public:
  int dp(int n) {
    if (n <= 1) return n;
    if (memo[n] != 0) return memo[n];  // ä»å¤‡å¿˜å½•ä¸­æå–ä¹‹å‰çš„è®¡ç®—ç»“æœï¼›
    const int result = dp(n - 1) + dp(n - 2);
    memo[n] = result;  // æ›´æ–°å¤‡å¿˜å½•ï¼›
    return result;
  }
  int fib(int n) {
    memo = vector<int>(n + 1, 0);
    return dp(n);
  }
};
```

```cpp
// è‡ªåº•å‘ä¸Š + DP Tableï¼›
class Solution {
public:
  int fib(int n) {
    if (n <= 1) return n;
    vector<int> dp(n + 1, 0);
    dp[0] = 0, dp[1] = 1;
    for (auto i = 2; i <= n; ++i) {
      dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
  }
};
```

#### ç­”é¢˜æŠ€å·§

1. ç¡®å®šã€ŒçŠ¶æ€ã€ï¼Œä¹Ÿå°±æ˜¯åŸé—®é¢˜å’Œå­é—®é¢˜ä¸­ä¼šå˜åŒ–çš„å˜é‡ï¼›
2. ç¡®å®šã€Œé€‰æ‹©ã€ï¼Œä¹Ÿå°±æ˜¯å¯¼è‡´ã€ŒçŠ¶æ€ã€äº§ç”Ÿå˜åŒ–çš„è¡Œä¸ºï¼›
3. æ˜ç¡®ã€Œdp å‡½æ•°/æ•°ç»„ã€çš„å®šä¹‰ã€‚


### å›æº¯ç®—æ³•

* [ğŸŸ  <b>[å…¨æ’åˆ—](https://leetcode.cn/problems/permutations/description/)</b>]ï¼›

```cpp
class Solution {
  vector<vector<int>> result;
public:
  void iterate(vector<int>& nums, vector<int>& tracks, unordered_map<int, bool>& colorMap) {
    // å›æº¯ -> åœ¨å¾ªç¯é‡Œé€’å½’ï¼›
    // tracks æ”¶é›†æ¯ä¸€ä¸ªè·¯å¾„ï¼Œå½“ nums æ•°å­—å…¨è¢«æ ‡è®°æ—¶æ¨å…¥ resultï¼›
    if (tracks.size() == nums.size()) {
      result.push_back(tracks);
    }
    // åªéå†å½“å‰é€’å½’ä¸­ï¼Œnums æ²¡æœ‰è¢«æ ‡è®°çš„éƒ¨åˆ†ï¼Œå…ƒç´ ä¸é‡å¤é€‰æ‹©ï¼›
  for (auto num : nums) {
      if (colorMap[num]) continue;
      // ä¿®æ”¹çŠ¶æ€ï¼›
      colorMap[num] = true;
      tracks.push_back(num);
      iterate(nums, tracks, colorMap);
      // æ¢å¤çŠ¶æ€ï¼›
      colorMap[num] = false;
      tracks.pop_back();
    }
  }   
  vector<vector<int>> permute(vector<int>& nums) {
    vector<int> tracks;
    unordered_map<int, bool> colorMap; 
    for (auto num: nums) colorMap[num] = false;
    iterate(nums, tracks, colorMap);
    return result;
  }
};
```


### å…¶ä»–æŠ€å·§

* ä¸‘æ•°ï¼ˆUgly Numberï¼‰ï¼šå¦‚æœä¸€ä¸ªæ•° n å¯ä»¥è¡¨ç¤ºä¸ºï¼š<b>n = 2<sup>^a</sup> x 3<sup>^b</sup> x 5<sup>^c</sup></b>ï¼Œå…¶ä¸­ aã€bã€c éƒ½æ˜¯éè´Ÿæ•´æ•°ï¼Œé‚£ä¹ˆè¿™ä¸ªæ•°å°±æ˜¯ä¸€ä¸ªä¸‘æ•°ã€‚
  * [ğŸŸ¢ <b>[ä¸‘æ•°](https://leetcode.cn/problems/ugly-number/description/)</b>]ï¼›
  * [ğŸŸ  <b>[ä¸‘æ•°2](https://leetcode.cn/problems/ugly-number-ii/description/)</b>] - æ‹†è§£ + DPï¼›
* è´¨æ•°ï¼ˆç´ æ•°ï¼ŒPrimeï¼‰ï¼šä¸€ä¸ªæ•°åªèƒ½è¢« 1 å’Œå®ƒæœ¬èº«æ•´é™¤ã€‚Sieve of Eratosthenes ç­›é€‰æ³•ï¼š

![](3.gif)

```cpp
#include <vector>
#include <algorithm>

int countPrimes(int n) {
  if (n < 2) return 0;
  std::vector<bool> isPrime(n, true);
  isPrime[0] = isPrime[1] = false;  // 0 å’Œ 1 ä¸æ˜¯è´¨æ•°ï¼›
  for (int i = 2; i * i < n; ++i) {
    if (isPrime[i]) {
      for (int j = i * i; j < n; j += i) {
        isPrime[j] = false;
      }
    }
  }
  return std::count(isPrime.begin(), isPrime.end(), true);
}

```








  
