---
title: è‡ªç”¨ç®—æ³•æ¨¡ç‰ˆ
intro: è‡ªç”¨ç®—æ³•æ¨¡ç‰ˆã€‚
comments: true
date: 2025-04-08 10:34:00
tags:
- Algorithm
- ç®—æ³•
---

## æ•°ç»„é“¾è¡¨

* **æ•°ç»„**ï¼š
  * å†…å­˜è¿ç»­ âœ…ï¼›
  * æ”¯æŒå…ƒç´ çš„éšæœºè®¿é—®ï¼Œæ—¶é—´å¤æ‚åº¦ O(1) âœ…ã€‚
  * ä¸é€‚ç”¨äºéœ€è¦é¢‘ç¹æ’å…¥ \ åˆ é™¤çš„æ“ä½œ âŒï¼›
  * å¤§å°å›ºå®šï¼Œæ‰©å®¹éœ€æ¬ç§»å…ƒç´  âŒã€‚
  * åŠ¨æ€æ•°ç»„åº•å±‚è¿˜æ˜¯é™æ€æ•°ç»„ï¼Œä¼šä½¿ç”¨åŠ¨æ€æ‰©å®¹æœºåˆ¶è‡ªåŠ¨æ‰©å®¹ã€‚
* **é“¾è¡¨**ï¼š
  * é€‚ç”¨äºéœ€è¦é¢‘ç¹æ’å…¥ \ åˆ é™¤çš„æ“ä½œ âœ…ï¼›
  * å¤§å°å¯ä»¥åŠ¨æ€æ‰©å±• âœ…ã€‚
  * åœ¨å†…å­˜çš„ç¼“å­˜ç©ºé—´å±€éƒ¨æ€§ï¼ˆSpatial Localityï¼‰ä¸Šç›¸è¾ƒæ•°ç»„æ›´å·® âŒï¼›
  * ä¸æ”¯æŒéšæœºè®¿é—®ï¼Œéœ€ä»å¤´ \ å°¾éå†ï¼Œæ—¶é—´å¤æ‚åº¦ O(N) âŒã€‚
* **ç¯å½¢æ•°ç»„**ï¼šç”¨æ±‚æ¨¡è¿ç®—ï¼Œå°†æ™®é€šæ•°ç»„å˜æˆé€»è¾‘ä¸Šçš„ç¯å½¢æ•°ç»„ï¼Œè®©æˆ‘ä»¬å¯ä»¥ç”¨ O(1) çš„æ—¶é—´åœ¨æ•°ç»„å¤´éƒ¨å¢åˆ å…ƒç´ ã€‚

```cpp
#include <iostream>
#include <stdexcept>
#include <ostream>
#include <memory>

class CircularArray {
  // åŒºé—´ [start, end)ã€‚
  std::unique_ptr<int[]> arr = nullptr;
  size_t start; 
  size_t end;
  size_t count;
public:
  CircularArray(size_t size) : count(0), start(0), end(0) {
    arr = std::make_unique<int[]>(size);
  }
  void addFirst(int n) {
    // å…ˆå·¦ç§»ï¼Œå†èµ‹å€¼ï¼›
    start = (start + count - 1) % count;
    arr[start] = n;
    ++count;
  }
  void addLast(int n) {
    // å…ˆèµ‹å€¼ï¼Œå†å³ç§»ï¼›
    arr[end] = n;
    end = (end + 1) % count;
    ++count;
  }
  int removeFirst() {
    // å…ˆä¿å­˜å€¼ï¼Œå†å³ç§»ï¼›
    auto v = arr[start];
    start = (start + 1) % count;
    return v;
  }
  int removeLast() {
    // å…ˆå·¦ç§»ï¼Œå†è¿”å›å€¼ï¼›
    end = (end + count - 1) % count;
    return arr[end];
  }
};  
```

## å“ˆå¸Œè¡¨

* **è´Ÿè½½å› å­**ï¼ˆLoad Factorï¼‰ï¼š`Î± = å­˜å‚¨çš„é”®å€¼å¯¹æ•°é‡ / åº•å±‚æ•°ç»„å¤§å°`ï¼Œè¡¨ç¤ºå“ˆå¸Œè¡¨è£…æ»¡çš„ç¨‹åº¦çš„åº¦é‡ï¼Œå€¼è¶Šå¤§ï¼Œè¯´æ˜å­˜å‚¨çš„é”®å€¼å¯¹è¶Šå¤šã€‚Î± è¿‡å¤§ä¼šå¯¼è‡´å“ˆå¸Œè¡¨æ‰©å®¹ï¼›
* **å“ˆå¸Œå†²çª**ï¼šä¸¤ä¸ªä¸åŒçš„ key é€šè¿‡å“ˆå¸Œå‡½æ•°å¾—åˆ°äº†ç›¸åŒçš„ç´¢å¼•ï¼›
  * ***æ‹‰é“¾æ³•***ï¼ˆChainingï¼‰ï¼šæ¯ä¸ªå“ˆå¸Œæ¡¶ï¼ˆæ§½ï¼‰ä¸ç›´æ¥å­˜å‚¨ä¸€ä¸ªå€¼ï¼Œè€Œæ˜¯å­˜å‚¨ä¸€ä¸ªé“¾è¡¨æˆ–å…¶ä»–æ•°æ®ç»“æ„ï¼ˆå¦‚é“¾è¡¨ã€é“¾è¡¨æ ‘ã€åŠ¨æ€æ•°ç»„ç­‰ï¼‰ï¼Œè¯¥é“¾è¡¨ä¸­ä¿å­˜æ‰€æœ‰æ˜ å°„åˆ°åŒä¸€ä½ç½®çš„å…ƒç´ ã€‚è´Ÿè½½å› å­å¯ä»¥æ— é™å¢å¤§ï¼›
  * ***çº¿æ€§æ¢æŸ¥æ³•***ï¼ˆLinear Probingï¼‰ï¼šåœ¨å†²çªå‘ç”Ÿæ—¶ï¼ŒæŒ‰ç…§å›ºå®šçš„æ­¥é•¿ï¼Œé€æ­¥æ£€æŸ¥ä¸‹ä¸€ä¸ªæ¡¶ï¼Œç›´åˆ°æ‰¾åˆ°ä¸€ä¸ªç©ºæ§½æ¥å­˜å‚¨å…ƒç´ ã€‚è´Ÿè½½å› å­æœ€å¤§ä¸º 1ã€‚
* **å“ˆå¸Œè¡¨ä¸­é”®çš„éå†é¡ºåºæ˜¯æ— åºçš„**ï¼Œå› ä¸ºéå†è¿‡ç¨‹å®é™…ä¸Šæ˜¯éå†å“ˆå¸Œè¡¨çš„åº•å±‚æ•°ç»„ï¼Œæ•°ç»„ä¸­å…ƒç´ çš„å­˜æ”¾é¡ºåºå¯èƒ½ä¼šç”±äºå“ˆå¸Œè¡¨æ‰©å®¹è€Œå‘ç”Ÿæ”¹å˜ï¼›
* **å“ˆå¸Œè¡¨ä¸­çš„ key å¿…é¡»æ˜¯ä¸å¯å˜ç±»å‹**ï¼Œå› ä¸º key çš„å˜åŒ–ä¼šä½¿åŸæœ‰çš„ç´¢å¼•å¤±æ•ˆï¼Œå¯¼è‡´æ— æ³•æ‰¾åˆ°ä¹‹å‰å­˜å‚¨çš„æ•°æ®ï¼›
* LinkedHashMapï¼šä½¿ç”¨åŒå‘é“¾è¡¨è®°å½•å“ˆå¸Œè¡¨ä¸­é”®å€¼å¯¹çš„æ’å…¥é¡ºåºã€‚åŒå‘é“¾è¡¨å¯ä»¥ä¿è¯å“ˆå¸Œè¡¨å€¼åˆ é™¤çš„ O(1) å¤æ‚åº¦ã€‚

![](1.png)

* ArrayHashMapï¼šä½¿ç”¨æ•°ç»„ç»´æŠ¤åŠ å…¥åˆ°å“ˆå¸Œè¡¨ä¸­çš„æ‰€æœ‰é”®å€¼å¯¹ï¼Œå“ˆå¸Œè¡¨ä¸­å­˜æ”¾ (key, index)ï¼Œæ•°ç»„ä¸­æŒ‰ç…§ index å­˜æ”¾é”®å€¼å¯¹çš„å®é™… Nodeã€‚å¯ç”¨äºä»å“ˆå¸Œè¡¨ä¸­ä»¥ O(1) å¤æ‚åº¦éšæœºè·å¾— keyã€‚<u>ä¸‹è¿°å®ä¾‹ä»£ç æ²¡æœ‰è¿›è¡Œè¶Šç•Œæ£€æŸ¥</u>ã€‚

```cpp
#include <vector>
#include <unordered_map>
#include <random>

struct Node {
  int key;
  int val;
};
class ArrayHashMap {
  std::unordered_map<int, int> map;
  std::vector<Node> arr;
  std::mt19937 gen;  // Mersenne Twister 19937 ä¼ªéšæœºæ•°ç”Ÿæˆå™¨ï¼ˆPRNGï¼‰ï¼Œæä¾›é«˜è´¨é‡çš„ä¼ªéšæœºæ•°ï¼›
public:
  ArrayHashMap() : gen(std::random_device{}()) {}  // éšæœºç§å­ï¼Œå†³å®šéšæœºæ•°çš„èµ·å§‹çŠ¶æ€ï¼›
  void put(int key, int val) {
    arr.push_back({ key, val });
    map[key] = arr.size() - 1;
  }
  int get(int key) {
    auto index = map[key];
    return arr[index].val;
  }
  void remove(int key) {
    // è°ƒæ¢å¾…åˆ é™¤å…ƒç´ å’Œæ•°ç»„å°¾éƒ¨å…ƒç´ ï¼›
    auto index = map[key];
    auto& node = arr.back();
    std::swap(arr[index], node);
    // è°ƒæ•´å°¾éƒ¨å…ƒç´ å­˜å‚¨åœ¨å“ˆå¸Œè¡¨ä¸­çš„ç´¢å¼•ä½ç½®ï¼›
    map[node.key] = index;
    // åˆ é™¤æ•°ç»„å°¾éƒ¨å…ƒç´ ï¼›
    arr.pop_back();
    // åˆ é™¤å“ˆå¸Œè¡¨ä¸­çš„å…ƒç´ ï¼›
    map.erase(key);
  }
  int randomKey() { 
    std::uniform_int_distribution<int> dist(0, arr.size() - 1);
    return arr[dist(gen)].key;
  }
};
```

## äºŒå‰æ ‘

### ç±»åˆ«

* **æ»¡äºŒå‰æ ‘**ï¼ˆPerfect Binary Treeï¼‰ï¼šæ¯ä¸€å±‚èŠ‚ç‚¹éƒ½æ˜¯æ»¡çš„ï¼›
* **å®Œå…¨äºŒå‰æ ‘**ï¼ˆComplete Binary Treeï¼‰ï¼š**æ¯ä¸€å±‚çš„èŠ‚ç‚¹éƒ½ç´§å‡‘é å·¦æ’åˆ—**ï¼Œä¸”é™¤äº†æœ€åä¸€å±‚ï¼Œå…¶ä»–æ¯å±‚éƒ½å¿…é¡»æ˜¯æ»¡çš„ï¼›
  * å®Œå…¨äºŒå‰æ ‘çš„å·¦å³å­æ ‘ä¸­ï¼Œè‡³å°‘æœ‰ä¸€æ£µæ˜¯æ»¡äºŒå‰æ ‘ã€‚
* **äºŒå‰æœç´¢æ ‘**ï¼ˆBinary Search Treeï¼‰ï¼šæ ‘ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹ï¼Œå…¶å·¦å­æ ‘çš„æ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½è¦å°äºè¿™ä¸ªèŠ‚ç‚¹çš„å€¼ï¼Œå³å­æ ‘çš„æ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½è¦å¤§äºè¿™ä¸ªèŠ‚ç‚¹çš„å€¼ã€‚ä½ å¯ä»¥ç®€å•è®°ä¸ºã€Œå·¦å°å³å¤§ã€ã€‚**äºŒå‰æœç´¢æ ‘çš„æ€§èƒ½å–å†³äºæ ‘çš„é«˜åº¦ï¼Œæ ‘çš„é«˜åº¦å–å†³äºæ ‘çš„å¹³è¡¡æ€§**ã€‚
  * ä¸»è¦çš„å®é™…åº”ç”¨æ˜¯ TreeMap å’Œ TreeSetï¼ŒTreeMap ç±»ä¼¼äºå“ˆå¸Œè¡¨ï¼Œå®ƒæŠŠé”®å€¼å¯¹å­˜å‚¨åœ¨ä¸€æ£µäºŒå‰æœç´¢æ ‘çš„èŠ‚ç‚¹é‡Œã€‚TreeMap ä¸­çš„é”®å€¼å¯¹æŒ‰ç…§ key è‡ªåŠ¨æ’åºï¼Œæ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾çš„æ—¶é—´å¤æ‚åº¦ä¸º O(logN)ã€‚
* **å¹³è¡¡äºŒå‰æ ‘**ï¼ˆBalanced Binary Treeï¼‰ï¼š**å®ƒçš„ã€Œæ¯ä¸ªèŠ‚ç‚¹ã€çš„å·¦å³å­æ ‘çš„é«˜åº¦å·®ä¸è¶…è¿‡ 1**ã€‚å‡è®¾å¹³è¡¡äºŒå‰æ ‘ä¸­å…±æœ‰ N ä¸ªèŠ‚ç‚¹ï¼Œé‚£ä¹ˆå¹³è¡¡äºŒå‰æ ‘çš„é«˜åº¦æ˜¯ O(logN)ã€‚

### æ ‘çš„å„ç§éå†

* åœ¨å®é™…çš„ç®—æ³•é—®é¢˜ä¸­ï¼Œ**DFS ç®—æ³•å¸¸ç”¨æ¥ç©·ä¸¾æ‰€æœ‰è·¯å¾„ï¼ŒBFS ç®—æ³•å¸¸ç”¨æ¥å¯»æ‰¾æœ€çŸ­è·¯å¾„**ã€‚

#### é€’å½’éå†ï¼ˆDFSï¼‰

* å‰åºä½ç½®ï¼šä¸€ä¸ªèŠ‚ç‚¹åœ¨å®ƒçš„å·¦å³å­æ ‘éå†ä¹‹å‰å˜è“ï¼›
* ä¸­åºä½ç½®ï¼šä¸€ä¸ªèŠ‚ç‚¹åœ¨å®ƒçš„å·¦å­æ ‘éå†å®Œæ—¶æ‰ä¼šå˜è“ã€‚BST çš„ä¸­åºéå†ç»“æœæ˜¯æœ‰åºçš„ï¼›
* ååºä½ç½®ï¼šä¸€ä¸ªèŠ‚ç‚¹åœ¨å®ƒçš„å·¦å³å­æ ‘å‡éå†å®Œåå˜è“ã€‚

```cpp
struct TreeNode {
  TreeNode* left;
  TreeNode* right;
  int val;
  TreeNode(int val) : left(nullptr), right(nullptr), val(val) {}
};
void traverse(TreeNode* root) {
  if (!root) return;
  // å‰åºä½ç½®ï¼›
  traverse(root->left);
  // ä¸­åºä½ç½®ï¼›
  traverse(root->right);
  // ååºä½ç½®ï¼›
}
```

#### å±‚åºéå†ï¼ˆBFSï¼‰

* å¯ä»¥è®°å½•éå†å±‚çº§çš„å†™æ³•æ¡†æ¶ï¼š

```cpp
void bfsBinaryTreeTraverse(TreeNode* root) {
  if (!root) return;
  std::queue<TreeNode*> q;
  q.push(root);

  size_t depth = 1;
  while (!q.empty()) {
    int sz = q.size();
    while (sz-- > 0) {  // å¤„ç†å½“å‰å±‚çš„æ‰€æœ‰èŠ‚ç‚¹ï¼›
      auto& node = q.front();
      q.pop();
      if (node->left) {
        q.push(node->left);
      }
      if (node->right) {
        q.push(node->right);
      }
    }
    ++depth;
  }
}
```

* å¸¦æœ‰èŠ‚ç‚¹è·¯å¾„æƒé‡å’Œçš„å†™æ³•æ¡†æ¶ï¼š

```cpp
struct State {
  TreeNode* node;
  size_t depth;
};
void bfsBinaryTreeTraverseWithPriority(TreeNode* root) {
  if (!root) return;
  std::queue<State> q;
  q.push({ root, 1 });
  while (!q.empty()) {
    auto& cur = q.front();
    q.pop();
    if (cur.node->left) {
      q.push({ cur.node->left, cur.depth + 1 });
    }
    if (cur.node->right) {
      q.push({ cur.node->right, cur.depth + 1 });
    }
  }
}
```

## å¤šå‰æ ‘

* æ£®æ—æ˜¯å¤šä¸ªå¤šå‰æ ‘çš„é›†åˆã€‚ä¸€æ£µå¤šå‰æ ‘ä¹Ÿæ˜¯ä¸€ä¸ªç‰¹æ®Šçš„æ£®æ—ã€‚

### é€’å½’éå†ï¼ˆDFSï¼‰

```cpp
struct TreeNode {
  int val;
  std::vector<TreeNode*> children;
};
void traverse(TreeNode* root) {
  if (!root) return;
  // å‰åºä½ç½®ï¼›
  for (auto child : root->children) {
    traverse(child);
  }
  // ååºä½ç½®ï¼›
}
```

### å±‚åºéå†ï¼ˆBFSï¼‰

```cpp
void bfsTraverse(TreeNode* root) {
  if (!root) return;
  std:queue<TreeNode*> q;
  q.push(root);
  while (!q.empty()) {
    auto node = q.front();
    q.pop();
    for (auto child : node->children) {
      q.push(child);
    }
  }
}

void bfsBinaryTreeTraverseWithPriority(TreeNode* root) {
  if (!root) return;
  std::queue<TreeNode*> q;
  q.push(root);
  size_t depth = 1;
  while (!q.empty()) {
    size_t sz = q.size();
    while (sz-- > 0) {
      auto cur = q.front();
      q.pop();
      for (auto child : cur->children) {
        q.push(child);
      }
    }
    ++depth;
  }
}

struct State {
  TreeNode* node;
  size_t depth;
};
void bfsBinaryTreeTraverseWithPriorityAsState(TreeNode* root) {
  if (!root) return;
  std::queue<State> q;
  q.push({ root, 1 });
  while (!q.empty()) {
    auto cur = q.front();
    q.pop();
    for (auto child : cur.node->children) {
      q.push({ child, cur.depth + 1 });
    }
  }
}
```

## äºŒå‰å †

* äºŒå‰å †æ˜¯ä¸€ç§æ‹¥æœ‰ç‰¹æ®Šæ€§è´¨çš„å®Œå…¨äºŒå‰æ ‘ï¼Œè¿™æ£µäºŒå‰æ ‘ä¸Šçš„ä»»æ„èŠ‚ç‚¹çš„å€¼ï¼Œéƒ½å¿…é¡»å¤§äºç­‰äºï¼ˆæˆ–å°äºç­‰äºï¼‰å…¶å·¦å³å­æ ‘æ‰€æœ‰èŠ‚ç‚¹çš„å€¼ã€‚å¦‚æœæ˜¯å¤§äºç­‰äºï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºã€Œ**å¤§é¡¶å †**ã€ï¼Œå¦‚æœæ˜¯å°äºç­‰äºï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºã€Œ**å°é¡¶å †**ã€ï¼›
* ä¸€ä¸ªäºŒå‰å †çš„å·¦å³å­å †ï¼ˆå­æ ‘ï¼‰ä¹Ÿæ˜¯ä¸€ä¸ªäºŒå‰å †ã€‚è¿™ä¸ªæ€§è´¨ä¸»è¦åœ¨å †æ’åºç®—æ³•çš„ä¼˜åŒ–ä¸­æœ‰ç”¨åˆ°ï¼›
* ä¸»è¦æ“ä½œå°±ä¸¤ä¸ªï¼šsinkï¼ˆä¸‹æ²‰ï¼‰ã€swimï¼ˆä¸Šæµ®ï¼‰ï¼Œç”¨ä»¥ç»´æŠ¤äºŒå‰å †çš„æ€§è´¨ã€‚
* ä¸»è¦åº”ç”¨æœ‰ä¸¤ä¸ªï¼š
  * ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ˆPriority Queueï¼‰ï¼Œå¢åˆ å…ƒç´ çš„å¤æ‚åº¦æ˜¯ O(logN)ï¼›
  * å †æ’åºï¼ˆHeap Sortï¼‰ã€‚

### ä¼˜å…ˆçº§é˜Ÿåˆ—

#### ç›¸å…³åŠ›æ‰£ä¹ é¢˜

* [ğŸ”´ <b>[åˆå¹¶ K ä¸ªå‡åºé“¾è¡¨](https://leetcode.cn/problems/merge-k-sorted-lists/)</b>]ï¼šä¼˜å…ˆé˜Ÿåˆ—ï¼ˆæœ€å°å †ï¼‰ + è™šæ‹Ÿå¤´ç»“ç‚¹éå†ï¼›
* [ğŸŸ  <b>[æœ‰åºçŸ©é˜µä¸­ç¬¬ K å°çš„å…ƒç´ ](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/)</b>]ï¼šåç»­åŠ å…¥ä¼˜å…ˆé˜Ÿåˆ—çš„å…ƒç´ éœ€è¦é€šè¿‡çŸ©é˜µçš„ xã€y åæ ‡è·å–ï¼Œè¿™äº›ä¿¡æ¯éœ€è¦è¢«åŒæ—¶ä¿å­˜åœ¨é˜Ÿåˆ—å…ƒç´ ä¸­ï¼›

```cpp
// ç®€åŒ–å°é¡¶å †å®ç°ï¼›
#include<vector>
#include<iostream>
#include<algorithm>
class PriorityQueue {
  std::vector<int> heap;
  size_t size = 0;

  static int parent(size_t node) {
    return (node - 1) / 2;
  }
  static int left(size_t node) {
    return node * 2 + 1;
  }
  static int right(size_t node) {
    return node * 2 + 2;
  }
  void swim(size_t node) {
    while (node > 0 && heap[node] < heap[parent(node)]) {
      std::swap(heap[node], heap[parent(node)]);
      node = parent(node);
    }
  }
  void sink(size_t node) {
    while (left(node) < size) {  // å®Œå…¨äºŒå‰æ ‘ï¼Œåªè¦æœ‰å·¦å­èŠ‚ç‚¹å°±ç»§ç»­ï¼›
      // æ¯”è¾ƒè‡ªå·±å’Œå·¦å³å­èŠ‚ç‚¹ï¼Œçœ‹çœ‹è°æœ€å°ï¼›
      auto min = node;
      if (left(node) < size && heap[left(node)] < heap[min]) {
        min = left(node);
      }
      if (right(node) < size && heap[right(node)] < heap[min]) {
        min = right(node);
      }
      if (min == node) break;
      std::swap(heap[node], heap[min]);  // å¦‚æœå·¦å³å­èŠ‚ç‚¹ä¸­æœ‰æ¯”è‡ªå·±å°çš„ï¼Œå°±äº¤æ¢ï¼›
      node = min;
    }
  }
public:
  PriorityQueue(int capacity) {
    heap.resize(capacity);
  }
  auto peak() {
    return heap[0];
  }
  // å‘å †ä¸­æ’å…¥ä¸€ä¸ªå…ƒç´ ï¼Œæ—¶é—´å¤æ‚åº¦ O(logN)ï¼›
  auto push(int x) {
    heap[size] = x;  // æŠŠæ–°å…ƒç´ è¿½åŠ åˆ°æœ€åï¼ˆæœ€åä¸€å±‚çš„æœ€å³ï¼Œä¿æŒå®Œå…¨äºŒå‰æ ‘ï¼‰ï¼›
    ++size;
    swim(size - 1);  // å‘å †é¡¶ä¸Šæµ®å…ƒç´ ï¼›
  }
  // åˆ é™¤æ ˆé¡¶å…ƒç´ ï¼Œæ—¶é—´å¤æ‚åº¦ O(logN)ï¼›
  auto pop() {
    int n = heap[0];
    heap[0] = heap[size - 1];  // æŠŠå †åº•å…ƒç´ æ”¾åˆ°å †é¡¶ï¼›
    --size;
    sink(0);  // ä¸‹æ²‰ä½äºå †é¡¶çš„å…ƒç´ ï¼Œä½¿å…¶ä½äºæ­£ç¡®ä½ç½®ï¼›
    return n;
  }
};
```

## çº¿æ®µæ ‘

![](2.png)

* ç”¨äºé«˜æ•ˆè§£å†³**æ•°ç»„çš„åŒºé—´æŸ¥è¯¢å’ŒåŒºé—´åŠ¨æ€ä¿®æ”¹é—®é¢˜**ï¼›
* å¯ä»¥åœ¨ O(logN) çš„æ—¶é—´å¤æ‚åº¦æŸ¥è¯¢ä»»æ„é•¿åº¦çš„åŒºé—´å…ƒç´ èšåˆå€¼ï¼Œåœ¨ O(logN) çš„æ—¶é—´å¤æ‚åº¦å¯¹ä»»æ„é•¿åº¦çš„åŒºé—´å…ƒç´ è¿›è¡ŒåŠ¨æ€ä¿®æ”¹ï¼Œå…¶ä¸­ N ä¸ºæ•°ç»„ä¸­çš„å…ƒç´ ä¸ªæ•°ã€‚


### é“¾å¼ç»“æ„

```cpp
// çº¿æ®µæ ‘èŠ‚ç‚¹ï¼›
struct SegmentNode {
  size_t l, r;  // è¯¥èŠ‚ç‚¹è¡¨ç¤ºçš„åŒºé—´èŒƒå›´ [l, r]ï¼›
  int mergeVal;
  SegmentNode* left = nullptr;
  SegmentNode* right = nullptr;
  SegmentNode(int mergeVal, size_t l, size_t r) : mergeVal(mergeVal), l(l), r(r) {}
};
class SegmentTree {
  SegmentNode* root;
  std::function<int(int, int)> merger;
  SegmentNode* build(const std::vector<int>& nums, int l, int r) {
    if (l == r) {
      return new SegmentNode(nums[l], l, r);
    }
    int mid = l + (r - l) / 2;
    auto left = build(nums, l, mid);
    auto right = build(nums, mid + 1, r);
    auto node = new SegmentNode(merger(left->mergeVal, right->mergeVal), l, r);
    node->left = left;
    node->right = right;
    return node;
  }

  void update(SegmentNode* node, int index, int value) {
    // æ‰¾åˆ°ç›®æ ‡èŠ‚ç‚¹ï¼›
    if (node->l == node->r) {
      node->mergeVal = value;
      return;
    }
    int mid = node->l + (node->r - node->l) / 2;
    if (index <= mid) {
      // è‹¥ index è¾ƒå°ï¼Œåˆ™å»å·¦å­æ ‘æ›´æ–°ï¼›
      update(node->left, index, value);
    } else {
      // è‹¥ index è¾ƒå¤§ï¼Œåˆ™å»å³å­æ ‘æ›´æ–°ï¼›
      update(node->right, index, value);
    }
    // åœ¨åç»­ä½ç½®æ›´æ–°çˆ¶èŠ‚ç‚¹çš„å€¼ï¼›
    node->mergeVal = merger(node->left->mergeVal, node->right->mergeVal);
  }
  int query(SegmentNode* node, int qL, int qR) {
    if (node->l == qL && node->r == qR) {
      return node->mergeVal;
    }

    // æœªç›´æ¥å‘½ä¸­åŒºé—´ï¼Œéœ€è¦å‘ä¸‹æŸ¥æ‰¾ï¼›
    int mid = node->l + (node->r - node->l) / 2;
    if (qR <= mid) {
      return query(node->left, qL, qR);
    } else if (qL > mid) {
      return query(node->right, qL, qR);
    } else {
      // node.l <= qL <= mid < qR <= node.rï¼›
      // ç›®æ ‡åŒºé—´æ¨ªè·¨å·¦å³å­æ ‘ï¼›
      return merger(
        query(node->left, qL, mid),
        query(node->right, mid + 1, qR)
      );
    }
  }
public:
  SegmentTree(const std::vector<int>& nums, std::function<int(int, int)> merger) : merger(merger) {
    root = build(nums, 0, nums.size() - 1);
  }

  void update(int index, int value) {
    update(root, index, value);
  }

  int query(int qL, int qR) {
    return query(root, qL, qR);
  }
};
```

### æ•°ç»„å®ç°

```cpp

```


## æŠ€å·§

### åˆ†æ²»ç®—æ³• & åˆ†æ²»æ€æƒ³

* åˆ†æ²»æ€æƒ³ï¼šæŠŠä¸€ä¸ªé—®é¢˜åˆ†è§£æˆè‹¥å¹²ä¸ªå­é—®é¢˜ï¼Œç„¶ååˆ†åˆ«è§£å†³è¿™äº›å­é—®é¢˜ï¼Œæœ€ååˆå¹¶å­é—®é¢˜çš„è§£å¾—åˆ°åŸé—®é¢˜çš„è§£ï¼Œè¿™ç§æ€æƒ³å¹¿æ³›å­˜åœ¨äºé€’å½’ç®—æ³•ä¸­ã€‚

### é“¾è¡¨åŒæŒ‡é’ˆ

* å½“éœ€è¦åˆ›é€ ä¸€æ¡æ–°é“¾è¡¨çš„æ—¶å€™ï¼Œå¯ä»¥ä½¿ç”¨**è™šæ‹Ÿå¤´ç»“ç‚¹**ç®€åŒ–è¾¹ç•Œæƒ…å†µçš„å¤„ç†ã€‚

```cpp
// dummy.next æ°¸è¿œæŒ‡å‘æ–°é“¾è¡¨ï¼ŒdummyCursor ç”¨æ¥æ¸¸åŠ¨ï¼›
ListNode dummy(-1), *dummyCursor = &dummy;
```

* å¦‚æœéœ€è¦æŠŠåŸé“¾è¡¨çš„èŠ‚ç‚¹æ¥åˆ°æ–°é“¾è¡¨ä¸Šï¼Œè€Œä¸æ˜¯ new æ–°èŠ‚ç‚¹æ¥ç»„æˆæ–°é“¾è¡¨çš„è¯ï¼Œé‚£ä¹ˆæ–­å¼€èŠ‚ç‚¹å’ŒåŸé“¾è¡¨ä¹‹é—´çš„é“¾æ¥å¯èƒ½æ˜¯å¿…è¦çš„ï¼›
* **å¦‚ä½•åªéå†ä¸€æ¬¡é“¾è¡¨ï¼Œå°±å¾—åˆ°å€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹ï¼Ÿ**ç¬¬ä¸€ä¸ªæŒ‡é’ˆå…ˆèµ° k æ­¥ï¼Œç¬¬äºŒä¸ªæŒ‡é’ˆæ¥ç€ä»é“¾è¡¨å¤´éƒ¨ä¸ç¬¬ä¸€ä¸ªæŒ‡é’ˆåŒæ­¥å‘å°¾éƒ¨ç§»åŠ¨ã€‚å½“ç¬¬äºŒä¸ªæŒ‡é’ˆåˆ°è¾¾æœ€åä¸€ä¸ªèŠ‚ç‚¹åæ—¶ï¼Œç¬¬ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘çš„å°±æ˜¯é“¾è¡¨å€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹ï¼›
* **å¿«æ…¢æŒ‡é’ˆ**ï¼ˆFloyd ç®—æ³•ï¼‰ï¼šä¸¤ä¸ªæŒ‡é’ˆå‡ä»é“¾è¡¨å¤´å¼€å§‹ç§»åŠ¨ï¼Œæ¯å½“æ…¢æŒ‡é’ˆ slow å‰è¿›ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆ fast å°±å‰è¿› n æ­¥ï¼Œè¿™æ ·ï¼Œå½“ fast èµ°åˆ°é“¾è¡¨æœ«å°¾æ—¶ï¼Œslow å°±æŒ‡å‘äº†é“¾è¡¨ä½ 1/n å¤„çš„èŠ‚ç‚¹ã€‚è¯¥æŠ€å·§å¯ç”¨äºåˆ¤æ–­é“¾è¡¨æ˜¯å¦æœ‰ç¯ã€‚

```cpp
ListNode* middleNode(ListNode* head) {
  ListNode* slow = head;
  ListNode* fast = head;
  while (fast && fast->next) {
    slow = slow->next;
    fast = fast->next->next;
  }
  return slow;
}
```

### æ•°ç»„

* åŒæŒ‡é’ˆã€å¿«æ…¢æŒ‡é’ˆï¼›
* æ»‘åŠ¨çª—å£ï¼šå¿«æ…¢æŒ‡é’ˆçš„ä¸€ç§å˜ä½“ï¼Œä¸€å¿«ä¸€æ…¢ä¸¤ä¸ªæŒ‡é’ˆå‰åç›¸éšï¼Œä¸­é—´çš„éƒ¨åˆ†å°±æ˜¯çª—å£ã€‚è¯¥æŠ€å·§ä¸»è¦ç”¨æ¥è§£å†³å­æ•°ç»„é—®é¢˜ï¼Œæ¯”å¦‚ï¼š**å¯»æ‰¾ç¬¦åˆæŸä¸ªæ¡ä»¶çš„æœ€é•¿/æœ€çŸ­å­æ•°ç»„**ã€‚

```cpp
size_t left = 0,  right = 0;
while (right < nums.size()) {
  window.addLast(nums[right]);
  ++right;
  while (window needs shirk) {
    window.removeFirst(nums[first]);
    ++first;
  }
}
```

## äºŒå‰æ ‘



### å…¶ä»–æŠ€å·§

* ä¸‘æ•°ï¼ˆUgly Numberï¼‰ï¼šå¦‚æœä¸€ä¸ªæ•° n å¯ä»¥è¡¨ç¤ºä¸ºï¼š<b>n = 2<sup>^a</sup> x 3<sup>^b</sup> x 5<sup>^c</sup></b>ï¼Œå…¶ä¸­ aã€bã€c éƒ½æ˜¯éè´Ÿæ•´æ•°ï¼Œé‚£ä¹ˆè¿™ä¸ªæ•°å°±æ˜¯ä¸€ä¸ªä¸‘æ•°ã€‚
  * [ğŸŸ¢ <b>[ä¸‘æ•°](https://leetcode.cn/problems/ugly-number/description/)</b>]ï¼›
  * [ğŸŸ  <b>[ä¸‘æ•°2](https://leetcode.cn/problems/ugly-number-ii/description/)</b>] - æ‹†è§£ + DPï¼›
* è´¨æ•°ï¼ˆç´ æ•°ï¼ŒPrimeï¼‰ï¼šä¸€ä¸ªæ•°åªèƒ½è¢« 1 å’Œå®ƒæœ¬èº«æ•´é™¤ã€‚Sieve of Eratosthenes ç­›é€‰æ³•ï¼š

![](3.gif)

```cpp
#include <vector>
#include <algorithm>

int countPrimes(int n) {
  if (n < 2) return 0;
  std::vector<bool> isPrime(n, true);
  isPrime[0] = isPrime[1] = false;  // 0 å’Œ 1 ä¸æ˜¯è´¨æ•°ï¼›
  for (int i = 2; i * i < n; ++i) {
    if (isPrime[i]) {
      for (int j = i * i; j < n; j += i) {
        isPrime[j] = false;
      }
    }
  }
  return std::count(isPrime.begin(), isPrime.end(), true);
}

```








  
