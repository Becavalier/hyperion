---
title: 自用算法模版
intro: 自用算法模版。
comments: true
date: 2025-04-08 10:34:00
tags:
- Algorithm
- 算法
---

## 数组链表

* **数组**：
  * 内存连续 ✅；
  * 支持元素的随机访问，时间复杂度 O(1) ✅。
  * 不适用于需要频繁插入 \ 删除的操作 ❌；
  * 大小固定，扩容需搬移元素 ❌。
  * 动态数组底层还是静态数组，会使用动态扩容机制自动扩容。
* **链表**：
  * 适用于需要频繁插入 \ 删除的操作 ✅；
  * 大小可以动态扩展 ✅。
  * 在内存的缓存空间局部性（Spatial Locality）上相较数组更差 ❌；
  * 不支持随机访问，需从头 \ 尾遍历，时间复杂度 O(N) ❌。
* **环形数组**：用求模运算，将普通数组变成逻辑上的环形数组，让我们可以用 O(1) 的时间在数组头部增删元素。

```cpp
#include <iostream>
#include <stdexcept>
#include <ostream>
#include <memory>

class CircularArray {
  // 区间 [start, end)。
  std::unique_ptr<int[]> arr = nullptr;
  size_t start; 
  size_t end;
  size_t count;
public:
  CircularArray(size_t size) : count(0), start(0), end(0) {
    arr = std::make_unique<int[]>(size);
  }
  void addFirst(int n) {
    // 先左移，再赋值；
    start = (start + count - 1) % count;
    arr[start] = n;
    ++count;
  }
  void addLast(int n) {
    // 先赋值，再右移；
    arr[end] = n;
    end = (end + 1) % count;
    ++count;
  }
  int removeFirst() {
    // 先保存值，再右移；
    auto v = arr[start];
    start = (start + 1) % count;
    return v;
  }
  int removeLast() {
    // 先左移，再返回值；
    end = (end + count - 1) % count;
    return arr[end];
  }
};  
```

## 哈希表

* **负载因子**（Load Factor）：`α = 存储的键值对数量 / 底层数组大小`，表示哈希表装满的程度的度量，值越大，说明存储的键值对越多。α 过大会导致哈希表扩容；
* **哈希冲突**：两个不同的 key 通过哈希函数得到了相同的索引；
  * ***拉链法***（Chaining）：每个哈希桶（槽）不直接存储一个值，而是存储一个链表或其他数据结构（如链表、链表树、动态数组等），该链表中保存所有映射到同一位置的元素。负载因子可以无限增大；
  * ***线性探查法***（Linear Probing）：在冲突发生时，按照固定的步长，逐步检查下一个桶，直到找到一个空槽来存储元素。负载因子最大为 1。
* **哈希表中键的遍历顺序是无序的**，因为遍历过程实际上是遍历哈希表的底层数组，数组中元素的存放顺序可能会由于哈希表扩容而发生改变；
* **哈希表中的 key 必须是不可变类型**，因为 key 的变化会使原有的索引失效，导致无法找到之前存储的数据；
* LinkedHashMap：使用双向链表记录哈希表中键值对的插入顺序。双向链表可以保证哈希表值删除的 O(1) 复杂度。

![](1.png)

* ArrayHashMap：使用数组维护加入到哈希表中的所有键值对，哈希表中存放 (key, index)，数组中按照 index 存放键值对的实际 Node。可用于从哈希表中以 O(1) 复杂度随机获得 key。<u>下述实例代码没有进行越界检查</u>。

```cpp
#include <vector>
#include <unordered_map>
#include <random>

struct Node {
  int key;
  int val;
};
class ArrayHashMap {
  std::unordered_map<int, int> map;
  std::vector<Node> arr;
  std::mt19937 gen;  // Mersenne Twister 19937 伪随机数生成器（PRNG），提供高质量的伪随机数；
public:
  ArrayHashMap() : gen(std::random_device{}()) {}  // 随机种子，决定随机数的起始状态；
  void put(int key, int val) {
    arr.push_back({ key, val });
    map[key] = arr.size() - 1;
  }
  int get(int key) {
    auto index = map[key];
    return arr[index].val;
  }
  void remove(int key) {
    // 调换待删除元素和数组尾部元素；
    auto index = map[key];
    auto& node = arr.back();
    std::swap(arr[index], node);
    // 调整尾部元素存储在哈希表中的索引位置；
    map[node.key] = index;
    // 删除数组尾部元素；
    arr.pop_back();
    // 删除哈希表中的元素；
    map.erase(key);
  }
  int randomKey() { 
    std::uniform_int_distribution<int> dist(0, arr.size() - 1);
    return arr[dist(gen)].key;
  }
};
```

## 二叉树

### 类别

* **满二叉树**（Perfect Binary Tree）：每一层节点都是满的；
* **完全二叉树**（Complete Binary Tree）：**每一层的节点都紧凑靠左排列**，且除了最后一层，其他每层都必须是满的；
  * 完全二叉树的左右子树中，至少有一棵是满二叉树。
* **二叉搜索树**（Binary Search Tree）：树中的每个节点，其左子树的每个节点的值都要小于这个节点的值，右子树的每个节点的值都要大于这个节点的值。你可以简单记为「左小右大」；
* **平衡二叉树**（Balanced Binary Tree）：它的「每个节点」的左右子树的高度差不超过 1。假设平衡二叉树中共有 N 个节点，那么平衡二叉树的高度是 O(logN)。

### 树的各种遍历

#### 递归遍历（DFS）

* 前序位置：一个节点在它的左右子树遍历之前变蓝；
* 中序位置：一个节点在它的左子树遍历完时才会变蓝。BST 的中序遍历结果是有序的；
* 后序位置：一个节点在它的左右子树均遍历完后变蓝。

```cpp
struct TreeNode {
  TreeNode* left;
  TreeNode* right;
  int val;
  TreeNode(int val) : left(nullptr), right(nullptr), val(val) {}
};
void traverse(TreeNode* root) {
  if (!root) return;
  // 前序位置；
  traverse(root->left);
  // 中序位置；
  traverse(root->right);
  // 后序位置；
}
```

#### 层序遍历（BFS）

* 可以记录遍历层级的写法框架：

```cpp
void bfsBinaryTreeTraverse(TreeNode* root) {
  if (!root) return;
  std::queue<TreeNode*> q;
  q.push(root);

  size_t depth = 1;
  while (!q.empty()) {
    int sz = q.size();
    while (sz-- > 0) {  // 处理当前层的所有节点；
      auto& node = q.front();
      q.pop();
      if (node->left) {
        q.push(node->left);
      }
      if (node->right) {
        q.push(node->right);
      }
    }
    ++depth;
  }
}
```

* 带有节点路径权重和的写法框架：

```cpp

```

## 二叉堆












  
