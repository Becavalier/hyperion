---
title: 《x86 汇编语言：从实模式到保护模式（第2版）》读书笔记（第 1-10 章）
intro: 一本 2023 年的新书，这里挑些重点记一记。
comments: false
date: 2023-04-09 10:51:58
tags:
- 汇编
- x86
- x64
---

一本 2023 年的新书，这里挑些重点记一记。

### 第 1 章 - 十六进制计数法

（略）

### 第 2 章 - 计算机和汇编语言

1. Intel 处理器的发展：4004（4 位）、8088（8 位）、8086（16 位）、80286、80386、80486、Pentium、...。
2. 人们最早用的是开关、跳线以及纸带来给计算机编程。

### 第 3 章 - 分段机制和逻辑地址

3. **处理器的字长**：指寄存器和算术逻辑部件的数据宽度。
4. 8086 处理器：

![](1.jpg)

* 诞生于 1978 年；
* 访问内存时使用的是**逻辑地址**：“段地址”+“段内偏移”，指令中的地址均相对于某个段；
* 16 位 *ip* 寄存器；
* 4 个 16 位段寄存器：
  * *cs*：指定代码段位置；
  * *ds*：指定数据段位置；
  * *es*：附加段，冗余的段寄存器；
  * *ss*：栈段寄存器。
* 实模式下，栈空间最大为 64KB；
* 加电启动时状态：
  * cs -> 0xffff；
  * ip -> 0x0。
* 提供了 20 根地址线，可寻址 1MB 内存：
  * 大部分用于访问 **DRAM**（0x0\~0x9ffff），少部分用于访问 **ROM-BIOS**（0xf0000\~0xfffff），和**外围板卡**（0xa0000\～0xeffff）。ROM 部分存有固化的开机启动代码（通常为跳转指令，将 cs/ip 跳回 ROM 的低地址区），通常也被称为 BIOS；
  * 段只能起始于被 16 整除的物理内存地址（可以被表示）；
  * 段逻辑地址 => 段物理地址 >> 4；
  * 单个段最大 64KB。
* 只能使用寄存器 bx、si、di、bp 来提供偏移内存地址，8086 中很多寄存器有特殊用途：
  * bx：基址寄存器（Base Address Register）；
  * ax：累加器寄存器（Accumulator）：与它有关的指令还会做指令长度上的优化；
  * cx：计数器（Counter）；
  * dx：数据寄存器（Data）：专门用于和外部设备之间进行数据传送；
  * si：源索引寄存器（Source Index）；
  * di：目标寄存器（Destination Index）：用于数据传送操作。
* 固定数量的基址和变址组合：
  * [bx + si]；
  * [bx + di]；
  * [bp + si]；
  * [bp + di]。
* 寻址方式：
  * 寄存器寻址；
  * 立即数寻址；
  * 内存寻址：指定偏移地址（有效地址）如何计算：
    * 直接寻址：mov ax, \[0x5c0f\]；
    * 基址寻址：mov \[bx\], dx；（**当使用 bp 作为基址寄存器时，对应的段寄存器默认为 ss**，bp 常用于栈内寻址）
    * 变址寻址：mov \[si\], dx；（使用变址寄存器 si 和 di）
    * 基址变址寻址：mov ax, \[bx + si + 0x100\]。
* 无条件转移指令：“16 位” 是指要转移到的**目标位置的偏移地址是 16 位的**。
  * *相对短转移*：段内转移，允许转移到距离当前指令 -128～127 字节的地方。指令必须使用关键字 “short”；
  * *16 位相对近转移*：段内转移，允许转移到距离当前指令 -32768～32767 字节的地方。指令必须使用关键字 “near”；
  * *16 位间接绝对近转移*：段内转移，目标地址通过 16 位通用寄存器或内存地址间接给出；
  * *16 位直接绝对远转移*：直接在指令中给出段地址和偏移地址的转移指令；
  * *16 位间接绝对远转移*：指令必须使用关键字 “far”。

### 第 4 章 - 汇编语言和汇编软件

5. 汇编语言对指令的大小写没有特别的要求。
6. NASM -> Netwide Assembler。

### 第 5 章 - 虚拟机的安装和使用

7. 计算机的加电与复位：

* *RESET 引脚*：接受复位信号。复位后 CPU 会进行硬件初始化、BIST 内部自测试，并将内部所有寄存器的内容恢复到预置状态；
* 主引导扇区（MBR）：即 “0 盘面 0 磁道 1 扇区”。BIOS 会将该扇区内容加载到内存地址 **0x0000:0x7c00** 的位置（来自 Intel 第一代个人电脑芯片 8088，后续 CPU 为了保持兼容，一直使用这个地址），然后跳转到该位置执行。

8. 硬盘的访问模式：

* CHS（Cylinder-head-sector）模式：通过磁柱，磁头，扇区寻址；
* LBA（Logical Block Address）模式：物理扇区被组织成逻辑扇区，逻辑扇区号连续递增。

9. 一个简单的启动程序：

```assembly
mov ax, 0xb800

; x86 下的段寄存器只能间接赋值；
mov ds, ax  

; ds 会作为默认的数据段寄存器，也可以显式使用 es；
mov byte [0x00], 'a'  
mov byte [0x02], 's'
mov byte [0x04], 'm'
jmp $  ; 死循环；
times 510-($-$$) db 0
db 0x55, 0xaa
```

### 第 6 章 - 编写主引导扇区代码

10. **一个有效的主引导扇区，其最后 2 字节应当是 0x55 和 0xaa**。正常情况下，一段精心编写的主引导扇区代码将检测用来启动计算机的操作系统，并计算出它所在的硬盘位置。然后，它把操作系统的自举代码加载到内存，也用jmp指令跳转到那里继续执行，直到操作系统完全启动。
11. 显卡有自己的存储器（VRAM），要显示的内容都预先写入显存。

* 两种基本模式：
  * *文本模式*：用于显示字符的工作方式（字符代码存入显存，由字符发生器和控制电路决定如何渲染）；
  * *图形模式*：用于显示图形的工作方式。
* 由于历史的原因，所有在个人计算机上使用的显卡，在加电自检之后都会把自己初始化为 **80×25 文本模式**。在这种模式下，屏幕上可以显示 25 行，每行 80 个字符，每屏总共 2000 个字符；
* **0xb8000～0xbffff**（段起始 0xb800）这段物理地址空间，通常默认被用来映射显存；
* 屏幕上的**每个字符对应着显存中连续 2 字节**，前一个是字符的 ASCII 代码，后面是字符的显示属性。

![](2.jpg)

* 光标寄存器：0xe（高 8 位）、0xf（低 8 位），可读可写，合起来形成一个 16 位数值，控制光标在屏幕上的位置。
  * 端口 0x3d4（索引寄存器）存储要访问的寄存器索引值；
  * 端口 0x3d5 用于数据读写。

12. Nasm 伪指令（不对应处理器指令，由编译器处理）：db、dw、dd、dq。
13. **对于寄存器清零，使用 *xor* 指令生成的机器码更短**：

```assembly
mov rax, 0
xor rax, rax  ; better!
```

14. 段内近转移：

```assembly
infi: jmp near infi
```

* *near* 关键字表示代码转移位置在当前段内，相对量为 16 位；
* 取指令的位置：CS << 4 + IP；
* `jmp` 指令的几种形式：
  * 绝对地址跳转 -> *jmp 0x5000:0xf0c0*；
  * 相对偏移地址跳转（目标位置相对当前指令的偏移量）-> *jmp near infi*。

15. Nasm 伪指令：

* 重复指令：`times 20 mov ax, bx`；
* 当前指令行的位置：`$`；
* 当前汇编段的起始位置：`$$`；
* 当前位置已经过的段大小：`$ - $$`；
* 保留指定数量字节，但不初始化值：`resb 256`、`resw 100`、`resd 50`；
* 定义常数：`app_start equ 100`。

16. **Bochs**：开源的 x86 PC 模拟器。用软件来模拟处理器取指令和执行指令的过程，以及整个计算机硬件。

* 可用于调试 MBR 程序；
* 现代处理器加电时的状态：
  * cs -> 0xf000；
  * ip -> 0xfff0；
  * 其余高地址线 -> 高电平：处理器设计者希望把 ROM-BIOS 放到 4GB 可寻址内存的最高端，这样，4GB 以下连同低端 1MB 都是连续的 RAM 区，可以为操作系统管理内存带来方便。
* 常用命令：
  * *s*：step；
  * *n*：next；
  * *c*：continue；
  * *u/N*：反编译接下来的 N 条指令；
  * *print-stack N*：查看栈（ss:sp）内容；
  * *info eflags*：查看 flags 寄存器状态，大写为置位；

17. 在 32 位和 64 位处理器中，段寄存器 cs、ss、ds、es、fs 和 gs 均为 16 位，除此之外还额外增加了一个不可访问的部分，叫作“**段描述符高速缓存器**”。该部分由 CPU 内部使用，其中存放了段的起始地址、扩展范围以及各种属性。

### 第 7 章 - 相同的功能，不同的代码

18. 汇编语言源程序的编译符合一种假设，即编译后的代码将从某个内存段中偏移地址为 0 的地方开始加载。

![](3.jpg)

* 逻辑地址 0x0000:0x7c00 与 0x07c0:0x0000 指向同一个物理地址；
* 基于段寄存器的数据访问“分段”是 CPU 的特性之一。

19. 对 CPU 来说，**加减法不区分操作数的符号性**（通常没有减法运算电路），**乘除法区分操作数的符号性**。对于参与乘除法的操作数，需要正确使用零扩展和符号扩展来改变其长度。

### 第 8 章 - 比高斯更快的计算

20. 栈对应的内存段（栈段）由段寄存器 ss 指向，sp 寄存器指向下一个数据压入栈的位置（栈顶）。

```assembly
push ax
push word [label]  ; sp => sp - 2.
pop ax
pop word [label]
```

* `push` 指令使得 sp 向低地址方向增长，数据压入地址：ss << 4 + sp，`pop` 类似；
* `push` 与 `pop` 指令的操作数宽度只能为 2、4 或 8 个字节。

### 第 9 章 - 硬盘和显卡的访问与控制

21. Nasm 定义段：

```assembly
section .code align=16 vstart=0
```

* 段用于分隔程序中的不同内容；
* 汇编指令 “*section*” 或者 “*segment*” 用于定义段；
* 汇编指令 “*section.段名称.start*” 用于引用段地址（相对于文件开头）；
* 参数 “*vstart*”（Virtual Start Address）控制段内标号的汇编地址计算方式。定义时，地址为段内的偏移距离加上该参数的值；
* Intel 处理器要求段在内存中的起始物理地址最低于 16 字节对齐（通过 *align* 参数）；
* 段起始位置在汇编时确定，根据对齐方式和段大小从低地址到高地址自动选择。

22. 程序头部的基本信息：

* 程序尺寸，以字节为单位的大小；
* 程序入口点，包括段地址和（段内）偏移地址；
* 段重定位表：程序加载到内存后，对引用到的地址进行重定位。

23. 加载器的工作流程：

* 初始化栈段（ss、sp）；
* 载入程序的物理加载地址；
* 初始化段寄存器（ds、es）；
* 

24. 计算机内部总线系统：

![](4.jpg)

* 输出控制设备集中器（ICH）：连接不同总线，协调各个 I/O 接口对处理器的访问。即“南桥”；
* 每种相似类型的设备都有各自的总线体系，对应不同的线路复用和仲裁方式（USB 总线、IDE/SATA 总线等）；
* I/O 端口和端口访问：
  * 端口本质上是一些位于 I/O 接口电路中的寄存器，对应不同功能；
  * 端口实现方式：
    * 映射到指定物理内存段；
    * 独立编址：通过引脚 M/IO# 来控制某一时刻是内存生效还是 I/O 端口生效。
  * 访问端口：`in`、`out`。
* 访问硬盘：
  * 读写以“扇区”单位；
  * 逻辑扇区编址方法采用 LBA48，采用 48 位比特表示逻辑扇区号；
  * 8 个命令块端口：
    * *0x1f0*：Data Port；
    * *0x1f1*：Error；
    * *0x1f2*：Sector Count；
    * *0x1f3*：LBA low byte (Logical Block Address)；
    * *0x1f4*：LBA mid byte；
    * *0x1f5*：LBA hi byte；
    * *0x1f6*：1B1D TOP4LBA: B=LBA, D=drive；
    * *0x1f7*：Command/status。

25. 四种常见的 `call` 指令调用方式：

* 段内：用 `ret` 返回，直接从栈中恢复 IP 寄存器的值；
  * 相对近调用：*call label*；
  * 间接绝对近调用：*call cx*。
* 跨段：用 `retf` 返回，从栈中同时恢复 IP 和 cs 寄存器的值；
  * 直接绝对远调用：*call 0x2000:0x0030*；
  * 间接绝对远调用：*call far [bx]*。


### 第 10 章 - 中断和动态时钟显示

26. 外部硬件中断：从处理器外面来的中断信号。

* Intel 处理器上对应的两个引脚：
  * NMI（Non Maskable Interrupt）：必须加以处理的严重中断信号（**非屏蔽中断**）；
  * INTR：不紧急，不着急处理的中断信号（**可屏蔽中断**）。
* Intel 处理器规定，NMI 中断信号由 0 跳变到 1 后，至少要维持 **4 个以上的时钟周期**才算是有效的，才能被识别；
* 实模式下，NMI 中断使用统一的中断号 2，而不进行细分。

27. 
28. 
29. 
30. 
31. 
32. 
33. 
34. 


