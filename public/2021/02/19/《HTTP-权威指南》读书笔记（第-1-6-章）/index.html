<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>《HTTP 权威指南》读书笔记（第 1-6 章） | 曜彤.手记</title><meta name="baidu-site-verification" content="codeva-P9jyH0b1lv"><meta name="description" content="旧书清理计划。2012 年出版的书，暂时没有新版，选择性读读。"><meta name="generator" content="曜彤.手记"><meta name="keywords" content="博客, C++, C, Rust, Web, Java, IT, 编程, 开发, Android, Python, MySQL, 科技, 黑客, 技术, Javascript, 云, 大数据, 计算, 机器学习, AI, 人工智能, 创业, 产品, 公司, WebAssembly, Wasm"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.jpg"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.jpg"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.jpg"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.jpg"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.jpg"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.jpg"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.jpg"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.jpg"><link rel="apple-touch-icon" sizes="196x196" href="/images/apple-touch-icon-196x196.jpg"><link rel="apple-touch-icon" sizes="310x310" href="/images/apple-touch-icon-310x310.jpg"><link href="/images/splash/iphone5_splash.png" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphone6_splash.png" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphoneplus_splash.png" media="(device-width: 621px) and (device-height: 1104px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/iphonex_splash.png" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/iphonexr_splash.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphonexsmax_splash.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/ipad_splash.png" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro1_splash.png" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro3_splash.png" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro2_splash.png" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="128x128" href="/images/favicon-128.png"><link rel="icon" type="image/png" sizes="196x196" href="/images/favicon-196x196.png"><meta name="msapplication-TileColor" content="#FFFFFF"><meta name="msapplication-TileImage" content="mstile-144x144.png"><meta name="msapplication-square70x70logo" content="mstile-70x70.png"><meta name="msapplication-square150x150logo" content="mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="mstile-310x150.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"><link rel="manifest" href="/manifest.webmanifest"><link rel="alternate" type="application/atom+xml" title="Atom 0.3" href="/atom.xml"><link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body itemscope itemtype="https://schema.org/WebPage"><div class="canvas-containter"><span>X</span></div><header itemscope itemtype="https://schema.org/WPHeader"><div class="logo"></div><h1 class="title"><a href="/" alt="曜彤.手记" title="曜彤.手记" itemprop="headline">曜彤.手记</a><a title="Atom 0.3" target="__blank" href="/atom.xml" class="rss"><img src="/images/rss.png"></a></h1><p itemprop="description" class="description">随记，关于互联网技术、产品与创业</p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name" class="menu-item"><a href="/ " alt="首页" title="首页" itemprop="url">首页</a></li><li itemprop="name" class="menu-item"><a href="/articles" alt="文章" title="文章" itemprop="url">文章</a></li><li itemprop="name" class="menu-item"><a href="/readings" alt="阅读" title="阅读" itemprop="url">阅读</a></li><li itemprop="name" class="menu-item"><a href="/cards" alt="快记" title="快记" itemprop="url">快记</a></li><li itemprop="name" class="menu-item"><a href="/tags" alt="标签" title="标签" itemprop="url">标签</a></li><li itemprop="name" class="menu-item"><a href="/about" alt="关于" title="关于" itemprop="url">关于</a></li></ul></nav><div class="dynamic-slot"></div><div class="toc-body"><div class="bookmark"></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-1-%E7%AB%A0-HTTP-%E6%A6%82%E8%BF%B0"><span class="toc-text">第 1 章 - HTTP 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-2-%E7%AB%A0-URL-%E4%B8%8E%E8%B5%84%E6%BA%90"><span class="toc-text">第 2 章 - URL 与资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-3-%E7%AB%A0-HTTP-%E6%8A%A5%E6%96%87"><span class="toc-text">第 3 章 - HTTP 报文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-4-%E7%AB%A0-%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="toc-text">第 4 章 - 连接管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-5-%E7%AB%A0-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">第 5 章 - Web 服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-6-%E7%AB%A0-%E4%BB%A3%E7%90%86"><span class="toc-text">第 6 章 - 代理</span></a></li></ol></div><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><script src="https://shadow.elemecdn.com/npm/zoomage.js@latest/dist/zoomage.min.js" type="text/javascript"></script><script src="https://shadow.elemecdn.com/npm/axios@0.18.0/dist/axios.min.js" type="text/javascript"></script><script src="/scripts/post.js" type="text/javascript"></script><div class="touch-top"><span></span></div><article post-id="《HTTP 权威指南》读书笔记（第 1-6 章）" class="full article-post"><h1 itemprop="headline" class="align-center">《HTTP 权威指南》读书笔记（第 1-6 章）</h1><div class="content"><div class="article-meta"><span class="post-meta"><br>Created on<time itemprop="dateCreated" datetime="2021-02-19T11:45:04.000Z"> 2021 / 02 / 19, 19:45:04</time></span><span class="page-tag-anchor"><a href="/tags/HTTP" itemprop="url">#HTTP</a>&nbsp;&nbsp;</span></div><p>旧书清理计划。2012 年出版的书，暂时没有新版，选择性读读。</p>
<h3 id="第-1-章-HTTP-概述"><a href="#第-1-章-HTTP-概述" class="headerlink" title="第 1 章 - HTTP 概述"></a>第 1 章 - HTTP 概述</h3><ol>
<li><span class="pn">Page 6</span>最初设计 <strong>MIME</strong>（Multipurpose Internet Mail Extension，多用途因特网邮件扩展）是为了解决在不同电子邮件系统之间搬移报文时存在的问题。Web 服务器会为所有 HTTP 对象数据附加一个 MIME 类型，以便与浏览器检测是否可以处理（应该如何处理）该类内容。<strong>该类型对应于响应头的 “Content-type” 字段，该字段值就是 MIME 类型</strong>。</li>
<li><span class="pn">Page 7</span>URI = URL（统一资源定位符）+ URN（统一资源名）。</li>
</ol>
<ul>
<li>URL 组成：<em>方案://地址/路径</em>；<ul>
<li><strong>方案</strong>：说明了资源所使用的协议类型（HTTP / HTTPS 等）；</li>
<li><strong>地址</strong>：服务器的因特网地址；</li>
<li><strong>路径</strong>：服务器上某个资源的位置。</li>
</ul>
</li>
<li>URN：作为特定内容的唯一名称使用，与资源所在地无关。通过 URN，可以用同一个名字通过多种网络协议访问资源。</li>
</ul>
<ol start="3">
<li><span class="pn">Page 9</span>HTTP 事务组成：</li>
</ol>
<ul>
<li><strong>方法</strong>：告诉服务器要执行的动作，如 <strong>GET</strong>、<strong>POST</strong>、<strong>PUT</strong> 等；</li>
<li><strong>状态码</strong>：表明请求的状态，包含一个三位的<strong>数字</strong>（200）以及一条<strong>解释性短语</strong>（OK）。其中，解释性短语仅对人类有意义。</li>
</ul>
<ol start="4">
<li><span class="pn">Page 11</span><strong>HTTP 报文是纯文本的</strong>，以方便人们对其进行读写。其组成包括（包括请求报文与响应报文）：</li>
</ol>
<p><img src="1.png"></p>
<ul>
<li><strong>起始行</strong>：报文的第一行。<strong>请求报文中用来说明做什么；响应报文中说明发生了什么</strong>；</li>
<li><strong>首部字段</strong>：位于起始行后面。每行一个字段，每个字段包含一个名值对，以冒号分割。<strong>首部以一个空行结束</strong>；</li>
<li><strong>主体</strong>：可选的主体，其中<strong>包含所有类型的数据</strong>（文本、二进制等）。</li>
</ul>
<ol start="5">
<li><span class="pn">Page 14</span>HTTP 请求中的端口号（包括默认的 80）主要用于<strong>建立于特定端口上的 TCP 连接</strong>。</li>
<li><span class="pn">Page 20</span>Web 结构组件：</li>
</ol>
<ul>
<li><strong>代理</strong>；</li>
<li><strong>缓存</strong>；</li>
<li><strong>网关</strong>：通常用于将 HTTP 流量转换成其他协议；</li>
<li><strong>隧道</strong>：是建立之后，就会在两条连接之间对原始数据进行“盲转发”的 HTTP 应用程序。其通常用来在一条或多条 HTTP 连接上转发非 HTTP 数据，转发时不会窥探数据。一种常见用途是<strong>通过 HTTP 连接承载加密的 SSL 安全套接字层流量</strong>；<ul>
<li>使用 HTTP CONNECT 方法（主要用于 HTTPS），连接后双方进入“原始 TCP”传输状态，可以直接传输加密数据（比如 TLS）；</li>
<li>使用 POST/GET 包裹 TCP 数据（用于通用 TCP 隧道）；</li>
</ul>
</li>
<li><strong>Agent 代理</strong>；代表用户发起 HTTP 请求的客户端程序（如“Web 浏览器”）。</li>
</ul>
<h3 id="第-2-章-URL-与资源"><a href="#第-2-章-URL-与资源" class="headerlink" title="第 2 章 - URL 与资源"></a>第 2 章 - URL 与资源</h3><ol start="7">
<li><span class="pn">Page 29</span>URL 语法：</li>
</ol>
<pre class="line-numbers language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>scheme<span class="token operator">></span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token operator">&lt;</span>user<span class="token operator">></span><span class="token punctuation">:</span><span class="token operator">&lt;</span>password<span class="token operator">></span>@<span class="token operator">&lt;</span>host<span class="token operator">></span><span class="token punctuation">:</span><span class="token operator">&lt;</span>port<span class="token operator">></span><span class="token operator">/</span><span class="token operator">&lt;</span>path<span class="token operator">></span><span class="token punctuation">;</span><span class="token operator">&lt;</span>params<span class="token operator">></span><span class="token operator">?</span><span class="token operator">&lt;</span>query<span class="token operator">></span>#<span class="token operator">&lt;</span>frag<span class="token operator">></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>- <em><strong>组件</strong></em>：</p>
<ul>
<li><em><strong>scheme</strong></em>：访问服务器获取资源时要使用哪种协议，不区分大小写；</li>
<li><em><strong>user</strong></em>：某些方案访问资源时需要的用户名；</li>
<li><em><strong>password</strong></em>：同上，所需的密码；</li>
<li><em><strong>host</strong></em>：资源宿主服务器的主机名或点分 IP 地址；</li>
<li><em><strong>port</strong></em>：资源宿主服务器正在监听的端口号；</li>
<li><em><strong>path</strong></em>：服务器上资源的本地名；</li>
<li><em><strong>params</strong></em>：输入参数，由 “=” 连接组成的键值对；</li>
<li><em><strong>query</strong></em>：查询参数；</li>
<li><em><strong>frag</strong></em>：一小片或一部分资源的名字（仅客户端使用）。</li>
</ul>
<p>- <em><strong>HTTP 简单认证头部</strong></em>：dXNlcjpwYXNz 是 “username:password” 的 Base64 编码；</p>
<pre class="line-numbers language-text"><code class="language-text">GET /protected/resource HTTP/1.1
Host: example.com
Authorization: Basic dXNlcjpwYXNz
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ol start="8">
<li><span class="pn">Page 36</span>“相对 URL 到对应绝对 URL” 的转换算法定义在 <strong>RFC 2396</strong> 中。</li>
<li><span class="pn">Page 38</span><strong>URL 编码</strong>：为了保证 URL 在互联网中各个协议和应用中的可移植性。</li>
</ol>
<ul>
<li><strong>对部分 URL</strong>：对 URL 组成中的某个部分（如 “#”、“/”）进行转译，一般用于转译用户输入（<code>window.encodeURIComponent</code>）；</li>
<li><strong>对整个 URL</strong>：对整个 URL 进行编码。（<code>window.encodeURI</code> 会将特定字符转换为对应的 UTF-8 编码，比如 <em>query</em> 部分）。</li>
</ul>
<h3 id="第-3-章-HTTP-报文"><a href="#第-3-章-HTTP-报文" class="headerlink" title="第 3 章 - HTTP 报文"></a>第 3 章 - HTTP 报文</h3><ol start="10">
<li><span class="pn">Page 48</span>HTTP 标准中规定<strong>起始行和首部的每一行都以 CRLF（回车符+换行符）结尾</strong>。但稳健的应用也应该接受单个换行符作为行终止符。</li>
<li><span class="pn">Page 50</span>有些 HTTP 版本（如 HTTP/1.1）中要求<strong>有效的请求或响应中必须包含特定的首部</strong>，即首部不能完全留空。</li>
<li><span class="pn">Page 51</span>常见请求方法：</li>
</ol>
<p><img src="2.png"></p>
<ul>
<li>GET / HEAD 为“<strong>安全方法</strong>”，对应的 HTTP 请求不会产生动作；</li>
<li>使用 HEAD 方法，可以：<ul>
<li>在不获取资源的情况下了解资源的情况；</li>
<li>通过查看响应中的状态码，查看某个对象是否存在；</li>
<li>通过查看首部，测试资源是否被修改。</li>
</ul>
</li>
<li>PUT 方法的语义：让服务器用请求的主体创建一个<strong>由所请求 URL 命名的新文档</strong>，或者覆盖已有的文档（一般是<strong>幂等</strong>的）；</li>
<li><strong>POST 侧重于向服务器提交数据的目的</strong>，一般用于发生非幂等的改变；</li>
<li>TRACE 方法会让服务器原样返回客户端发送的请求内容，主要用于诊断，即用于验证请求是否如愿穿过了请求/响应链；</li>
<li>HTTP/1.1 中新增了 PATCH 方法（RFC 5789）；</li>
<li>通常，GET、HEAD、PUT、DELETE、TRACE 和 OPTIONS 方法是<strong>幂等的</strong>。</li>
<li>GET 等方法也可以携带主体（body）部分，只是在 RFC 中并没有明确要求需要携带；</li>
<li>OPTIONS 请求：主要用于 <strong>CORS</strong> 跨域资源共享，请求给定的 URL 或服务器的允许通信选项。本质是为浏览器提供的一套安全跨域资源访问策略；</li>
</ul>
<p><p><img src="10.png" alt="简单请求"><span class="pic-desc">简单请求</span></p></p>
<p><p><img src="11.png" alt="复杂请求"><span class="pic-desc">复杂请求</span></p></p>
<ol start="13">
<li><span class="pn">Page 52</span>常见状态码：</li>
</ol>
<p><img src="3.png"></p>
<ul>
<li><em>100</em>：<em>Continue</em>。说明收到了请求的初始部分，请求客户端继续；<ul>
<li><em>客户端</em>：如果客户端在向服务器发送一个实体，且愿意在发送前等待 100 Continue 响应，那么，客户端就要发送一个携带值为 “100 Continue” 的 <em><strong>Expect</strong></em> 首部； </li>
<li><em>服务器</em>：收到对应请求后，用 “100 Continue” 或一条错误码作为响应；</li>
<li><em>代理</em>：根据下一跳服务器的 HTTP 兼容情况，选择性返回 <em>417 Expectation Failed</em> 或者继续向下转发。</li>
</ul>
</li>
<li><em>101</em>：<em>Switching Protocols</em>。服务器正在根据客户端的指定，将协议切换成 <em>Update</em> 首部所列协议（WebSocket 的链接过程会使用）；</li>
<li><em>201</em>：<em>Created</em>。服务器对象创建成功（PUT）；</li>
<li><em>202</em>：<em>Accepted</em>。请求已被接受，但服务器还未对其执行任何动作。响应实体中应该包含对请求状态的描述，及请求完成时间的估计；</li>
<li><em>203</em>：<em>Non-Authoritative Information</em>。实体首部包含的信息不是来自于源段服务器，而是资源的一份副本；</li>
<li><em>204</em>：<em>No Content</em>。响应报文无实体。一般为非显式更新资源的结果；</li>
<li><em>205</em>：<em>Reset Content</em>。告知浏览器清除当前页面中的所有 HTML 表单元素；</li>
<li><em>206</em>：<em>Partial Content</em>。成功执行了一个部分或 Range 请求（需要同时返回 Content-Range、Date 以及 Etag 或 Content-Location 首部）；</li>
<li><em>300</em>：<em>Multiple Choices</em>。客户端请求一个实际指向多个资源的 URL 时会返回该状态码，比如服务器上有某个 HTML 文档的多个语言版本；</li>
<li><em>301</em>：<em>Moved Permanently</em>。请求的 URL 已被移除时使用。响应的 Location 首部中包含资源的当前可用 URL，<strong>任何未来对这个资源的引用都应该使用新的 URL</strong>；</li>
<li><em>302</em>：<em>Found</em>。表示目标资源临时移动到了另一个 URL 上。由于重定向是临时发生的，所以客户端在之后的请求中还应该使用原本的 URL（由于历史原因，<strong>POST 请求可能被用户代理重定向为 GET</strong>）；</li>
<li><em>303</em>：<em>See Other</em>。告知客户端应用另一个 URL 来获取资源，主要用于允许 POST 请求的响应将客户端重定向到某个资源上（比如将提交成功后的表单导向一个“上传成功”页面）；</li>
<li><em>304</em>：<em>Not Modified</em>。表示资源未被修改；</li>
<li><em>305</em>：<em>Use Proxy</em>。说明必须通过一个代理来访问资源，代理的位置由 Location 首部给出；</li>
<li><em>306</em>：（未使用）；</li>
<li><em>307</em>：<em>Temporary Redirect</em>。与 302 类似，<strong>但不允许将原本为 POST 的请求重定向到 GET 请求上</strong>；</li>
<li><em>308</em>：<em>Permanent Redirect</em>。与 301 类似，<strong>但不允许将原本为 POST 的请求重定向到 GET 请求上</strong>；</li>
<li><em>400</em>：<em>Bad Request</em>。用于告知客户端它发送了一个错误的请求；</li>
<li><em>401</em>：<em>Unauthorized</em>。与适当的首部一同返回，在这些首部中请求客户端在获取对资源的访问之前，对自己进行认证；</li>
<li><em>402</em>：<em>Payment Required</em>。（保留）；</li>
<li><em>403</em>：<em>Forbidden</em>。说明请求被服务器拒绝了；</li>
<li><em>405</em>：<em>Method Not Allowed</em>。说明发起的请求中带有所请求 URL 不支持的方法。响应中应携带 Allow 首部，告知客户端可用的方法有哪些；</li>
<li><em>406</em>：<em>Not Acceptable</em>。说明服务器没有与客户端可接受的 URL 相匹配的资源；</li>
<li><em>407</em>：<em>Proxy Authentication Required</em>。与 401 类似，但用于要求对资源进行认证的代理服务器；</li>
<li><em>408</em>：<em>Request Timeout</em>。若客户端完成请求所花时间太长，服务器可返回次状态码；</li>
<li><em>409</em>：<em>Conflict</em>。说明请求可能在资源上引发一些冲突。服务器担心请求会引发冲突时，可以发送此状态码；</li>
<li><em>410</em>：<em>Gone</em>。与 404 类似，只是服务器曾经拥有过此资源。主要用于 Web 站点的维护；</li>
<li><em>411</em>：<em>Length Required</em>。服务器要求在请求中包含 Content-Length 首部；</li>
<li><em>412</em>：<em>Precondition Failed</em>。表明客户端发起了条件请求（带有 Expect 首部），且其中一个条件失败了；</li>
<li><em>413</em>：<em>Request Entity Too Large</em>。表明客户端发送的实体主体部分过大；</li>
<li><em>414</em>：<em>Request URI Too Long</em>。表明客户端发送请求的 URL 过长；</li>
<li><em>415</em>：<em>Unsupported Media Type</em>。表明服务器无法理解或支持客户端所发送的实体类型；</li>
<li><em>416</em>：<em>Requested Range Not Satisfiable</em>。表明请求报文指定的资源范围无法被服务器满足；</li>
<li><em>417</em>：<em>Expectation Failed</em>。表明请求的期望（带有 Expect 首部）无法被满足；</li>
<li><em>501</em>：<em>Not Implemented</em>。表明客户端发起的请求超出了服务器的能力范围；</li>
<li><em>502</em>：<em>Bad Gateway</em>。作为代理或网关使用的服务器从请求响应链的下一条链路上收到了一条伪相应；</li>
<li><em>503</em>：<em>Service Unavailable</em>。说明服务器现在无法为请求提供服务；</li>
<li><em>504</em>：<em>Gateway Timeout</em>。与 408 类似，只是这里的响应来自一个网关或代理，它们在等待另一服务器对其请求进行响应时超时了；</li>
<li><em>505</em>：<em>HTTP Version Not Supported</em>。服务器收到的请求使用了它无法或不愿支持的协议版本。</li>
</ul>
<ol start="14">
<li><span class="pn">Page 54</span>首部：</li>
</ol>
<p>- <em><strong>常见首部</strong></em>：</p>
<ul>
<li>（通用首部）<em>Connection</em>：允许客户端和服务器指定与请求/响应连接有关的选项；</li>
<li>（通用首部）<em>Date</em>：说明报文的创建时间；</li>
<li>（通用首部）<em>MIME-Version</em>：给出了发送端使用的 MIME 版本；</li>
<li>（通用首部）<em>Trailer</em>：用于“分块传输编码”，可列出位于报文 trailer 部分的首部集合；</li>
<li>（通用首部）<em>Transfer-Encoding</em>：告知接收端为保证报文的可靠传输，对报文采用的编码方式；</li>
<li>（通用首部）<em>Update</em>：给出了发送端可能想要“升级”使用的新版本或协议；</li>
<li>（通用首部）<em>Via</em>：显示了报文经过的中间节点（代理、网关）；</li>
<li>（通用首部）<em>Cache-Control</em>：用于随报文传送缓存指示；</li>
<li>（通用首部）<em>Pragma</em>：用于随报文传送指示；</li>
<li>（请求首部）<em>Client-IP</em>：提供了客户端机器的 IP；</li>
<li>（请求首部）<em>From</em>：提供了客户端用户的邮件地址；</li>
<li>（请求首部）<em>Host</em>：给出了接受请求的服务器的主机号和端口号；</li>
<li>（请求首部）<em>Referer</em>：提供了包含当前 URI 的文档 URL；</li>
<li>（请求首部）<i>UA-*</i>：提供了客户端相关信息；</li>
<li>（请求首部）<em>User-Agent</em>：将发起请求的应用名称告知服务器；</li>
<li>（请求首部）<em>Accept</em>：告诉服务器能够发送哪些媒体类型；</li>
<li>（请求首部）<em>Accept-Charset</em>：告诉服务器能够发送哪些字符集；</li>
<li>（请求首部）<em>Accept-Encoding</em>：告诉服务器能够发送哪些编码方式；</li>
<li>（请求首部）<em>Accept-Language</em>：告诉服务器能够发送哪些语言；</li>
<li>（请求首部）<em>TE</em>：告诉服务器可以使用哪些扩展传输编码；</li>
<li>（请求首部）<em>Expect</em>：允许客户端列出某请求所要求的服务器行为；</li>
<li>（请求首部）<em>If-Match</em>：如果实体标记（某版本资源的标识符）与文档当前的实体标记相匹配，就获取该文档；</li>
<li>（请求首部）<em>If-None-Match</em>：（与上相反）；</li>
<li>（请求首部）<em>If-Modified-Since</em>：除非在<strong>某个指定日期之后</strong>资源被修改过，否则就限制该请求；</li>
<li>（请求首部）<em>If-Unmodified-Since</em>：（与上相反）；</li>
<li>（请求首部）<em>If-Range</em>：允许对文档的某个范围进行条件请求；</li>
<li>（请求首部）<em>Range</em>：如果服务器支持范围请求，就请求资源的指定范围；</li>
<li>（请求首部）<em>Authorization</em>：包含了客户端提供给服务器，以便其对自身进行认证的数据；</li>
<li>（请求首部）<em>Cookie</em>：向服务器传送令牌；</li>
<li>（请求首部）<em>Cookie2</em>：用来说明请求端支持的 cookie 版本；</li>
<li>（请求首部）<em>Max-Forward</em>：在通往源端服务器的路径上，将请求转发给其他代理或网关的最大次数（与 TRACE 方法一起使用）；</li>
<li>（请求首部）<em>Proxy-Authorization</em>：与 Authorization 首部相同，但用于代理；</li>
<li>（请求首部）<em>Proxy-Connection</em>：与 Connection 首部相同，但用于代理；</li>
<li>（响应首部）<em>Age</em>：从最初创建开始，响应持续的时间；</li>
<li>（响应首部）<em>Public</em>：服务器为其资源支持的请求方法列表；</li>
<li>（响应首部）<em>Retry-After</em>：如果资源不可用，在此日期或时间重试；</li>
<li>（响应首部）<em>Server</em>：服务器应用程序的名称和版本；</li>
<li>（响应首部）<em>Title</em>：对 HTML 来说，就是 HTML 文档的源端给出的标题；</li>
<li>（响应首部）<em>Warning</em>：比原因短语中更详细一些的警告报文；</li>
<li>（响应首部）<em>Accept-Ranges</em>：对此资源来说，服务器可接受的范围类型；</li>
<li>（响应首部）<em>Vary</em>：服务器查看的其他首部列表，可能会使响应发生变化；</li>
<li>（响应首部）<em>Proxy-Authenticate</em>：来自代理对客户端的质询列表；</li>
<li>（响应首部）<em>Set-Cookie</em>：可以在客户端设置一个令牌；</li>
<li>（响应首部）<em>Set-Cookie2</em>：与上类型，由 RFC 2965 定义；</li>
<li>（响应首部）<em>WWW-Authenticate</em>：来自服务器对客户端的质询列表；</li>
<li>（实体首部）<em>Allow</em>：列出了可对此实体执行的请求方法；</li>
<li>（实体首部）<em>Location</em>：告知客户端实体实际上位于何处，用于将接收端定向到资源的可用位置上去；</li>
<li>（实体首部）<i>Content-*</i>：与实体内容相关的信息（编码方式、语言、长度、MD5、范围、类型等）；</li>
<li>（实体首部）<em>ETag</em>：与此实体相关的实体标记；</li>
<li>（实体首部）<em>Expires</em>：实体不再有效，要从源端再次获取此实体的日期和时间；</li>
<li>（实体首部）<em>Last-Modified</em>：该实体最后一次被修改的日期和时间。</li>
</ul>
<p>- <em><strong>首部延续行</strong></em>：以空格或制表符（tab）延续首部。</p>
<pre class="line-numbers language-text"><code class="language-text">HTTP/1.0 200 OK
Content-Type: image/gif
Content-Length: 8572
Server: Test Server
  Version 1.0
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="第-4-章-连接管理"><a href="#第-4-章-连接管理" class="headerlink" title="第 4 章 - 连接管理"></a>第 4 章 - 连接管理</h3><ol start="15">
<li><span class="pn">Page 81</span>TCP 连接：</li>
</ol>
<ul>
<li>TCP 会<strong>按序、无差错</strong>地承载 HTTP 数据；</li>
<li>TCP 流是分段的、由 IP 分组（IP 数据报）传送，即 “HTTP over TCP over IP”。对应的 HTTPS 就是在 HTTP 与 TCP 之间插入了一个密码加密层（即 TLS 或 SSL）。</li>
</ul>
<p><img src="4.png"></p>
<ul>
<li>HTTP 报文流 -&gt; TCP 分段 -&gt; 封装 IP 分组 -&gt; 传输；</li>
<li>一个 TCP 连接由“<strong>源 IP 地址</strong>”、“<strong>源端口号</strong>”、“<strong>目的 IP 地址</strong>”、“<strong>目的端口号</strong>”四个部分唯一确定；</li>
<li>IP 分组包括：<ul>
<li>（20 字节）一个 <strong>IP 分组首部</strong>（包含源和目的 IP、长度和其他标记）；</li>
<li>（20 字节）一个 <strong>TCP 段首部</strong>（包含 TCP 端口号、TCP 控制标记以及用于数据排序和完整性校验的一些数字值）；</li>
<li>一个 <strong>TCP 数据块</strong>（0 或多个字节）。</li>
</ul>
</li>
<li>IP 分组<strong>报文结构</strong>：</li>
</ul>
<p><img src="5.png"></p>
<ul>
<li>“TCP 段序列” 和 “TCP 检验和” 字段用于保证数据传输的完整性；</li>
<li>“捎带的确认”字段中存放了发送回发送者的确认分组（由接受者发出，以确认收到某个分段），只不过由于确认分组报文本身很小，因此该分组可以由其他相同方向（向发送者）的输出数据分组“帮忙捎带”。</li>
</ul>
<p>- <em><strong>TCP 性能</strong></em>：</p>
<ul>
<li>HTTP 事务的时延：<ul>
<li>域名到 IP 的 DNS 查询时延（可通过本地缓存解决）；</li>
<li>TCP 连接建立时延；</li>
<li>HTTP 请求发送、处理和接收时延。</li>
</ul>
</li>
<li>TCP 连接三次握手过程：<ol>
<li>（<em>SYN 位</em>）客户端向服务器发送一个小的 TCP 分组（40~60 字节）。分组中设置了一个特殊的 SYN 标记，说明这是一个连接请求；</li>
<li>（<em>SYN 位</em> + <em>ACK 位</em>）若服务器接受了连接，会计算一些连接参数，并向客户端返回一个 TCP 分组，该分组中的 SYN 和 ACK 标记被置位，说明连接请求已被接受；</li>
<li>（<em>ACK 位</em>）最后，客户端向服务器回送一条确认信息，通知连接已成功建立。<strong>现代 TCP 栈都允许客户端在这个确认分组中发送数据</strong>。</li>
</ol>
</li>
<li>TCP 的“<strong>延迟确认</strong>”算法：<strong>为了增加“确认报文”找到同向传输数据分组的可能性</strong>。该算法会在一个特定的时间窗口（通常为 100~200 ms）内将输出确认存放在缓冲区中，以寻找能够捎带它的输出数据分组。若在该时间段内没有符合要求的输出数据分组，就将确认信息放在单独的分组中传送。在某些情况下，该算法会导致较大的时延。</li>
<li>TCP <strong>慢启动</strong>：TCP 连接会随着时间进行自我“调谐”，<strong>起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输速度</strong>（打开拥塞窗口）。这种机制称为 “TCP 慢启动”，用于防止因特网的突然过载和拥塞。在这种情况下，每个新建立 TCP 连接的传输速度会比已经交换过一定量数据的连接慢一些。因此，可以持久连接的 HTTP 连接可以在一定程度上解决这个问题；</li>
<li><strong>Nagle 算法</strong>与 <strong>TCP_NODELAY</strong>：Nagle 算法试图<strong>在发送一个分组之前，将大量 TCP 数据绑定在一起，以提高网络效率</strong>。该算法鼓励发送“全尺寸”的段，而小的 HTTP 报文可能无法填满一个分组，会因为等待额外数据而产生时延。同时，对于“延迟确认”机制，<strong>Nagle 算法会阻止数据的发送，直达有确认分组抵达为止</strong>（Nagle 机制在未接收到第一个报文的确认分组前，不会发送已读取到的报文），但确认分组自身还会被延迟确认算法延迟 100~200 ms。通过设置 TCP_NODELAY，可以禁用 Nagle 算法；</li>
<li><strong>TIME_WAIT 累积</strong>与<strong>端口耗尽</strong>：当某个 TCP 端点关闭 TCP 连接时，会在内存中维护一个小的控制块，以记录最近关闭连接的 IP 地址和端口号，以确保在这段时间内不会创建具有相同地址和端口号的新连接（防止在短时间内创建、关闭并重新创建两个具有相同 IP 和端口号的连接。比如复制了来自之前连接的分组）。当 TCP 连接的源 IP、目的 IP 以及目的端口号都固定时，有限的源端口号可能成为阻碍基准测试的一个因素（连接率收到限制）。</li>
</ul>
<ol start="16">
<li><span class="pn">Page 92</span>HTTP 请求的 <strong>Connection 首部</strong>：</li>
</ol>
<ul>
<li>指定了两个相邻 HTTP 应用之间的共享连接（比如发送端与第一个代理之间、两个中间代理之间等）的一组选项。<strong>这些选项仅应用于该连接，不会被传播到下一跳</strong>的链接中去；</li>
<li>Connection 首部可用标签类型：<ul>
<li><strong>HTTP 首部字段名</strong>，该首部字段包含与此连接相关的信息；</li>
<li><strong>任意标签值</strong>，用于描述此连接的非标准选项；</li>
<li>值 <em><strong>close</strong></em>，表明操作完成后需关闭这条持久连接。</li>
</ul>
</li>
<li>“逐跳首部名”（仅应用于这一跳的首部）可以放入 Connection 首部中，以确保在发送到下一跳前删除该首部。</li>
</ul>
<ol start="17">
<li><span class="pn">Page 93</span>四种提高 HTTP 连接性能的技术：</li>
</ol>
<ul>
<li><strong>并行连接</strong>：通过多条 TCP 连接发起并发的 HTTP 请求；</li>
<li><strong>持久连接</strong>：重用 TCP 连接，以消除连接及关闭时延（<strong>可以省去握手和慢启动过程</strong>）。*实现要求所有报文的实体长度都要和相应的 Content-Length 一致，以使得可以区分报文的起始和结束位置：<ul>
<li><em>HTTP/1.0+ Keep-Alive</em>：可以通过包含 <em>Connection: Keep-Alive</em> 首部请求将一条连接保持在打开状态，若服务器支持且同意，则会在响应中包含同样的 Connection 首部，而 Keep-Alive 首部中将指定相关行为的选项。<strong>该方式在通信链路中间存在“哑代理”时会存在问题</strong>；</li>
<li><em>HTTP/1.1 持久连接</em>：除非发送的请求中指明 <em>Connection: close</em>，否则<strong>默认情况下持久连接是激活的</strong>。</li>
</ul>
</li>
<li><strong>管道化连接</strong>（已逐渐被淘汰，被 HTTP/2 的多路复用取代）：通过共享的 TCP 连接发起并发的 HTTP 请求。几个限制：<ul>
<li>必须按照与请求相同的顺序回送 HTTP 响应；</li>
<li>HTTP 客户端不应该用管道化的方式发送会产生副作用的请求（比如 POST），因为在服务器出错时，这些请求无法被安全重试（不幂等）。</li>
</ul>
</li>
<li><strong>复用的连接</strong>：交替传送请求和响应报文。</li>
</ul>
<p><img src="6.png"></p>
<ol start="18">
<li><span class="pn">Page 108</span>正常关闭连接：</li>
</ol>
<p><img src="7.png"></p>
<ul>
<li><strong>TCP 连接是双向的</strong>，因此需要四次挥手；</li>
</ul>
<p><p><img src="12.png" alt="TCP 断开的四次挥手"><span class="pic-desc">TCP 断开的四次挥手</span></p></p>
<ul>
<li>关闭连接的输出信道总是安全的，而关闭连接的输入信道是危险的。如果另一端向已关闭的输入信道发送数据，操作系统会向另一端的机器回送一条 TCP “<strong>连接被对端重置</strong>”的报文。</li>
</ul>
<h3 id="第-5-章-Web-服务器"><a href="#第-5-章-Web-服务器" class="headerlink" title="第 5 章 - Web 服务器"></a>第 5 章 - Web 服务器</h3><ol start="19">
<li><span class="pn">Page 125</span>不同的 Web 服务器结构：</li>
</ol>
<ul>
<li><strong>单线程 Web 服务器</strong>：一次处理一个请求，直到其完成为止。一个事务处理结束之后，才去处理下一条连接；</li>
<li><strong>多进程及多线程 Web 服务器</strong>：基于“线程池”，同时对多个请求进行处理；</li>
<li><strong>I/O 复用 Web 服务器</strong>：用于支持大量的连接。复用结构中，<strong>同时监视所有连接上（多个 fd）的活动</strong>。当连接发生变化时，就对其进行处理；处理结束后，将连接返回到开放连接列表中，等待下一次状态变化；</li>
<li><strong>复用的多线程 Web 服务器</strong>：结合多线程与复用功能。</li>
</ul>
<p><img src="8.png"></p>
<ol start="20">
<li><span class="pn">Page 132</span>响应主体 <strong>MIME 分类方式</strong>：</li>
</ol>
<ul>
<li>文件扩展名；</li>
<li>魔法分类（如魔数）；</li>
<li>显式分类；</li>
<li>协商分类。</li>
</ul>
<h3 id="第-6-章-代理"><a href="#第-6-章-代理" class="headerlink" title="第 6 章 - 代理"></a>第 6 章 - 代理</h3><ol start="21">
<li><span class="pn">Page 137</span><strong>代理与网关的区别</strong>：严格来讲，代理连接的是两个或多个使用<strong>相同协议</strong>的应用程序（中继）；而网关连接的则是两个或多个使用<strong>不同协议</strong>的端点（协议转换器）。但实际上，两者之间的区别很模糊。</li>
</ol>
<p><img src="9.png"></p>
<ul>
<li>正向代理（Forward Proxy）是“站在客户端这边”帮你访问服务器：VPN、爬虫等等；</li>
<li>反向代理（Reverse Proxy）是“站在服务器这边”帮你接收客户端请求：LBS、缓存、统一路由入口等等。</li>
</ul>
<ol start="22">
<li><span class="pn">Page 138</span><strong>代理的应用场景</strong>：</li>
</ol>
<ul>
<li>内容过滤器；</li>
<li>文档访问控制；</li>
<li>安全防火墙；</li>
<li>Web 缓存；</li>
<li>反向代理（这里指“假扮 Web 服务器”）；</li>
<li>内容路由器：根据流量状况以及内容类型将请求导向特定的 Web 服务器；</li>
<li>转码器；</li>
<li>匿名者：主动从 HTTP 报文中删除身份特性，以提供高度的私密性。</li>
</ul>
<ol start="23">
<li><span class="pn">Page 147</span><strong>代理如何获取流量</strong>：</li>
</ol>
<ul>
<li>修改客户端代理；</li>
<li>修改网络（交换设备或路由器，即“拦截”）；</li>
<li>修改 DNS 的命名空间（如基于 DNS 的 LB）；</li>
<li>修改 Web 服务器（通过 Location 响应首部，将请求重定向到代理）。</li>
</ul>
<ol start="24">
<li><span class="pn">Page 158</span><strong>Via 首部字段</strong>列出了与报文途径的每个中间节点（代理或网关）有关的信息。<strong>报文每经过一个节点，都必须将这个中间节点添加到 Via 列表的末尾</strong>。Server 首部仅用于原始服务器。</li>
<li><span class="pn">Page 162</span>TRACE 方法可用于跟踪报文在各个代理内的变化。当 TRACE 请求到达目的服务器时，<strong>整条请求报文都会被封装在一条 HTTP 响应的主体中回送给发送端</strong>。可以使用 <strong>Max-Forwards</strong> 首部来限制 TRACE 和 OPTIONS 请求所经过的代理跳数。Max-Forwards 每经过一个代理时会被减一，当其值为 0 时，则必须将 TRACE 报文回送给客户端。</li>
<li><span class="pn">Page 166</span>OPTIONS 请求可用于发现 Web 服务器上某个特定资源所支持的功能。请求成功后会返回一个包含各种首部字段的 200 响应，这些字段描述了服务器支持的，或资源可用的各种可选特性。HTTP/1.1 在响应中唯一指定的首部字段为 Allow 首部，其包含了服务器支持的方法列表。</li>
</ol>
<br><div class="article-bottom-meta"><span class="post-meta">Last built on<time itemprop="dateModified" datetime="2021-02-19T11:45:04.000Z"> 2025 / 06 / 07, 16:37:02</time></span></div></div></article><br><span class="next-post"><a href="/2021/02/22/《HTTP-权威指南》读书笔记（第-7-15、20-章）/" itemprop="url">下一篇 ⇒</a></span><span class="prev-post"><a href="/2021/02/17/React-特性小结（v17-0-1）/" itemprop="url">⇐ 上一篇</a></span><br><section id="comments"><h4>评论 | Comments</h4><br><div class="comment-container"><div class="loading-mask">Loading ...</div><script src="https://utteranc.es/client.js" repo="Becavalier/utterances-comments" issue-term="title" label="[Comment]" theme="github-light" crossorigin="anonymous" async></script></div></section><br><br></main><script src="/scripts/index.js" type="text/javascript"></script></body></html>