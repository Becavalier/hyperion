<!DOCTYPE html><html lang="en-us"><head><meta name="baidu-site-verification" content="codeva-P9jyH0b1lv"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>JIT Compilation：理解与实现 | 曜彤.手记</title><meta name="description" content="本文主要介绍了基础编译技术中的 JIT Compilation 技术，以及如何使用 C++ 快速构建一个简单的 JIT Compiler。"><meta name="generator" content="曜彤.手记"><meta name="about" content="[object Object]"><meta name="keywords" content="博客, C++, C, Rust, Web, Java, IT, 编程, 开发, Android, Python, MySQL, 科技, 黑客, 技术, Javascript, 云, 大数据, 计算, 机器学习, AI, 人工智能, 创业, 产品, 公司, WebAssembly, Wasm"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.jpg"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.jpg"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.jpg"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.jpg"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.jpg"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.jpg"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.jpg"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.jpg"><link rel="apple-touch-icon" sizes="196x196" href="/images/apple-touch-icon-196x196.jpg"><link rel="apple-touch-icon" sizes="310x310" href="/images/apple-touch-icon-310x310.jpg"><link href="/images/splash/iphone5_splash.png" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphone6_splash.png" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphoneplus_splash.png" media="(device-width: 621px) and (device-height: 1104px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/iphonex_splash.png" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/iphonexr_splash.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphonexsmax_splash.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/ipad_splash.png" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro1_splash.png" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro3_splash.png" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro2_splash.png" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="128x128" href="/images/favicon-128.png"><link rel="icon" type="image/png" sizes="196x196" href="/images/favicon-196x196.png"><meta name="msapplication-TileColor" content="#FFFFFF"><meta name="msapplication-TileImage" content="mstile-144x144.png"><meta name="msapplication-square70x70logo" content="mstile-70x70.png"><meta name="msapplication-square150x150logo" content="mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="mstile-310x150.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"><link rel="manifest" href="/manifest.webmanifest"><link rel="alternate" type="application/atom+xml" title="Atom 0.3" href="/atom.xml"><link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body itemscope itemtype="https://schema.org/WebPage"><div class="canvas-containter"><span>X</span></div><header itemscope itemtype="https://schema.org/WPHeader"><div class="logo"></div><h1 class="title"><a href="/" alt="曜彤.手记" title="曜彤.手记" itemprop="headline">曜彤.手记</a><a title="Atom 0.3" target="__blank" href="/atom.xml" class="rss"><img src="/images/rss.png"></a></h1><p itemprop="description" class="description">随记，关于互联网技术、产品与创业</p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name" class="menu-item"><a href="/ " alt="首页" title="首页" itemprop="url">首页</a></li><li itemprop="name" class="menu-item"><a href="/articles" alt="文章" title="文章" itemprop="url">文章</a></li><li itemprop="name" class="menu-item"><a href="/readings" alt="阅读" title="阅读" itemprop="url">阅读</a></li><li itemprop="name" class="menu-item"><a href="/cards" alt="快记" title="快记" itemprop="url">快记</a></li><li itemprop="name" class="menu-item"><a href="/tags" alt="标签" title="标签" itemprop="url">标签</a></li><li itemprop="name" class="menu-item"><a href="/about" alt="关于" title="关于" itemprop="url">关于</a></li></ul></nav><div class="dynamic-slot"></div><div class="toc-body"><div class="bookmark"></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Brainfuck-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80"><span class="toc-text">Brainfuck 编程语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JIT-Compilation"><span class="toc-text">JIT Compilation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-text">实现细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%9C%BA%E5%99%A8%E7%A0%81"><span class="toc-text">编译机器码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">可执行内存分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OSR%EF%BC%88On-Stack-Replacement%EF%BC%89"><span class="toc-text">OSR（On-Stack Replacement）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Benchmark"><span class="toc-text">Benchmark</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF"><span class="toc-text">更多信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Interpretation-%E4%B9%8B%E6%AE%87"><span class="toc-text">Interpretation 之殇</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JIT-%E5%AE%9E%E7%8E%B0%E7%AD%96%E7%95%A5%E4%B8%8E%E6%96%B9%E5%BC%8F"><span class="toc-text">JIT 实现策略与方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">参考资料</span></a></li></ol></div><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><script src="https://shadow.elemecdn.com/npm/zoomage.js@latest/dist/zoomage.min.js" type="text/javascript"></script><script src="https://shadow.elemecdn.com/npm/axios@0.18.0/dist/axios.min.js" type="text/javascript"></script><script src="/scripts/post.js" type="text/javascript"></script><div class="touch-top"><span></span></div><article post-id="JIT Compilation：理解与实现" class="full article-post"><h1 itemprop="headline" class="align-center">JIT Compilation：理解与实现</h1><div class="content"><div class="article-meta"><span class="post-meta"><br>Created on<time itemprop="dateCreated" datetime="2021-05-10T00:38:26.000Z"> 2021 / 05 / 10, 08:38:26</time></span><span class="page-tag-anchor"><a href="/tags/JIT" itemprop="url">#JIT</a>&nbsp;&nbsp;<a href="/tags/Compiler" itemprop="url">#Compiler</a>&nbsp;&nbsp;</span></div><p>本文主要介绍了基础编译技术中的 JIT Compilation 技术，以及如何使用 C++ 快速构建一个简单的 JIT Compiler。</p>
<p>大约是在一年以前，“<em>写一篇文章介绍 JIT Compiler 是如何工作的</em>”这个想法就一直躺在我的 TODO List 中迟迟不能被点掉，而如今终于有时间将之付诸行动。那么通过这篇文章，我希望能够让你了解到以下这些内容：</p>
<ul>
<li>什么是 JIT Compilation 技术？它有哪些特性？</li>
<li>如何使用 C++ 在不依赖任何框架的情况下实现一个 JIT Compiler？</li>
</ul>
<p>而限于篇幅和主题范围，本文将<strong>不会涉及</strong>以下这些内容：</p>
<ul>
<li>如何编写完备的 Interpreter / Compiler？</li>
<li>相关的高级编译优化技术。</li>
</ul>
<p>由于编写 JIT Compiler 会涉及到从诸如 C/C++ 等高级编程语言、汇编、计算机体系结构，直到操作系统等多个方面的知识，因此这里我将假设读者已经具备这些领域相关的基础知识，而当在文中实际涉及到相关内容时，我也会进行简单的介绍。</p>
<p>在本文接下来将要阐述的例子中，考虑到完备性，以及为了便于进行 Benchmark，我们会为一个名为 <strong>Brainfuck</strong> 的真实存在的编程语言实现一个简单的 JIT Compiler。同时，我们也会为其实现一个相应的 Interpreter，从而比较 JIT Compilation 与 Interpretation 这两种方式在代码整体执行效率上的差异。而关于 Interpreter 部分的具体实现细节，你可以参考例子所在仓库中给出的源代码，限于篇幅，本文将不做赘述。在我们正式开始之前，以下是你继续阅读所需要提前了解的一些事项：</p>
<ul>
<li>代码仓库：<em><strong><a target="_blank" rel="noopener" href="https://github.com/Becavalier/brainfuck-jit-interpreter">https://github.com/Becavalier/brainfuck-jit-interpreter</a></strong></em>；</li>
<li>我们构建的 JIT Compiler 将以 X86-64 作为目标平台，其可以运行在 macOS 与 Linux 系统上；</li>
<li>由于 Compiler 实现部分的代码较多，因此本文将有选择性地进行介绍，完整代码请参考上述仓库。</li>
</ul>
<p>好的，那让我们开始吧。</p>
<h3 id="Brainfuck-编程语言"><a href="#Brainfuck-编程语言" class="headerlink" title="Brainfuck 编程语言"></a>Brainfuck 编程语言</h3><p>Brainfuck 是一门从名字上来看就十分特殊的编程语言，它由 <em>Urban Müller</em> 于 1993 年创造。<em>brainfuck</em> 一词本身是一个<u><a target="_blank" rel="noopener" href="https://www.wordsense.eu/brainfuck/">俚语词汇</a></u>，通常用来指带那些超出人们理解的、非常复杂和罕见的事物，而 Brainfuck 这门语言便是如此。例如，以下这段 Brainfuck 代码在正常执行后便会向控制台输出 “Hello, world!” 这几个字符。</p>
<pre class="line-numbers language-brainfuck"><code class="language-brainfuck"><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token branching important">[</span><span class="token pointer keyword">></span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token pointer keyword">></span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token pointer keyword">></span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token pointer keyword">></span><span class="token increment inserted">+</span><span class="token pointer keyword">&lt;</span><span class="token pointer keyword">&lt;</span><span class="token pointer keyword">&lt;</span><span class="token pointer keyword">&lt;</span><span class="token decrement deleted">-</span><span class="token branching important">]</span><span class="token pointer keyword">></span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token operator">.</span><span class="token pointer keyword">></span><span class="token increment inserted">+</span><span class="token operator">.</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token operator">.</span><span class="token operator">.</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token operator">.</span><span class="token pointer keyword">></span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token operator">.</span><span class="token pointer keyword">&lt;</span><span class="token pointer keyword">&lt;</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token operator">.</span><span class="token pointer keyword">></span><span class="token operator">.</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token operator">.</span><span class="token decrement deleted">-</span><span class="token decrement deleted">-</span><span class="token decrement deleted">-</span><span class="token decrement deleted">-</span><span class="token decrement deleted">-</span><span class="token decrement deleted">-</span><span class="token operator">.</span><span class="token decrement deleted">-</span><span class="token decrement deleted">-</span><span class="token decrement deleted">-</span><span class="token decrement deleted">-</span><span class="token decrement deleted">-</span><span class="token decrement deleted">-</span><span class="token decrement deleted">-</span><span class="token decrement deleted">-</span><span class="token operator">.</span><span class="token pointer keyword">></span><span class="token increment inserted">+</span><span class="token operator">.</span><span class="token pointer keyword">></span><span class="token operator">.</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>可以看到，通过肉眼识别代码本身，我们根本无法得知整段程序的意图，而这也正映射了 Brainfuck 语言其名称的含义。虽然如此，但 Brainfuck 语言本身确是一门<strong>图灵完备的极简编程语言</strong>。Brainfuck 语言仅由 8 种不同的指令组成，所有由该语言编写的程序均包含由这 8 种不同指令组成的不同指令序列。而程序在运行时，其包含的这些指令序列将被顺序依次执行。除此之外，Brainfuck 的执行模型也十分简单。除这 8 种不同的指令外，程序在执行时还会维护一个至少包含 <em>30000</em> 个单元的<strong>一维字节数组</strong>（后面我们将简称其为“<strong>纸带</strong>”）。程序初始执行时，数组中的所有单元格均会被初始化为数值 0，一个可以前后移动的“<strong>数据指针</strong>”将默认指向这个数组的第一个单元。而程序在运行时将会根据不同的指令来前后移动这个数据指针，并相应地更新或使用当前所指向单元格中的内容。关于上述提到的 8 种指令，它们所对应的字符和说明如下所示：</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">指令字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&gt;</td>
<td>将数据指针的值增加 1（即向右移动，指向当前单元右侧的单元）</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td>将数据指针的值减少 1（即向左移动，指向当前单元左侧的单元）</td>
</tr>
<tr>
<td align="center">+</td>
<td>将数据指针当前所指向单元内的字节值增加 1</td>
</tr>
<tr>
<td align="center">-</td>
<td>将数据指针当前所指向单元内的字节值减少 1</td>
</tr>
<tr>
<td align="center">.</td>
<td>输出当前数据指针所指向单元内存放的字节值</td>
</tr>
<tr>
<td align="center">,</td>
<td>接受一个输入的字节值，并将其存放到当前数据指针所指向单元内</td>
</tr>
<tr>
<td align="center">[</td>
<td>如果当前数据指针所指向单元内的字节值为 0，则执行流程跳转到后续与其配对的 “]” 指令的后一个指令</td>
</tr>
<tr>
<td align="center">]</td>
<td>如果当前数据指针所指向单元内的字节值不为 0，则执行流程回退到前方与其配对的 “[” 指令的后一个指令</td>
</tr>
</tbody></table></div>
<p>为了加深理解，我们可以举一个简单的例子，比如下述这段 Brainfuck 代码。</p>
<pre class="line-numbers language-brainfuck"><code class="language-brainfuck"><span class="token increment inserted">+</span><span class="token increment inserted">+</span><span class="token branching important">[</span><span class="token decrement deleted">-</span><span class="token pointer keyword">></span><span class="token increment inserted">+</span><span class="token pointer keyword">&lt;</span><span class="token branching important">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这段代码首先会将纸带第一个单元格内的值连续递增两次（<code>++</code>），即变为 2。随后，<code>[</code> 指令检查到当前单元格内的值不为 0（为 2），因此继续执行下一条指令。后续的四个指令 <code>-&gt;+&lt;</code> 会先将当前单元格内的值减一，接下来将数据指针向右移动到第二个单元格，然后将该单元格内的值加一，随后再返回第一个单元格，如此往复循环。直达最后的 <code>]</code> 指令判定第一个单元格内的值为 0 时，程序结束运行。因此我们可以得知，这段程序主要用来更换纸带前两个单元格内的值。相应地，你也可以使用 <u><em><strong><a target="_blank" rel="noopener" href="https://brainfuck-visualizer.herokuapp.com/">Brainfuck Visualizer</a></strong></em></u> 来查看上述程序的完整动态执行过程。</p>
<h3 id="JIT-Compilation"><a href="#JIT-Compilation" class="headerlink" title="JIT Compilation"></a>JIT Compilation</h3><p>在了解了目标语言后，接下来让我们一起看看 <strong>JIT Compilation</strong> 技术究竟是什么？相信无论是做前端、后端，还是移动端，对于 “JIT” 一词，你都肯定有所耳闻。JIT Compilation 的全称为 “<em>Just-In-Time Compilation</em>”，翻译过来为“即时编译”。<strong>其最显著的特征是代码的编译过程发生在程序的执行期间，而非执行之前</strong>。通常在编译技术领域，我们会将 JIT 与 AOT 这两种方式进行对比。AOT 编译相信大家都十分熟悉，常见的比如：使用 <em>Clang</em> 对 C/C++ 代码进行编译、使用 <em>Babel</em> 编译 ES6 代码，甚至是将 JavaScript 代码编译为专用于某一 JS 引擎的 IR（Intermediate Representation）等过程都可以被认作是 AOT 编译的一种具体类型。而 JIT 与 AOT 之间的最大区别便是“<em>编译过程发生的时间点</em>”，对于 JIT 而言，其编译过程发生在程序的运行时；而对 AOT 来说，编译过程则发生在程序执行之前（通常为构建时）。</p>
<p>传统的 JIT 编译器在实际动态生成机器码前，会首先对原始代码或其相应的 IR 中间代码进行一系列的分析（<em>profiling</em>）。通过这些分析过程，编译器能够找到可以通过 JIT 编译进行性能优化的“关键代码路径”。而这里的取舍重点在于：<strong>对这些代码进行运行时优化而得到的性能提升收益，需要高于进行优化时所产生的性能开销</strong>。在后面的文章中我们将会看到，对于我们的实例而言，这些开销主要来自于代码的运行时编译，以及进行 OSR（On-Stack Replacement）的过程。而为了便于理解，在本文后续的实例中，我们将不会实现传统 JIT 所进行的代码预分析过程。</p>
<p>另外需要注意的是，通常的 JIT 编译器由于考虑到“<strong>启动延迟</strong>（<em>startup time delay</em>）”的问题，因此一般会结合解释器一起使用。JIT 编译器所进行的代码分析过程越精细、所实施的优化越多，其动态生成的机器代码质量也会越高，但随之而来的初始代码执行延迟也会越大。而解释器的加入便可使代码的执行过程提前进行。而在此期间，JIT 编译器也会同时对代码进行分析和优化，并在特定的时刻再将程序的执行流程从解释执行转换到执行其动态生成的优化机器码。因此，对于 JIT Compilation 这项技术而言，其实现方式需要取舍的一个重点是：<strong>在编译时间和生成的代码质量之间进行权衡</strong>。比如，JVM 便有着两种可以选择的 JIT 模式 —— <em>client</em> 与 <em>server</em>，其中前者会采用最小的编译和优化选项以最大程度降低启动延迟；而后者则会采用最大化的编译和优化策略，同时牺牲程序的启动时间。</p>
<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><p><em>Ok, it’s time to showcase :)<em>。首先声明，我们为 Brainfuck 语言实现的 JIT Compiler 只用于作为本文内容的 POC，而并没有考虑作为生产版本的完备性，比如：</em>exception-handling</em>、<em>thread-safe</em>、<em>profiling</em>、<em>assembly fine-tuning</em> 等等。其次，接下来将要介绍的实现细节将着重聚焦于源代码中的函数 <em><strong>bfJITCompile</strong></em>、函数 <em><strong>allocateExecMem</strong></em>，以及类 <em><strong>VM</strong></em> 这三个部分，这里建议在继续阅读前，先自行大致浏览一下源代码。</p>
<p>就如同上面我们所说的那样，JIT Compilation 的代码编译过程发生在程序的运行时，因此从源代码中也可以看到，我们通过用户在运行解释器程序时所提供的不同参数（–jit）来决定是采用 JIT 编译执行，还是直接解释执行。而对于 “JIT 编译执行” 这种方式来说，其流程可大致总结为：</p>
<ul>
<li>读入源代码（包含 ASCII 形式的指令序列）；</li>
<li><strong>调用 <em>bfJITCompile</em> 函数，将源代码编译为机器码</strong>；</li>
<li><strong>调用 <em>allocateExecMem</em> 函数，将机器码动态分配在可执行的内存段上</strong>；</li>
<li><strong>调用 <em>VM::exec</em> 函数，通过 OSR 转移执行流程</strong>；</li>
<li>代码执行完毕后再次转移回主流程；</li>
<li>执行一些清理善后工作。</li>
</ul>
<p>接下来，我们将重点介绍上述流程中的第二、三及第四项的具体实现细节。</p>
<h4 id="编译机器码"><a href="#编译机器码" class="headerlink" title="编译机器码"></a>编译机器码</h4><p>在这一步中，我们会将程序启动时输入的 Brainfuck 源代码中的所有指令字符全部“提取”出来，并直接按顺序为其生成相应的机器码版本的二进制代码。这些生成的二进制机器码集合将被存放在一个 <code>std::vector</code> 对象中以备后续使用。为了简化机器码的生成过程，我们简单地通过 <code>switch</code> 语句识别出指令对应的字符，并“返回”该指令对应的 X86-64 二进制机器码。而这些返回的机器码也将被直接“拼接”到用于存放机器码集合的 Vector 容器中。</p>
<p>这里需要注意的是，对于这些返回的二进制机器码，由于其中可能含有引用的相对地址信息（RIP-Relative），因此在被实际存放到 Vector 容器之前，我们还需要通过诸如 <em>_relocateAddrOfPrintFunc</em> 等方法来对这些二进制机器码进行“<strong>地址重定位</strong>”处理。通过这些方法，我们能够准确计算出这些相对地址的实际信息，并对它们进行修正。</p>
<p>首先，在 <em>bfJITCompile</em> 函数的定义中我们可以找到如下这段代码。通过这段代码，我们将 Brainfuck 执行模型中的“数据指针”其地址存放在了寄存器 <em>rbx</em> 中，这样后续我们便可以通过修改或使用该寄存器中的值来控制数据指针的位置，或者读取、修改当前数据指针所指向纸带单元格中的内容。这里代码中的 “/* mem slot */” 表示该注释所在位置的内容将在编译时被替换为实际引用的内存地址。而这个地址将来自于 <code>bfState::ptr</code> 的值在经过函数 <em>_resolvePtrAddr</em> 处理后返回的小端（<em>little-endian</em>）格式地址。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// prologue.</span>
std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>uint8_t<span class="token operator">></span> machineCode <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// save dynamic pointer in %rbx.</span>
  <span class="token number">0x48</span><span class="token punctuation">,</span> <span class="token number">0xbb</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">/* mem slot */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// ...</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来，随着不断读入的指令字符，<em>bfJITCompile</em> 函数便可以依次将这些指令转换为其对应的机器码版本。对于 “+ - &gt; &lt;” 这四个指令来说，它们所对应的机器指令只需要通过操作我们先前存放在 <em>rbx</em> 寄存器中的数据指针的地址值，便可完成对 Brainfuck 抽象机器的状态改变。比如以 “+” 指令为例，我们可以找到如下这段代码：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// ...</span>
<span class="token keyword">case</span> <span class="token string">'+'</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">*</span>tok <span class="token operator">==</span> <span class="token string">'+'</span><span class="token punctuation">;</span> <span class="token operator">++</span>n<span class="token punctuation">,</span> <span class="token operator">++</span>tok<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">auto</span> ptrBytes <span class="token operator">=</span> <span class="token function">_resolvePtrAddr</span><span class="token punctuation">(</span>ptrAddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>uint8_t<span class="token operator">></span> byteCode <span class="token punctuation">{</span> 
    <span class="token number">0x80</span><span class="token punctuation">,</span> <span class="token number">0x3</span><span class="token punctuation">,</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>uint8_t<span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// addb $0x1, (%rbx)</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token function">_appendBytecode</span><span class="token punctuation">(</span>byteCode<span class="token punctuation">,</span> machineCode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">--</span>tok<span class="token punctuation">;</span>
  <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
<span class="token comment" spellcheck="true">// ...</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这段代码中我们首先使用了一个很容易想到的优化策略，那就是当遇到连续的 “+” 指令时，相较于为每一个出现的 “+” 指令都生成相同的、重复的机器码，我们可以选择首先计算遇到的连续出现的 “+” 指令的个数，然后再通过一条单独的汇编指令 <code>addb $N, (%rbx)</code> 来将这多个 “+” 指令所产生的状态变更一次性完成。相同的方式还可以被应用到其余的三种指令，它们分别对应数据指针所指向单元格内值的改变，以及数据指针本身的值的改变。</p>
<p>而对于 “,” 及 “.” 指令来说，由于它们涉及 IO 操作，因此这里对应的机器码将涉及对操作系统调用（<em>System Call</em>）的调用过程。操作系统调用需要遵循特定的调用惯例（<em>Calling Convention</em>），比如通常来说，寄存器 <em>rax</em> 用于存放系统调用号、<em>rdi</em> 用于存放第一个参数、<em>rsi</em> 用于存放第二个参数，以及 <em>rdx</em> 用于存放第三个参数等等。同时，macOS 与 Linux 操作系统下的系统调用号也并不相同，这里我们通过预处理指令来进行区分。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// ...</span>
<span class="token keyword">case</span> <span class="token string">','</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">/**
    movl $0x2000003, %eax
    movl $0x0, %edi
    movq %rbx, %rsi
    movl $0x1, %edx
    syscall
  */</span>
  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>uint8_t<span class="token operator">></span> byteCode <span class="token punctuation">{</span> 
<span class="token macro property">#<span class="token directive keyword">if</span> __APPLE__</span>
    <span class="token number">0xb8</span><span class="token punctuation">,</span> <span class="token number">0x3</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0x2</span><span class="token punctuation">,</span>
<span class="token macro property">#<span class="token directive keyword">elif</span> __linux__</span>
    <span class="token number">0xb8</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
    <span class="token number">0xbf</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span>
    <span class="token number">0x48</span><span class="token punctuation">,</span> <span class="token number">0x89</span><span class="token punctuation">,</span> <span class="token number">0xde</span><span class="token punctuation">,</span>
    <span class="token number">0xba</span><span class="token punctuation">,</span> <span class="token number">0x1</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span>
    <span class="token number">0xf</span><span class="token punctuation">,</span> <span class="token number">0x5</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token function">_appendBytecode</span><span class="token punctuation">(</span>byteCode<span class="token punctuation">,</span> machineCode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// ...</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后，对于 “[” 和 “]” 指令，其实现逻辑会稍微有些复杂。以 “[” 指令为例，如下代码所示。在这里，将 “[” 指令的语义逻辑直接映射到汇编代码是十分简单的，其逻辑是：<em>判断当前数据指针所指向单元格的值是否为 0。若为 0，则执行流程跳转到后续与其配对的 “]” 指令的后一个指令；否则继续执行下一条指令</em>。因此，我们这里直接使用 <em>cmpb</em> 汇编指令来判断以寄存器 <em>rbx</em> 中的值作为地址时，其对应内存位置的值是否为 0。若为 0，则使用 <em>je</em> 汇编指令跳转到后续的指令位置，否则直接执行下一条指令。代码中对“后续指令地址”的使用将会在与其配对的 “]” 指令处理流程中对其进行重定向处理。因此，这里我们将使用连续四个字节的 0x0 值进行占位。另外需要知道的是，为了简化实现，这里我们将固定使用 “<em>near jump</em>” 模式。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// ...</span>
<span class="token keyword">case</span> <span class="token string">'['</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">/*
    cmpb $0x0, (%rbx)
    je &lt;>
  */</span>
  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>uint8_t<span class="token operator">></span> byteCode <span class="token punctuation">{</span> 
    <span class="token number">0x80</span><span class="token punctuation">,</span> <span class="token number">0x3b</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span>
    <span class="token number">0xf</span><span class="token punctuation">,</span> <span class="token number">0x84</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">/* near jmp */</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// record the jump relocation pos.</span>
  <span class="token function">_appendBytecode</span><span class="token punctuation">(</span>byteCode<span class="token punctuation">,</span> machineCode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  jmpLocIndex<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>machineCode<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// ...</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>至此，我们便完成了机器指令的动态编译工作。通过这个阶段，我们的程序可以将输入的 Brainfuck 指令字符序列转换成对应的平台相关的二进制机器码。你可以在 <em>bfJITCompile</em> 函数的最后看到如下这样一段用来<strong>收尾的代码</strong>。这段代码主要用于在程序退出前输出 <em>stdout</em> 缓存区中的内容，并重置 <em>rip</em> 寄存器的值，以将程序执行流程退回到 C++ 代码中。后续我们还将回顾这部分内容。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// epilogue. </span>
<span class="token comment" spellcheck="true">// mainly restoring the previous pc, flushing the stdout buffer.</span>
<span class="token comment" spellcheck="true">/**
  cmpq $0, %r11
  je 8
  callq &lt;print>
  jmpq *(%rsp)
  */</span>
std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>uint8_t<span class="token operator">></span> byteCode <span class="token punctuation">{</span>
  <span class="token number">0x49</span><span class="token punctuation">,</span> <span class="token number">0x83</span><span class="token punctuation">,</span> <span class="token number">0xfb</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span>
  <span class="token number">0x74</span><span class="token punctuation">,</span> <span class="token number">0x8</span><span class="token punctuation">,</span>
  <span class="token number">0xe8</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">/* mem slot */</span>
  <span class="token number">0xff</span><span class="token punctuation">,</span> <span class="token number">0x24</span><span class="token punctuation">,</span> <span class="token number">0x24</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="可执行内存分配"><a href="#可执行内存分配" class="headerlink" title="可执行内存分配"></a>可执行内存分配</h4><p>接下来，我们将关注点从“如何动态生成机器码”移到“如何动态执行机器码”这个问题上。关于这部分实现可以参考名为 <em>allocateExecMem</em> 的函数，相关如下代码所示。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// ...</span>
uint8_t<span class="token operator">*</span> <span class="token function">allocateExecMem</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>uint8_t<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>
    <span class="token function">mmap</span><span class="token punctuation">(</span>
      <span class="token constant">NULL</span><span class="token punctuation">,</span>
      size<span class="token punctuation">,</span> 
      PROT_READ <span class="token operator">|</span> PROT_WRITE <span class="token operator">|</span> PROT_EXEC<span class="token punctuation">,</span> 
      MAP_PRIVATE <span class="token operator">|</span> MAP_ANONYMOUS<span class="token punctuation">,</span> 
      <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>
      <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// ...</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这个函数的定义中，我们调用名为了 <code>mmap</code> 的函数，而这个函数便是支持“动态执行机器码”的关键所在。<code>mmap</code> 函数是一个由 C 标准库提供的系统调用，通过该函数，我们可以在当前进程的 VAS（Virtual Address Space）中创建一个映射。这个映射可以指向一个具体的文件、或者是一个匿名空间。关于 <code>mmap</code> 函数，我们最为熟知的一种使用方式便是在为目标文件分配虚拟页时，操作系统会使用该函数将页表条目指向目标文件中的适当位置。而在这里，我们则需要利用该函数创建不指向任何实际文件的“匿名空间”，并将我们在上一步中编译得到的二进制机器码连续地放入到这段内存空间中。</p>
<p>不仅如此，通过为 <code>mmap</code> 函数的第三个参数指定 PROT_EXEC 属性，我们可以将这段申请的匿名内存空间标记为“<strong>可执行</strong>”。这意味着，存放在这段内存空间中的机器指令可以被 CPU 执行。而关于该函数其他参数的详细配置信息，你可以参考<u><strong><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/mmap.2.html">这里</a></strong></u>找到更多答案。<em>allocateExecMem</em> 函数的实际调用过程则被放置在了 <code>VM</code> 类的构造函数中，在这里我们通过 RAII 将资源的分配与销毁进行了简单的封装。</p>
<h4 id="OSR（On-Stack-Replacement）"><a href="#OSR（On-Stack-Replacement）" class="headerlink" title="OSR（On-Stack Replacement）"></a>OSR（On-Stack Replacement）</h4><p>当编译生成的二进制机器码被放入可执行的匿名内存段后，接下来的重点便是：<em>如何将程序的指令执行流程转移至这段内存的起始位置处？</em>关于这部分实现，我们需要借助 Clang/GCC 编译器提供的 “C++ 内联汇编” 功能。你可以在 <code>VM::exec</code> 函数的实现中找到答案。这段代码如下所示：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// ...</span>
<span class="token keyword">void</span> <span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// save the current %rip on stack (by PC-relative).</span>
  <span class="token comment" spellcheck="true">// %r10 - stdout buffer entry.</span>
  <span class="token comment" spellcheck="true">// %r11 - stdout buffer counter.</span>
  <span class="token keyword">asm</span><span class="token punctuation">(</span>R"<span class="token punctuation">(</span>
    pushq <span class="token operator">%</span><span class="token operator">%</span>rax
    pushq <span class="token operator">%</span><span class="token operator">%</span>rbx
    pushq <span class="token operator">%</span><span class="token operator">%</span>r10
    pushq <span class="token operator">%</span><span class="token operator">%</span>r11
    pushq <span class="token operator">%</span><span class="token operator">%</span>r12
    movq <span class="token operator">%</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">%</span><span class="token operator">%</span>r10
    xorq <span class="token operator">%</span><span class="token operator">%</span>r11<span class="token punctuation">,</span> <span class="token operator">%</span><span class="token operator">%</span>r11
    lea <span class="token function">0x9</span><span class="token punctuation">(</span><span class="token operator">%</span><span class="token operator">%</span>rip<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">%</span><span class="token operator">%</span>rax 
    pushq <span class="token operator">%</span><span class="token operator">%</span>rax
    movq <span class="token operator">%</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">%</span><span class="token operator">%</span>rax
    addq <span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">%</span><span class="token operator">%</span>rax
    jmpq <span class="token operator">*</span><span class="token operator">%</span><span class="token operator">%</span>rax 
  <span class="token punctuation">)</span><span class="token string">":: "</span>S<span class="token string">" (mem), "</span>m<span class="token string">" (stdoutBuf), "</span>D" <span class="token punctuation">(</span>prependStaticSize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// clean the stack.</span>
  <span class="token keyword">asm</span><span class="token punctuation">(</span>R"<span class="token punctuation">(</span>
    addq $<span class="token number">8</span><span class="token punctuation">,</span> <span class="token operator">%</span>rsp
    popq <span class="token operator">%</span>r12
    popq <span class="token operator">%</span>r11
    popq <span class="token operator">%</span>r10
    popq <span class="token operator">%</span>rbx
    popq <span class="token operator">%</span>rax
  <span class="token punctuation">)</span>"<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// ...</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这段代码中，我们使用了两次 <code>asm</code> 汇编指令。其中，第一次内联汇编的目的主要是为了将程序的执行流程转移到我们之前动态编译生成的机器码上。这里前 5 行对 <code>push</code> 指令的调用过程主要用于将这些寄存器中的值存放到栈上，以保护此刻的寄存器状态。而这些值将会在程序的执行流程返回到 C++ 代码后再被重新恢复。第 6 行的 <code>movq</code> 指令将 <em>stdout buffer</em> 的首地址存放到了寄存器 <em>r10</em> 中，这个 <em>buffer</em> 将用于缓存通过 “.” 指令输出的字符内容，<strong>以减少系统调用的实际调用次数，提升性能</strong>。接下来的第 8-9 行，我们将正常 C++ 代码执行流程的下一条指令其地址存放到了栈上，以便后续能够从动态执行流程中正常返回。第 10-11 行，我们正确地设置了匿名可执行内存段的地址以及相应的偏移位置（跨过了静态的 <em>subroutine</em> 定义部分）。最后一行，通过 <code>jmpq</code> 指令，我们让 CPU 的执行流程跳转到以 <em>rax</em> 寄存器中的值作为内存地址的位置，即包含我们将要执行的第一条动态指令的位置。</p>
<p>至此，从 C++ 代码到动态指令的执行转移流程便完成了。而当动态生成的指令全部执行完毕后，我们需要通过类似的方式再将执行流程转移回正常的 C++ 代码中。还记得我们在“编译机器码”这一小节最后提到的那小段 “<em>epilogue</em>” 汇编代码吗？如果返回去查看，你会发现在这段代码的最后一条指令中，我们使用了 <code>jmpq *(%rsp)</code> 指令，这条指令将会把 CPU 的执行流程转移到以当前进程栈底存放的那个 <em>qword</em> 值作为地址的内存位置上。而这个值，便是我们在上一步中存放的 C++ 代码的返回地址。当执行流程返回到 C++ 代码后，我们遇到了第二个 <code>asm</code> 汇编指令。通过这段指令，我们可以清理栈上的内容并同时恢复相关寄存器的状态。到这里，程序的执行流程便基本结束了。</p>
<p>让我们将目光再移回到本小节的主题 “OSR” 上来。OSR 的全称为 “On-Stack Replacement”。借助 Google，我们可以找到对它的一个定义，如下所示：</p>
<blockquote>
<p>On-stack-replacement (OSR) describes the ability to replace currently executing code with a different version, either a more optimized one (tiered execution) or a more general one (deoptimization to undo speculative optimization).</p>
</blockquote>
<p>实际上，对于 OSR 我们可以将其简单理解为“<strong>从一个执行环境到另一个执行环境的转换过程</strong>”。比如在我们的实例中，<code>VM::exec</code> 函数在执行时，它会将执行环境从 C++ 代码转移至动态生成的机器码，最后再以同样的方式转移回来。而这样的执行环境转换便可被视为 OSR 的过程。下图是对上述 OSR 过程的一个形象展示。</p>
<p><img src="1.png"></p>
<h3 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h3><p>至此，我们已经介绍完了 Brainfuck JIT Compiler 几个关键点的实现细节。那现在让我们来看看这个粗糙版的 JIT 编译器其性能如何？项目的源代码中提供了两组测试，分别用于测试 “<strong>IO 密集型</strong>” 和“<strong>计算密集型</strong>”这两个场景。一组测试结果如下所示：</p>
<ul>
<li><em><strong>IO 密集型 case</strong></em>：</li>
</ul>
<pre class="line-numbers language-text"><code class="language-text">Benchmark for 10 seconds: (higher score is better)
   12950 interpreter
   35928 jit (win)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li><em><strong>计算密集型 case</strong></em>：</li>
</ul>
<pre class="line-numbers language-text"><code class="language-text">Benchmark Result: (lower time is better)
    13.018s interpreter
     0.885s jit (win)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>可以看到，总体结果还算不错。对于 IO 密集型的测试用例，JIT Compilation 相比单纯的 Interpretation 可以带来将近 <strong>3 倍</strong>的性能提升。而对于计算密集型场景来说，JIT 带来的性能提升便十分可观了。在我们的“<em>打印曼德布洛特集合</em>”的测试用例中，使用 JIT Compilation 相较于 Interpretation 可以带来将近 <strong>15 倍</strong>的性能提升。当然，鉴于我们并没有采用更加完备的测试集合及测试方案，这些测试用例结果仅供参考。</p>
<h3 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h3><p>接下来，我们将会对额外的一些问题进行适当的讨论。当然，这些话题中每一个都可以展开形成一篇完整的文章，因此这里只做引申之意。更多的信息请自行 Google。</p>
<h4 id="Interpretation-之殇"><a href="#Interpretation-之殇" class="headerlink" title="Interpretation 之殇"></a>Interpretation 之殇</h4><p>可以说，“<em>branch-misprediction</em>” 是众多导致解释器运行缓慢的原因中最为重要的一个。例如我们在本文实例的源代码中实现的那个基于 <code>switch</code> 语句的解释器。这个解释器模型每次读取输入源文件中的一个字符指令，然后再根据指令内容相应地改变当前解释器的状态（如：数据指针、纸带内容等）。而这样方式所产生的问题在于：从宏观来看，CPU 在实际执行这个 switch 语句时，无法得知下一次将要输入的可能符号指令是什么，而这便会导致 “PC 分支预测” 失败。从微观上来看，无法预测或预测失败都会导致 CPU 时钟周期的浪费（需等待结果，或丢弃错误预测值而导致流水线重填装等）。因此，由“流水线相关”导致的指令延迟也将在大量指令执行后凸显出来。</p>
<p>而对于诸如 “<em>Direct Threading</em>” 与 “<em>Subroutine Threading</em>” 等解释器模型来说，它们虽然可以较好地解决分支预测失败的问题，但随之而来的诸如：使用了过多的 <code>jmp</code> 指令、产生了无用的栈帧（没有 <em>inline</em>）等问题也会大大降低解释器在解释程序时的性能。相对的，JIT Compilation 通过动态生成机器码、<em>inlining</em> 编译等基本优化策略便可轻松避免上述这些问题。不仅如此，某些 JIT 编译器甚至能够获得比 AOT 方式更高的运行时性能提升。而这主要源于 JIT 能够在代码运行时根据当前操作系统类型、CPU ISA 体系、代码 Profiling 结果进行更加动态、启发式的代码优化过程。</p>
<h4 id="JIT-实现策略与方式"><a href="#JIT-实现策略与方式" class="headerlink" title="JIT 实现策略与方式"></a>JIT 实现策略与方式</h4><p>常见的 <strong>JIT 策略</strong>可以被分为这样几类：<em><strong>Method-based JIT</strong></em>、<em><strong>Trace-based JIT</strong></em> 以及 <em><strong>Region-based JIT</strong></em>。其中，<em>Method-based JIT</em> 使用“函数”作为独立的编译单元，编译器会在代码执行的过程中识别出热点函数（比如依据函数的被调用次数），然后再使用编译后的机器码版本进行替换。这种方式实现较为简单但也存在相应的问题，比如其 JIT 粒度较为粗糙，热代码的命中率较低，位于函数体中的耗时逻辑（比如“循环”）无法被准确捕捉。</p>
<p>相对的，<em>Trace-based JIT</em> 则使用 “Trace” 作为热代码的编译单元。一个 Trace 是指程序在运行时所执行的一段热代码路径。从源代码上来看，这些热代码的执行路径可能会横跨多个函数。而 JIT 编译器要做的事情，便是对这段路径上的热代码进行运行时的编译优化。</p>
<p>最后的 <em>Region-based JIT</em> 则是以 “Tracelet” 作为其编译单元的，这种 JIT 方案主要来自于 Facebook 的 HHVM 虚拟机实现。一个 Tracelet 通常是指一段可以被“类型特化”的最长的执行路径。更多的信息可以参考<u><strong><a target="_blank" rel="noopener" href="https://research.fb.com/wp-content/uploads/2018/04/hhvm-jit-a-profile-guided-region-based-compiler-for-php-and-hack.pdf">这篇论文</a></strong></u>（作者也不了解，就不展开讲了）。</p>
<p>除了上述这三种常见的 JIT 编译器实现策略外，对于实现细节，相较于我们在本文中使用的“人肉机器码编译”过程，通常我们会选择使用一些编译框架来提供更好的机器码拣选和编译功能。常用的框架比如：<em>DynASM</em>、<em>LLVM</em> 以及 <em>Cranelift</em> 等。这些框架通常不止提供基础的、针对具体平台的机器码编译功能、同时也还会提供相应的代码优化功能。比如对于 <em>Method-based JIT</em> 这种策略来说，通常一些可用于静态 AOT 编译的优化策略也可以被 JIT 编译器直接使用，而通过使用诸如 LLVM，我们便可以更简单地直接使用这些十分成熟的优化策略，免除了重复实现的烦恼。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><em><a target="_blank" rel="noopener" href="https://solarianprogrammer.com/2018/01/10/writing-minimal-x86-64-jit-compiler-cpp/">https://solarianprogrammer.com/2018/01/10/writing-minimal-x86-64-jit-compiler-cpp/</a>.</em></li>
<li><em><a target="_blank" rel="noopener" href="https://solarianprogrammer.com/2018/01/12/writing-minimal-x86-64-jit-compiler-cpp-part-2/">https://solarianprogrammer.com/2018/01/12/writing-minimal-x86-64-jit-compiler-cpp-part-2/</a>.</em></li>
<li><em><a target="_blank" rel="noopener" href="https://corsix.github.io/dynasm-doc">https://corsix.github.io/dynasm-doc</a>.</em></li>
<li><em><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Just-in-time_compilation">https://en.wikipedia.org/wiki/Just-in-time_compilation</a>.</em></li>
<li><em><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tracing_just-in-time_compilation">https://en.wikipedia.org/wiki/Tracing_just-in-time_compilation</a>.</em></li>
<li><em><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Brainfuck">https://en.wikipedia.org/wiki/Brainfuck</a>.</em></li>
<li><em><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc-4.0.2/gcc/Extended-Asm.html#Extended-Asm">https://gcc.gnu.org/onlinedocs/gcc-4.0.2/gcc/Extended-Asm.html#Extended-Asm</a>.</em></li>
<li><em><a target="_blank" rel="noopener" href="https://github.com/opensource-apple/xnu/blob/master/bsd/kern/syscalls.master">https://github.com/opensource-apple/xnu/blob/master/bsd/kern/syscalls.master</a>.</em></li>
<li><em><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Ahead-of-time_compilation">https://en.wikipedia.org/wiki/Ahead-of-time_compilation</a>.</em></li>
<li><em><a target="_blank" rel="noopener" href="http://prl.ccs.neu.edu/blog/2019/01/28/on-stack-replacement/">http://prl.ccs.neu.edu/blog/2019/01/28/on-stack-replacement/</a>.</em></li>
<li><em><a target="_blank" rel="noopener" href="https://javapapers.com/core-java/jvm-server-vs-client-mode">https://javapapers.com/core-java/jvm-server-vs-client-mode</a>.</em></li>
</ol>
<br><div class="article-bottom-meta"><span class="post-meta">Last built on<time itemprop="dateModified" datetime="2021-05-10T00:38:26.000Z"> 2023 / 10 / 26, 11:37:10</time></span></div></div></article><br><span class="next-post"><a href="/2021/05/11/GCC-下默认的对齐指针访问（Aligned-Memory-Access）/" itemprop="url">下一篇 ⇒</a></span><span class="prev-post"><a href="/2021/05/06/Rust-Runtime-与-ABI/" itemprop="url">⇐ 上一篇</a></span><br><section id="comments"><h4>评论 | Comments</h4><br><div class="comment-container"><div class="loading-mask">Loading ...</div><script src="https://utteranc.es/client.js" repo="Becavalier/utterances-comments" issue-term="title" label="[Comment]" theme="github-light" crossorigin="anonymous" async></script></div></section><br><br></main><script src="/scripts/index.js" type="text/javascript"></script></body></html>