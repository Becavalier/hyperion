<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>C++ Dependent Names、non-ADL 以及 ADL 查找 | 曜彤.手记</title><meta name="description" content="记录下 C++ 中对于 Dependent Names 在 non-ADL 以及 ADL 这两种情况下的名字查找规则。"><meta name="generator" content="曜彤.手记"><meta name="about" content="[object Object]"><meta name="keywords" content="博客, C++, C, Rust, Web, Java, IT, 编程, 开发, Android, Python, MySQL, 科技, 黑客, 技术, Javascript, 云, 大数据, 计算, 机器学习, AI, 人工智能, 创业, 产品, 公司, WebAssembly, Wasm"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.jpg"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.jpg"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.jpg"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.jpg"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.jpg"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.jpg"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.jpg"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.jpg"><link rel="apple-touch-icon" sizes="196x196" href="/images/apple-touch-icon-196x196.jpg"><link rel="apple-touch-icon" sizes="310x310" href="/images/apple-touch-icon-310x310.jpg"><link href="/images/splash/iphone5_splash.png" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphone6_splash.png" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphoneplus_splash.png" media="(device-width: 621px) and (device-height: 1104px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/iphonex_splash.png" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/iphonexr_splash.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphonexsmax_splash.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/ipad_splash.png" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro1_splash.png" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro3_splash.png" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro2_splash.png" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="128x128" href="/images/favicon-128.png"><link rel="icon" type="image/png" sizes="196x196" href="/images/favicon-196x196.png"><meta name="msapplication-TileColor" content="#FFFFFF"><meta name="msapplication-TileImage" content="mstile-144x144.png"><meta name="msapplication-square70x70logo" content="mstile-70x70.png"><meta name="msapplication-square150x150logo" content="mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="mstile-310x150.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"><link rel="manifest" href="/manifest.webmanifest"><link rel="alternate" type="application/atom+xml" title="Atom 0.3" href="/atom.xml"><link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body itemscope itemtype="https://schema.org/WebPage"><div class="canvas-containter"><span>X</span></div><header itemscope itemtype="https://schema.org/WPHeader"><div class="logo"></div><h1 class="title"><a href="/" alt="曜彤.手记" title="曜彤.手记" itemprop="headline">曜彤.手记</a><a title="Atom 0.3" target="__blank" href="/atom.xml" class="rss"><img src="/images/rss.png"></a></h1><p itemprop="description" class="description">随记，关于互联网技术、产品与创业</p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name" class="menu-item"><a href="/ " alt="首页" title="首页" itemprop="url">首页</a></li><li itemprop="name" class="menu-item"><a href="/articles" alt="文章" title="文章" itemprop="url">文章</a></li><li itemprop="name" class="menu-item"><a href="/readings" alt="阅读" title="阅读" itemprop="url">阅读</a></li><li itemprop="name" class="menu-item"><a href="/cards" alt="快记" title="快记" itemprop="url">快记</a></li><li itemprop="name" class="menu-item"><a href="/tags" alt="标签" title="标签" itemprop="url">标签</a></li><li itemprop="name" class="menu-item"><a href="/about" alt="关于" title="关于" itemprop="url">关于</a></li></ul></nav><div class="toc-slot"></div><div class="toc-body"><div class="bookmark"></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dependent-Names"><span class="toc-text">Dependent Names</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E8%A7%84%E5%88%99"><span class="toc-text">绑定规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E8%A7%84%E5%88%99"><span class="toc-text">查找规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ADL"><span class="toc-text">ADL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></div><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><script src="https://shadow.elemecdn.com/npm/zoomage.js@latest/dist/zoomage.min.js" type="text/javascript"></script><script src="https://shadow.elemecdn.com/npm/axios@0.18.0/dist/axios.min.js" type="text/javascript"></script><script src="/scripts/post.js" type="text/javascript"></script><div class="touch-top"><span></span></div><article post-id="C++ Dependent Names、non-ADL 以及 ADL 查找" class="full"><h1 itemprop="headline" class="align-center">C++ Dependent Names、non-ADL 以及 ADL 查找</h1><div class="content"><div class="article-meta"><span class="post-meta"><br>Created on<time itemprop="dateCreated" datetime="2020-08-18T10:13:58.000Z"> 2020 / 08 / 18, 18:13:58</time></span><span class="page-tag-anchor"><a href="/tags/Cpp" itemprop="url">#Cpp</a>&nbsp;&nbsp;</span></div><p>记录下 C++ 中对于 Dependent Names 在 non-ADL 以及 ADL 这两种情况下的名字查找规则。</p>
<h3 id="Dependent-Names"><a href="#Dependent-Names" class="headerlink" title="Dependent Names"></a>Dependent Names</h3><p>Dependent-name 主要出现在模板定义中。主要指对于一些结构体的实际定义，将取决于真正实例化时的模板参数。特别地，类型和表达式的真正定义取决于<strong>模板实例化时的参数类型</strong>，以及<strong>非类型的模板参数值</strong>。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">struct</span> X <span class="token operator">:</span> B<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// "B&lt;T>" is dependent on T.</span>
  <span class="token keyword">typename</span> T<span class="token operator">::</span>A<span class="token operator">*</span> pa<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "T::A" is dependent on T.</span>

  <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>B<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> pb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> B<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "B&lt;T>::i" is dependent on T.</span>
    pb<span class="token operator">-</span><span class="token operator">></span>j<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "pb->j" is dependent on T.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因此，对于 Dependent 的名字查找和绑定规则会有所不同。</p>
<h3 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h3><p>Non-dependent 的名字会在模板<strong>定义时</strong>查找并进行绑定。<strong>即使在模板实例化时存在着更好的匹配，此绑定也会保持不变</strong>。对于此类名字的绑定过程，候选函数将以在模板定义之前出现的函数为主，若未找到可以绑定的函数，则终止编译。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"g(double)\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
 
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">struct</span> S <span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token function">g</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "g" is a non-dependent name, bound now.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"g(int)\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">g</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// calls g(int).</span>

  S<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> s<span class="token punctuation">;</span>
  s<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// calls g(double).</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果 non-dependent 名字的含义<strong>在模板定义上下文和模板实例化之间更改</strong>，则程序是 <strong>ill-formed</strong> 的。比如：“在模板定义时，在一个 non-dependent 名字的定义中使用了不完全类型，而模板实例化时却成为了完全类型”等（示例如下）。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">int</span> b<span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"int"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"long"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>  <span class="token comment" spellcheck="true">// make g() as a dependent-name (correct);</span>
<span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  f<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">,</span> T<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// T() will be treated as a function type, so use T{} instead.</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token operator">></span>  <span class="token comment" spellcheck="true">// dependent or not?</span>
<span class="token keyword">void</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  f<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">,</span> b<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  g<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "int";</span>
  h<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Clang - "long", GCC - "int" (ill-formed);</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于 dependent 名字的绑定过程则会被推迟到“查找”阶段进行。</p>
<h3 id="查找规则"><a href="#查找规则" class="headerlink" title="查找规则"></a>查找规则</h3><ul>
<li>对于具有外部链接（External Linkage）的函数定义，Non-ADL 查找<strong>仅会查找模板的定义上下文</strong>；</li>
<li>对于具有外部链接的函数定义，ADL 查找会查找<strong>模板的定义上下文</strong>，以及<strong>模板的实例化上下文</strong>；</li>
</ul>
<p>这两个规则用于保证模板的实例化不会违背其 <strong>ODR（One Definition Rule）</strong>原则。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// an external library.</span>
<span class="token keyword">namespace</span> E <span class="token punctuation">{</span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
  <span class="token keyword">void</span> <span class="token function">writeObject</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Value = "</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token comment" spellcheck="true">// translation unit 1:</span>
<span class="token comment" spellcheck="true">// Programmer 1 wants to allow E::writeObject to work with vector&lt;int>.</span>
<span class="token keyword">namespace</span> P1 <span class="token punctuation">{</span>
  std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> os<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token operator">:</span> v<span class="token punctuation">)</span> os <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span> <span class="token keyword">return</span> os<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">;</span>
    E<span class="token operator">::</span><span class="token function">writeObject</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: will not find P1::operator&lt;&lt;.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token comment" spellcheck="true">// translation unit 2:</span>
<span class="token comment" spellcheck="true">// Programmer 2 wants to allow E::writeObject to work with vector&lt;int>.</span>
<span class="token keyword">namespace</span> P2 <span class="token punctuation">{</span>
  std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> os<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token operator">:</span> v<span class="token punctuation">)</span> os <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span><span class="token string">':'</span><span class="token punctuation">;</span> <span class="token keyword">return</span> os <span class="token operator">&lt;&lt;</span> <span class="token string">"[]"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">doSomethingElse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">;</span>
    E<span class="token operator">::</span><span class="token function">writeObject</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error: will not find P2::operator&lt;&lt;.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上面的示例中，如果对于 operator&lt;&lt; 的 non-ADL 查找允许在模板的实例化上下文中进行，则对于 <code>E::writeObject&lt;vector&lt;int&gt;&gt;</code> 的实例化这导致该模板具有两个不同的定义。一个使用了 “P1::operator&lt;&lt;”，另一个使用了 “P2::operator&lt;&lt;”。链接器可能无法识别类似的 ODR 违规，导致在两个实例化中可能都会使用其中的某一个定义。</p>
<p>为了能够使 ADL 查找来检查用户定义的命名空间，应<strong>将 std::vector 替换为用户定义的类，或者将其元素类型替换为用户自定义的类</strong>：</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> P1 <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// if C is a class defined in the P1 namespace.</span>
  std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> os<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>C<span class="token operator">></span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>C n<span class="token operator">:</span> v<span class="token punctuation">)</span> os <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">;</span> <span class="token keyword">return</span> os<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>C<span class="token operator">></span> v<span class="token punctuation">;</span>
  E<span class="token operator">::</span><span class="token function">writeObject</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// OK: instantiates writeObject(std::vector&lt;P1::C>)</span>
                     <span class="token comment" spellcheck="true">//     which finds P1::operator&lt;&lt; via ADL.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意：此规则使得无法对标准库类型进行运算符重载（因为按照 ADL 规则，需要将重载运算符定义在 std 命名空间内。如下代码所示）；</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iterator></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;utility></span></span>
 
<span class="token comment" spellcheck="true">// Bad idea: operator in global namespace, but its arguments are in std::.</span>
std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>std<span class="token operator">::</span>ostream<span class="token operator">&amp;</span> os<span class="token punctuation">,</span> std<span class="token operator">::</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> os <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">','</span> <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span>second<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">typedef</span> std<span class="token operator">::</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">></span> elem_t<span class="token punctuation">;</span>
  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>elem_t<span class="token operator">></span> <span class="token function">v</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// OK, ordinary lookup finds ::operator&lt;&lt;</span>
  std<span class="token operator">::</span><span class="token function">copy</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span>ostream_iterator<span class="token operator">&lt;</span>elem_t<span class="token operator">></span><span class="token punctuation">(</span>std<span class="token operator">::</span>cout<span class="token punctuation">,</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token comment" spellcheck="true">// Error: both ordinary - </span>
  <span class="token comment" spellcheck="true">// lookup from the point of definition of std::ostream_iterator and ADL will -</span>
  <span class="token comment" spellcheck="true">// only consider the std namespace, and will find many overloads of -</span>
  <span class="token comment" spellcheck="true">// std::operator&lt;&lt;, so the lookup will be done. Overload resolution will then -</span>
  <span class="token comment" spellcheck="true">// fail to find operator&lt;&lt; for elem_t in the set found by the lookup.</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="ADL"><a href="#ADL" class="headerlink" title="ADL"></a>ADL</h3><ul>
<li>对于以 Primitive Type 作为参数的函数调用，只能遵循 non-ADL 查找规则；</li>
</ul>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Test\n"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// There is no operator&lt;&lt; in global namespace, but ADL -</span>
                          <span class="token comment" spellcheck="true">// examines std namespace because the left argument is in -</span>
                          <span class="token comment" spellcheck="true">// std and finds std::operator&lt;&lt;(std::ostream&amp;, const char*).</span>
  <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>std<span class="token operator">::</span>cout<span class="token punctuation">,</span> <span class="token string">"Test\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// same, using function call notation, -</span>

  <span class="token comment" spellcheck="true">// however,</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Error: 'endl' is not declared in this namespace.</span>
                      <span class="token comment" spellcheck="true">// This is not a function call to endl(), so ADL does not apply.</span>

  <span class="token function">endl</span><span class="token punctuation">(</span>std<span class="token operator">::</span>cout<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// OK: this is a function call: ADL examines std namespace</span>
                    <span class="token comment" spellcheck="true">// because the argument of endl is in std, and finds std::endl.</span>

  <span class="token punctuation">(</span>endl<span class="token punctuation">)</span><span class="token punctuation">(</span>std<span class="token operator">::</span>cout<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Error: 'endl' is not declared in this namespace.</span>
                       <span class="token comment" spellcheck="true">// The sub-expression (endl) is not a function call expression.</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>一些例子</strong>：</p>
<ul>
<li><strong>using-directive 会在当前 scope 引入名字</strong>。在当前 scope 内查找时，如果找到名字，则不会在往外层 scope 继续查找；因此 <code>foo(N1::S&#123;&#125;);</code> 只会调用 <code>N2::foo</code>，而非 <code>::foo</code>。</li>
</ul>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> N1 <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> S <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">namespace</span> N2 <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// as a fallback to unqualified name which has no user-defined overload.</span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"called N2::foo, generic one."</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>N1<span class="token operator">::</span>S s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"called foo."</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">using</span> N2<span class="token operator">::</span>foo<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// N2::foo is introduced into the main function, lookup stops here.</span>
  <span class="token function">foo</span><span class="token punctuation">(</span>N1<span class="token operator">::</span>S<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// use generic version.</span>
  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// use generic version.</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>查找时同时找到 ADL 引入的 <code>N1::foo</code>，以及由 using-directive 引入的 <code>N2::foo</code>。但前者优先级更高。</li>
</ul>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> N1 <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> S <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>S s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"called N1::foo, specific one."</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">namespace</span> N2 <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// as a fallback to unqualified name which has no user-defined overload.</span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"called N2::foo, generic one."</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>N1<span class="token operator">::</span>S s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"called foo."</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">using</span> N2<span class="token operator">::</span>foo<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// N2::foo is introduced into the main function, lookup stops here.</span>
  <span class="token function">foo</span><span class="token punctuation">(</span>N1<span class="token operator">::</span>S<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// use specific version.</span>
  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// use generic version.</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><code>foo(N1::S&#123;&#125;);</code> 调用了由 using-directive 引入的特化版本 <code>template&lt;&gt; N2::foo</code>。</li>
</ul>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> N1 <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> S <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">namespace</span> N2 <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// as a fallback to unqualified name which has no user-defined overload.</span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"called N2::foo, generic one."</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span>
  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>N1<span class="token operator">::</span>S s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"called N2::foo, specialization one."</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>N1<span class="token operator">::</span>S s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"called foo."</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">using</span> N2<span class="token operator">::</span>foo<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// N2::foo is introduced into the main function, lookup stops here.</span>
  <span class="token function">foo</span><span class="token punctuation">(</span>N1<span class="token operator">::</span>S<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// use specific version.</span>
  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// use generic version.</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>External Linkage Lookup 只能走 ADL 的方式；</li>
<li>不建议为标准库中的类型（如 <code>std::vector&lt;int&gt;</code> 等）进行自定义的运算符重载（一般不建议污染 std 命名空间）。<strong>最好写在自定义类型中，然后走 ADL；using-directive 引入的泛型版本作为 backup</strong>。</li>
</ul>
<br><div class="article-bottom-meta"><span class="post-meta">Last built on<time itemprop="dateModified" datetime="2020-08-18T10:13:58.000Z"> 2023 / 10 / 26, 11:37:10</time></span></div></div></article><br><span class="next-post"><a href="/2020/08/21/Threaded-Code/" itemprop="url">下一篇 ⇒</a></span><span class="prev-post"><a href="/2020/08/18/Wasm3-架构剖析/" itemprop="url">⇐ 上一篇</a></span><br><section id="comments"><div><script src="https://utteranc.es/client.js" repo="Becavalier/utterances-comments" issue-term="title" label="[Comment]" theme="github-light" crossorigin="anonymous" async></script></div></section><br><br></main><script src="/scripts/index.js" type="text/javascript"></script></body></html>