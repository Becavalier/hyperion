<!DOCTYPE html><html lang="en-us"><head><meta name="baidu-site-verification" content="codeva-P9jyH0b1lv"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>《x86/x64 体系探索及编程》读书笔记 | 曜彤.手记</title><meta name="description" content="一本在 Intel 手册的基础之上讨论 x86/x64 处理器组成及相关编程方式的书。"><meta name="generator" content="曜彤.手记"><meta name="about" content="[object Object]"><meta name="keywords" content="博客, C++, C, Rust, Web, Java, IT, 编程, 开发, Android, Python, MySQL, 科技, 黑客, 技术, Javascript, 云, 大数据, 计算, 机器学习, AI, 人工智能, 创业, 产品, 公司, WebAssembly, Wasm"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.jpg"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.jpg"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.jpg"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.jpg"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.jpg"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.jpg"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.jpg"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.jpg"><link rel="apple-touch-icon" sizes="196x196" href="/images/apple-touch-icon-196x196.jpg"><link rel="apple-touch-icon" sizes="310x310" href="/images/apple-touch-icon-310x310.jpg"><link href="/images/splash/iphone5_splash.png" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphone6_splash.png" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphoneplus_splash.png" media="(device-width: 621px) and (device-height: 1104px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/iphonex_splash.png" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/iphonexr_splash.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphonexsmax_splash.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/ipad_splash.png" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro1_splash.png" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro3_splash.png" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro2_splash.png" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="128x128" href="/images/favicon-128.png"><link rel="icon" type="image/png" sizes="196x196" href="/images/favicon-196x196.png"><meta name="msapplication-TileColor" content="#FFFFFF"><meta name="msapplication-TileImage" content="mstile-144x144.png"><meta name="msapplication-square70x70logo" content="mstile-70x70.png"><meta name="msapplication-square150x150logo" content="mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="mstile-310x150.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"><link rel="manifest" href="/manifest.webmanifest"><link rel="alternate" type="application/atom+xml" title="Atom 0.3" href="/atom.xml"><link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body itemscope itemtype="https://schema.org/WebPage"><div class="canvas-containter"><span>X</span></div><header itemscope itemtype="https://schema.org/WPHeader"><div class="logo"></div><h1 class="title"><a href="/" alt="曜彤.手记" title="曜彤.手记" itemprop="headline">曜彤.手记</a><a title="Atom 0.3" target="__blank" href="/atom.xml" class="rss"><img src="/images/rss.png"></a></h1><p itemprop="description" class="description">随记，关于互联网技术、产品与创业</p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name" class="menu-item"><a href="/ " alt="首页" title="首页" itemprop="url">首页</a></li><li itemprop="name" class="menu-item"><a href="/articles" alt="文章" title="文章" itemprop="url">文章</a></li><li itemprop="name" class="menu-item"><a href="/readings" alt="阅读" title="阅读" itemprop="url">阅读</a></li><li itemprop="name" class="menu-item"><a href="/cards" alt="快记" title="快记" itemprop="url">快记</a></li><li itemprop="name" class="menu-item"><a href="/tags" alt="标签" title="标签" itemprop="url">标签</a></li><li itemprop="name" class="menu-item"><a href="/about" alt="关于" title="关于" itemprop="url">关于</a></li></ul></nav><div class="dynamic-slot"></div><div class="toc-body"><div class="bookmark"></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B0%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">第一章 - 数与数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-x86-x64-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-text">第二章 - x86&#x2F;x64 编程基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%BC%96%E5%86%99%E6%9C%AC%E4%B9%A6%E7%9A%84%E5%AE%9E%E9%AA%8C%E4%BE%8B%E5%AD%90"><span class="toc-text">第三章 - 编写本书的实验例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E8%BA%AB%E4%BB%BD"><span class="toc-text">第四章 - 处理器的身份</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BA%86%E8%A7%A3-Flags"><span class="toc-text">第五章 - 了解 Flags</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">第六章 - 处理器的控制寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-MSR"><span class="toc-text">第七章 - MSR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AE%9E%E5%9C%B0%E5%9D%80%E6%A8%A1%E5%BC%8F"><span class="toc-text">第八章 - 实地址模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-SMM-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F%E6%8E%A2%E7%B4%A2"><span class="toc-text">第九章 - SMM 系统管理模式探索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-x86-x64-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%BD%93%E7%B3%BB%EF%BC%88%E4%B8%8A%EF%BC%89"><span class="toc-text">第十章 - x86&#x2F;x64 保护模式体系（上）</span></a></li></ol></div><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><script src="https://shadow.elemecdn.com/npm/zoomage.js@latest/dist/zoomage.min.js" type="text/javascript"></script><script src="https://shadow.elemecdn.com/npm/axios@0.18.0/dist/axios.min.js" type="text/javascript"></script><script src="/scripts/post.js" type="text/javascript"></script><div class="touch-top"><span></span></div><article post-id="《x86/x64 体系探索及编程》读书笔记" class="full article-post"><h1 itemprop="headline" class="align-center">《x86/x64 体系探索及编程》读书笔记</h1><div class="content"><div class="article-meta"><span class="post-meta"><br>Created on<time itemprop="dateCreated" datetime="2020-11-11T00:19:13.000Z"> 2020 / 11 / 11, 08:19:13</time></span><span class="page-tag-anchor"><a href="/tags/汇编" itemprop="url">#汇编</a>&nbsp;&nbsp;<a href="/tags/x86" itemprop="url">#x86</a>&nbsp;&nbsp;<a href="/tags/x64" itemprop="url">#x64</a>&nbsp;&nbsp;</span></div><p>一本在 Intel 手册的基础之上讨论 x86/x64 处理器组成及相关编程方式的书。</p>
<h3 id="第一章-数与数据结构"><a href="#第一章-数与数据结构" class="headerlink" title="第一章 - 数与数据结构"></a>第一章 - 数与数据结构</h3><ol>
<li><span class="pn">Page 4</span>x86/x64 体系使用的是“<strong>小端序</strong>”，即：MSB 对应存储器地址的高位，LSB 对应存储器地址的低位。而在诸如 PowerPC 等 RISC 体系下的某些架构，则可能使用“大端序”。</li>
</ol>
<pre class="line-numbers language-nasm"><code class="language-nasm"><span class="token comment" spellcheck="true">; MacOS Version.</span>
<span class="token keyword">global _main</span>
<span class="token keyword">section .data</span>
<span class="token label function">msg:</span> db <span class="token string">"It's little-endian based!"</span>, <span class="token number">10</span>
<span class="token label function">foo:</span> dd <span class="token number">0</span>

<span class="token keyword">section .text</span>
<span class="token label function">exit:</span>
  mov <span class="token register variable">rax</span>, <span class="token number">0x02000001</span>
  xor <span class="token register variable">rdi</span>, <span class="token register variable">rdi</span>
  syscall
<span class="token label function">_main:</span>  <span class="token comment" spellcheck="true">; entry here.</span>
  mov dword<span class="token operator">[</span>rel foo<span class="token operator">]</span>, <span class="token number">1</span>
  test byte<span class="token operator">[</span>rel foo<span class="token operator">]</span>, <span class="token number">1</span>  <span class="token comment" spellcheck="true">; if the LSB is saved in a lower address?</span>
  jnz .succeed
  call exit
<span class="token label function">.succeed:</span>
  mov <span class="token register variable">rax</span>, <span class="token number">0x02000004</span>
  mov <span class="token register variable">rdi</span>, <span class="token number">1</span>
  mov <span class="token register variable">rsi</span>, msg
  mov <span class="token register variable">rdx</span>, <span class="token number">26</span>
  syscall
  call exit
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="2">
<li><span class="pn">Page 6</span>在 x86/x64 体系中，指令处理数据分为“基础（fundamental）”和“数值（numeric）”两大类。前者包括：byte（8 位）\ word（16 位）\ doubleword（32 位）\ quadword（64 位），它们代表<strong>指令能一次性处理的数据宽度</strong>。后者主要使用在<strong>运算类指令</strong>上，包括：</li>
</ol>
<ul>
<li><em><strong>整数</strong></em>：包括 unsigned 与 signed 类型；</li>
<li><em><strong>浮点数</strong></em>：包括单精度浮点（1/8/23）、双精度浮点（1/11/52）与扩展双精度浮点（1/15/64）；</li>
<li><em><strong>BCD</strong></em>（binary-code decmial integer）：包括 non-packed BCD 码与 packed BCD 码；</li>
<li><em><strong>SIMD</strong></em>：单指令多数据流；</li>
</ul>
<ol start="3">
<li><p><span class="pn">Page 7</span>不存在 unsigned 浮点数（IEEE-754 有小数位）。</p>
</li>
<li><p><span class="pn">Page 7</span><strong>在 x86 中，对整数的加减法运算（乘除会在具体指令上进行区分）不会识别 signed 与 unsigned 的区别</strong>。而是会同时根据两种情况下的运算结果来修改 eflags 的标志位（比如 OF 与 SF），具体如何解释则由上层程序负责。而 RISC 体系普遍会在<strong>指令层上进行假定运算</strong>（如 add 与 addu，一个针对 signed，另一个针对 unsigned），部分 x86 体系下的指令也做了区分（如 div 与 idiv）。</p>
</li>
<li><p><span class="pn">Page 9</span>在单精度与双精度浮点数中，“尾数”部分有一个<strong>隐式</strong>的整数位，该位的值为固定的 “1”。在扩展双精度浮点数中，“尾数”有 64 位，“指数”有 15 位；且其中<strong>整数位是显式的</strong>，在 “normal（规格化）” 数中，这个位必须为 1。<strong>在规格化浮点数中，浮点数的尾数不应当包含前导 0</strong>。如果全部用十进制表示，对于类似 “0.0123” 的浮点数，规格化的表示应为 “1.23e-2”。但对于某些过小的数，如 “1.23e-130”，允许的阶数位数不能满足阶数大小的需要（下溢出），这时可能就会在尾数前添加前导 0，如将其表示为 “0.000123e-126”。</p>
</li>
<li><p><span class="pn">Page 10</span>“<strong>移码</strong>（biased notation）”用来<strong>解决浮点数使用 integer 方法进行比较时出现的问题，通过使用 unsigned 值来简化指数的比较过程</strong>。</p>
</li>
</ol>
<ul>
<li><em>Biasing is done because exponents have to be signed values in order to be able to represent both tiny and huge values, <strong>but two’s complement, the usual representation for signed values, would make comparison harder</strong>.</em></li>
</ul>
<ol start="7">
<li><span class="pn">Page 11</span>在 NASM 中使用浮点数字面量值，分别对应不同的编码方式（__float32__ / __float64__ / __float80e__）：</li>
</ol>
<pre class="line-numbers language-nasm"><code class="language-nasm"><span class="token keyword">global _main</span>
<span class="token keyword">section .text</span>
<span class="token label function">exit:</span>
  mov <span class="token register variable">rax</span>, <span class="token number">0x02000001</span>
  xor <span class="token register variable">rdi</span>, <span class="token register variable">rdi</span>
  syscall
<span class="token label function">_main:</span>  <span class="token comment" spellcheck="true">; entry here.</span>
  mov <span class="token register variable">rax</span>, __float32__(<span class="token number">0.5</span>)
  call exit
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="8">
<li><span class="pn">Page 11</span>IEEE-754 其他实数编码格式：</li>
</ol>
<p><img src="1.png"></p>
<ul>
<li>denormal 数是一个<strong>极小的数，接近于 0</strong>。其指数部分为 0，尾数部分不为 0；</li>
<li>如果一个数超出 infinite，那就是一个 NaN 数。其分为两类：<strong>SNaN</strong>（Signaling NaN）与 <strong>QNaN</strong>（Quiet NaN）。<strong>前者表示一种比较严重的错误值，一般 FPU 会发出对应的异常信号；后者则通常可以接受</strong>（可能针对不同的异常）；</li>
<li>不再上述表格中的编码值均为 “<strong>unsupported 编码值</strong>”。</li>
</ul>
<ol start="9">
<li><span class="pn">Page 17</span>IEEE-754 的四种<strong>舍入模式</strong>（用于在编码类型转换时舍入尾数部分）：</li>
</ol>
<ul>
<li><em><strong>round to nearest</strong></em>：四舍五入，且<strong>当有两个最接近的可表示的值时首选“偶数”值</strong>；</li>
<li><em><strong>round down</strong></em>：向<strong>负无穷大</strong>（向下）舍入；</li>
<li><em><strong>round up</strong></em>：向<strong>正无穷大</strong>（向上）舍入；</li>
<li><em><strong>round zero</strong></em>：向 <strong>0</strong>（截断）舍入。</li>
</ul>
<ol start="10">
<li><span class="pn">Page 17</span>FPU（Float Point Unit）：<strong>浮点运算单元</strong>。在大多数现代通用计算机架构中，<strong>一个或多个浮点运算单元会被集成在 CPU 中</strong>。浮点数的计算也会采用独立的寄存器，比如 XMM 寄存器。</li>
<li><span class="pn">Page 17</span><strong>浮点数中的溢出</strong>分为两种：</li>
</ol>
<ul>
<li><strong>向上溢出</strong>：结果值超出了目标格式的最大 normal 值（即 finite 范围外）；</li>
<li><strong>向下溢出</strong>：结果值超出了目标格式的最小 normal 值（即 tiny 值或 denornal 值）；</li>
</ul>
<p><img src="2.png"></p>
<ol start="12">
<li><span class="pn">Page 20</span>在 BCD（Binary Coded Decimal）码中，<strong>一个十进制数的每一位，使用 8 位的二进制进行编码</strong>，如 15 的 BCD 编码为 “15H”。而在 “packed BCD” 中，每个 BCD 数字使用 4 位来表示。<strong>x86</strong> 下可以使用 <code>aaa</code> 指令来将累加器（AX）中的值转换为非压缩的 BCD 码。</li>
</ol>
<h3 id="第二章-x86-x64-编程基础"><a href="#第二章-x86-x64-编程基础" class="headerlink" title="第二章 - x86/x64 编程基础"></a>第二章 - x86/x64 编程基础</h3><ol start="13">
<li><span class="pn">Page 24</span>C 语言不能直接转换为机器语言，要先由 C 编译器编译出汇编代码，然后再由汇编器生成机器指令，最终再由链接器将这些变量的地址定下来（符号重定位）。</li>
</ol>
<p><img src="3.png"></p>
<ol start="14">
<li><span class="pn">Page 24</span><strong>x86 机器是 CISC 体系，指令的长度不是固定的</strong>。其中最短的指令 1 字节，最长的指令 15 字节。</li>
<li><span class="pn">Page 26</span>C 语言中的 __stdcall 与 __cdecl 调用规范会使用栈来传递参数，而使用寄存器来传递参数能获得更高的效率。</li>
<li><span class="pn">Page 27</span>“段内调用”（<strong>Near Call</strong>，即对 cs 寄存器当前指向的段中过程的调用）的几种形式：</li>
</ol>
<ul>
<li><em>call puts</em>：目标地址距 IP 偏移量；</li>
<li><em>call ax</em>：寄存器操作数；</li>
<li><i>call word[puts_pointer]</i>：内存操作数。</li>
</ul>
<ol start="17">
<li><span class="pn">Page 30</span><strong>Canonical 地址</strong>：即 x64 体系下的高 16 位作为符号扩展位，仅使用低 48 位寻址的地址形式。</li>
<li><span class="pn">Page 32</span>x64 寻址模式：</li>
</ol>
<p><img src="4.png"></p>
<ul>
<li>基址和变址可以是通用寄存器，displacement 的值是 8/32 位；</li>
<li><i>[rip + disp32]</i>：x64 新增的 RIP-Relative 寻址模式，地址值依赖于当前 RIP 的值。该模式易于构造 PIC 代码结构。<ul>
<li>如 <code>mov rax, [rel table]</code>。</li>
</ul>
</li>
</ul>
<ol start="19">
<li><span class="pn">Page 35</span>x86 编程可用的寄存器：</li>
</ol>
<ul>
<li><em>通用寄存器</em>；</li>
<li><em>标志寄存器</em>：eflags、rflags；</li>
<li><em>段寄存器</em>：<strong>64 位模式下，除 gs、fs 外，其他段的 base 值强制为 0 值</strong>。<ul>
<li>cs：指向当前进程的代码段；</li>
<li>ds：指向当前进程的数据段；</li>
<li>ss：指向当前进程的堆栈段；</li>
<li>es、gs、fs；</li>
</ul>
</li>
<li><em>系统段寄存器</em>：<ul>
<li>gdtr：全局描述符表寄存器；</li>
<li>ldtr：局部描述符表寄存器；</li>
<li>idtr：中断描述符表寄存器；</li>
<li>tr：任务寄存器。</li>
</ul>
</li>
<li><em>控制寄存器</em>；</li>
<li><em>调试寄存器</em>；</li>
<li><em>mmx 与 xmm</em>（SSE 指令）；</li>
<li><em>ymm</em>（AVX 指令）；</li>
<li><em>MSR</em>（用于配置管理）。</li>
</ul>
<ol start="20">
<li><span class="pn">Page 37</span>内存地址形式：</li>
</ol>
<ul>
<li>逻辑地址（Logical Address）：程序代码中使用的地址，包含两部分 segment + offset；</li>
<li>有效地址（Effective Address）：即逻辑地址中的 offset 部分，为段内的有效地址偏移量；</li>
<li>线性地址（Linear Address）：由逻辑地址转换而来（段基址 + 段内偏移）。<strong>在 x64 下，段寄存器 cs、ds、ss、es 的段基址均为 0，线性地址等于段内偏移</strong>；</li>
<li>物理地址（Physical Address）：真实的内存或 IO 地址。x64 体系支持 64K IO 地址空间。</li>
</ul>
<ol start="21">
<li><span class="pn">Page 41</span>Load-and-store 操作：非原子性，会连续执行多个操作，在多处理器系统里需要加上 lock 前缀以保证执行的原子性。如：<code>lock add dword [mem], eax</code>。</li>
</ol>
<h3 id="第三章-编写本书的实验例子"><a href="#第三章-编写本书的实验例子" class="headerlink" title="第三章 - 编写本书的实验例子"></a>第三章 - 编写本书的实验例子</h3><ol start="22">
<li><span class="pn">Page 51</span><strong>MBR（主引导记录）</strong>：计算机开机后访问硬盘时所必须要读取的首个扇区。系统启动顺序：</li>
</ol>
<ul>
<li>BIOS 加电自检（Power On Self Test - POST）。BIOS 执行内存地址为 FFFF:0000H 处的跳转指令，跳转到固化在 ROM 中的自检程序处，对系统硬件（包括内存）进行检查；</li>
<li>读取主引导记录（MBR）。当 BIOS 检查到硬件正常并与 CMOS 中的设置相符后，按照 CMOS 中对启动设备的设置顺序检测可用的启动设备。BIOS 将相应启动设备的第一个扇区（也就是 MBR 扇区）读入内存地址为 <strong>0000:7C00H</strong> 处；</li>
<li>检查 0000:01FEH-0000:01FFH（MBR 的结束标志位）是否等于 55AAH，若不等于则转去尝试其他启动设备，如果没有启动设备满足要求则显示 “NO ROM BASIC” 然后死机；</li>
<li>当检测到有启动设备满足要求后，BIOS 将控制权交给相应启动设备。启动设备的 MBR 将自己复制到 0000:0600H 处，然后继续执行；</li>
<li>根据 MBR 中的引导代码启动引导程序。</li>
</ul>
<h3 id="第四章-处理器的身份"><a href="#第四章-处理器的身份" class="headerlink" title="第四章 - 处理器的身份"></a>第四章 - 处理器的身份</h3><ol start="23">
<li><span class="pn">Page 68</span><em>cpuid</em> 指令可以获得 CPU 的支持特性信息，关于 leaf 与 sub-leaf 的细节参考 Intel Manual。</li>
</ol>
<h3 id="第五章-了解-Flags"><a href="#第五章-了解-Flags" class="headerlink" title="第五章 - 了解 Flags"></a>第五章 - 了解 Flags</h3><ol start="24">
<li><span class="pn">Page 86</span>标志位：</li>
</ol>
<ul>
<li><strong>状态标志位（Status Flags）</strong>：</li>
</ul>
<div class="table-container"><table>
<thead>
<tr>
<th>标志位</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CF（Carry）</td>
<td>0</td>
<td>用于 unsigned 数运算，发生进位/借位时置位。</td>
</tr>
<tr>
<td>PF（Parity）</td>
<td>2</td>
<td>判断结果值的最低字节中 1 的个数为偶数（1），否则（0）。</td>
</tr>
<tr>
<td>AF（Auxiliary Carry）</td>
<td>4</td>
<td>用于支持 BCD 码的运算。当运算时 bit 3 发生向上进位或借位时，该位置位。</td>
</tr>
<tr>
<td>ZF（Zero）</td>
<td>6</td>
<td>结果值是否为 0。</td>
</tr>
<tr>
<td>SF（Sign）</td>
<td>7</td>
<td>结果值为 MSB 位的值。</td>
</tr>
<tr>
<td>OF（Overflow）</td>
<td>11</td>
<td>用于 signed 数运算，结果值产生溢出时置位。</td>
</tr>
</tbody></table></div>
<ul>
<li><strong>系统标志位（System Flags）</strong>：</li>
</ul>
<div class="table-container"><table>
<thead>
<tr>
<th>标志位</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>IOPL（I/O Privilege Level）</td>
<td>12, 13</td>
<td>指示访问 I/O 地址空间需要的权限等级，该值在 CPL（Current Privilege Level）为 0 时可修改。<ul><li><b>CPL &lt;= IOPL</b>：可直接访问 I/O 地址空间；</li><li><b>CPL &gt; IOPL</b>：查看程序 TSS（Task State Segment）段中 I/O Permission Bitmap 对应位的值，若为 0 则可访问；否则 #GP 异常。</li></ul></td>
</tr>
<tr>
<td>NT（Nested Task）</td>
<td>14</td>
<td>1 - 表示当前任务被嵌套在另一个任务里；0 - 当前任务没有被嵌套。该标志在 64 位下无效。</td>
</tr>
<tr>
<td>RF（Resume）</td>
<td>16</td>
<td>1 - 禁用指令调试中断异常；0 - 允许产生调试中断异常。在返回并成功执行断点指令后，CPU 会自动清零该位。</td>
</tr>
<tr>
<td>VM（Virtual 8086 Mode）</td>
<td>17</td>
<td>设置进入和离开 Virtual 8086 模式。该标志在 64 位下无效。</td>
</tr>
<tr>
<td>AC（Alignment Check）</td>
<td>18</td>
<td>设置地址中的对齐检查。完整开启条件：<ul><li>CR0.AM 置位；</li><li>eflags.AC 置位；</li><li>CPL=3 / 保护模式下。</li></ul></td>
</tr>
</tbody></table></div>
<ul>
<li><strong>控制标志位（Control Flags）</strong>：</li>
</ul>
<div class="table-container"><table>
<thead>
<tr>
<th>标志位</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>TF（Trap）</td>
<td>8</td>
<td>置位后开启单步调试模式（属于 #DB 异常）。</td>
</tr>
<tr>
<td>IF（Interrupt Enable）</td>
<td>9</td>
<td>控制 CPU 是否响应硬件可屏蔽中断（Maskable Interrupts），该标志位不影响其他类型中断。</td>
</tr>
</tbody></table></div>
<ol start="25">
<li><span class="pn">Page 94</span>eflags.RF 与 eflags.TF 标志配合使用完成单步调试：</li>
</ol>
<p><img src="5.png"></p>
<h3 id="第六章-处理器的控制寄存器"><a href="#第六章-处理器的控制寄存器" class="headerlink" title="第六章 - 处理器的控制寄存器"></a>第六章 - 处理器的控制寄存器</h3><ol start="26">
<li><span class="pn">Page 101</span>x64 上的控制寄存器被扩展为 64 位，有 CR0 ~ CR15 共 16 个，其中仅使用了 CR0、CR2、CR3、CR4，以及 CR8。而为了支持“长模式”，x64 体系引入了 EFER 寄存器。</li>
</ol>
<div class="table-container"><table>
<thead>
<tr>
<th>寄存器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CR8</td>
<td>任务优先级寄存器（Task Priority Register），仅 64 位下有效。其低 4 位作为优先级值，设置 CPU 可以响应的中断级别（0~15）。</td>
</tr>
<tr>
<td>CR2</td>
<td>存放着缺页错误发生时，程序试图访问的地址（PFLA）。</td>
</tr>
<tr>
<td>CR3</td>
<td>指向第 1 级的页表结构。<ul><li>non-PAE 模式：指向 Page-Directory Table 的基地址；</li><li>PAE：指向 Page-Directory-Pointer Table 的基地址；</li><li>Long Mode：指向 Page-Map Level-4 Table 的基地址。</li></ul></td>
</tr>
<tr>
<td>CR0</td>
<td><ul><li>CR0.PE：0 - 实模式；1 - 保护模式；</li><li>CR0.NE：决定 x87 FPU 使用的异常处理模式；</li><li>CR0.TS：发生任务切换时置位；</li><li>CR0.MP：用于监控 wait/fwait 指令的执行；</li><li>CR0.PG：1 - 开启页式管理模式；</li><li>CR0.CD &amp; CR0.NW：控制 CPU 内部的高速缓存策略（Cache Disable &amp; Not Write-through）；</li><li>CR0.WP：1 - 不能修改只读页；</li><li>CR0.AM：控制开启边界对齐检查。</li></ul></td>
</tr>
<tr>
<td>CR4</td>
<td><ul><li>CR4.TSD：1 - rdtsc / rdtscp 指令只能在 CPL=0 时执行；</li><li>CR4.PCE：0 - rdpmc 指令只能在 CPL=0 时执行；</li><li>CR4.MCD：1 - 开启 Machine Check 机制；</li><li>CR4.OSFXSR：1 - 已经为 SSE 执行环境做好准备；</li><li>CR4.VMXE：1 - 开启 VMX 功能；</li><li>CR4.SMXE：1 - 开启 SMX 功能；</li><li>CR4.PAE：1 - 开启扩展的物理地址。</li></ul></td>
</tr>
<tr>
<td>EFER</td>
<td><ul><li>EFER.LME：1 - 启用“长模式”；</li><li>EFER.LMA：1 - CPU 目前处于“长模式”，该位由 CPU 维护。</li></ul></td>
</tr>
</tbody></table></div>
<ol start="27">
<li><span class="pn">Page 102</span>中断向量表（IVT）与系统调用：</li>
</ol>
<p><img src="6.png"></p>
<ul>
<li>IDT 是 x86 下用来实现 IVT 的数据结构。</li>
</ul>
<h3 id="第七章-MSR"><a href="#第七章-MSR" class="headerlink" title="第七章 - MSR"></a>第七章 - MSR</h3><ol start="28">
<li><span class="pn">Page 116</span><strong>MSR</strong>（Model-Specific Register）：特定于模型的寄存器。是 x86 指令集中用于调试、程序执行跟踪、计算机性能监控和切换某些 CPU 功能的各种控制寄存器中的任何一种。</li>
</ol>
<ul>
<li>性能监视计数器；</li>
<li>调试扩展的支持；</li>
<li>机器检查的能力；</li>
<li>实现内存类型与范围定义的寄存器（MTRR）；</li>
<li>功耗与温控管理；</li>
<li>特殊指令的支持；</li>
<li>处理器特色和模型管理的支持，等等。</li>
</ul>
<ol start="29">
<li><span class="pn">Page 125</span>系统调用指令相关的 MSR：</li>
</ol>
<p><img src="7.png"></p>
<p><em>syscall</em>：</p>
<ul>
<li>MSR_LSTAR -&gt; rip，并把下一条程序指令保存在 rcx；</li>
<li>把 rflags 的值保存在 r11，并用 MSR_SFMASK 寄存器的值 mask 该值（屏蔽某些标志位）；</li>
<li>MSR_STAR[47:32] -&gt; cs, ss。</li>
</ul>
<p><em>sysret</em>：</p>
<ul>
<li>rcx -&gt; rip；</li>
<li>r11 -&gt; rflags；</li>
<li>MSR_STAR[63:48] -&gt; cs, ss。</li>
</ul>
<h3 id="第八章-实地址模式"><a href="#第八章-实地址模式" class="headerlink" title="第八章 - 实地址模式"></a>第八章 - 实地址模式</h3><ol start="30">
<li><span class="pn">Page 132</span>实地址模式（Real Mode）：</li>
</ol>
<ul>
<li>没有虚拟地址概念，各个段寄存器中装载的都是<strong>物理地址</strong>；</li>
<li>早期用在 8086、8088 和 80188 处理器时代，286、386 处理器开始工作在保护模式；</li>
<li><strong>处理器启动后第一个进入的工作模式</strong>；</li>
<li>使用“逻辑地址”的编址方式，20 位物理地址（base = segment &lt;&lt; 4），16 位默认指令操作数和地址；</li>
<li>默认运行在 Ring0 层；</li>
<li>段大小为 64K。</li>
</ul>
<h3 id="第九章-SMM-系统管理模式探索"><a href="#第九章-SMM-系统管理模式探索" class="headerlink" title="第九章 - SMM 系统管理模式探索"></a>第九章 - SMM 系统管理模式探索</h3><p>（略）</p>
<h3 id="第十章-x86-x64-保护模式体系（上）"><a href="#第十章-x86-x64-保护模式体系（上）" class="headerlink" title="第十章 - x86/x64 保护模式体系（上）"></a>第十章 - x86/x64 保护模式体系（上）</h3><p>（待更新）</p>
<br><div class="article-bottom-meta"><span class="post-meta">Last built on<time itemprop="dateModified" datetime="2020-11-11T00:19:13.000Z"> 2023 / 10 / 26, 11:37:10</time></span></div></div></article><br><span class="next-post"><a href="/2020/11/13/《CSAPP-第三版》读书笔记（第 1-3 章）/" itemprop="url">下一篇 ⇒</a></span><span class="prev-post"><a href="/2020/11/05/《现代-C-教程：高速上手-C-11-14-17-20》读书笔记/" itemprop="url">⇐ 上一篇</a></span><br><section id="comments"><h4>评论 | Comments</h4><br><div class="comment-container"><div class="loading-mask">Loading ...</div><script src="https://utteranc.es/client.js" repo="Becavalier/utterances-comments" issue-term="title" label="[Comment]" theme="github-light" crossorigin="anonymous" async></script></div></section><br><br></main><script src="/scripts/index.js" type="text/javascript"></script></body></html>