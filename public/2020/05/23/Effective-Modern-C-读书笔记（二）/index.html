<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>《Effective Modern C++》读书笔记（二） | 曜彤.手记</title><meta name="description" content="文接上回，本文为上一文的第二篇。"><meta name="generator" content="曜彤.手记"><meta name="about" content="[object Object]"><meta name="keywords" content="博客, C++, C, Rust, Web, Java, IT, 编程, 开发, Android, Python, MySQL, 科技, 黑客, 技术, Javascript, 云, 大数据, 计算, 机器学习, AI, 人工智能, 创业, 产品, 公司, WebAssembly, Wasm"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.jpg"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.jpg"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.jpg"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.jpg"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.jpg"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.jpg"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.jpg"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.jpg"><link rel="apple-touch-icon" sizes="196x196" href="/images/apple-touch-icon-196x196.jpg"><link rel="apple-touch-icon" sizes="310x310" href="/images/apple-touch-icon-310x310.jpg"><link href="/images/splash/iphone5_splash.png" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphone6_splash.png" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphoneplus_splash.png" media="(device-width: 621px) and (device-height: 1104px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/iphonex_splash.png" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/iphonexr_splash.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphonexsmax_splash.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/ipad_splash.png" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro1_splash.png" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro3_splash.png" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro2_splash.png" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="128x128" href="/images/favicon-128.png"><link rel="icon" type="image/png" sizes="196x196" href="/images/favicon-196x196.png"><meta name="msapplication-TileColor" content="#FFFFFF"><meta name="msapplication-TileImage" content="mstile-144x144.png"><meta name="msapplication-square70x70logo" content="mstile-70x70.png"><meta name="msapplication-square150x150logo" content="mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="mstile-310x150.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"><link rel="manifest" href="/manifest.webmanifest"><link rel="alternate" type="application/atom+xml" title="Atom 0.3" href="/atom.xml"><link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body itemscope itemtype="https://schema.org/WebPage"><div class="canvas-containter"><span>X</span></div><header itemscope itemtype="https://schema.org/WPHeader"><div class="logo"></div><h1 class="title"><a href="/" alt="曜彤.手记" title="曜彤.手记" itemprop="headline">曜彤.手记</a><a title="Atom 0.3" target="__blank" href="/atom.xml" class="rss"><img src="/images/rss.png"></a></h1><p itemprop="description" class="description">随记，关于互联网技术、产品与创业</p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name" class="menu-item"><a href="/ " alt="首页" title="首页" itemprop="url">首页</a></li><li itemprop="name" class="menu-item"><a href="/articles" alt="文章" title="文章" itemprop="url">文章</a></li><li itemprop="name" class="menu-item"><a href="/readings" alt="阅读" title="阅读" itemprop="url">阅读</a></li><li itemprop="name" class="menu-item"><a href="/cards" alt="快记" title="快记" itemprop="url">快记</a></li><li itemprop="name" class="menu-item"><a href="/tags" alt="标签" title="标签" itemprop="url">标签</a></li><li itemprop="name" class="menu-item"><a href="/about" alt="关于" title="关于" itemprop="url">关于</a></li></ul></nav><div class="dynamic-slot"></div><div class="toc-body"><div class="bookmark"></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E3%80%81%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E2%80%9C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E2%80%9D"><span class="toc-text">右值引用、移动语义与“完美转发”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">Lambda 表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91-API"><span class="toc-text">并发 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%82%E9%A1%B9"><span class="toc-text">杂项</span></a></li></ol></div><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><script src="https://shadow.elemecdn.com/npm/zoomage.js@latest/dist/zoomage.min.js" type="text/javascript"></script><script src="https://shadow.elemecdn.com/npm/axios@0.18.0/dist/axios.min.js" type="text/javascript"></script><script src="/scripts/post.js" type="text/javascript"></script><div class="touch-top"><span></span></div><article post-id="《Effective Modern C++》读书笔记（二）" class="full"><h1 itemprop="headline" class="align-center">《Effective Modern C++》读书笔记（二）</h1><div class="content"><div class="article-meta"><span class="post-meta"><br>Created on<time itemprop="dateCreated" datetime="2020-05-23T09:19:08.000Z"> 2020 / 05 / 23, 17:19:08</time></span><span class="page-tag-anchor"><a href="/tags/Cpp" itemprop="url">#Cpp</a>&nbsp;&nbsp;</span></div><p>文接上回，本文为上一文的第二篇。</p>
<h3 id="右值引用、移动语义与“完美转发”"><a href="#右值引用、移动语义与“完美转发”" class="headerlink" title="右值引用、移动语义与“完美转发”"></a>右值引用、移动语义与“完美转发”</h3><ol start="65">
<li><span class="pn">Page 159</span>从函数返回的右值引用和直接返回右值的行为是一样的。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> A <span class="token punctuation">{</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
A<span class="token operator">&amp;&amp;</span> <span class="token function">foo</span><span class="token punctuation">(</span>A<span class="token operator">&amp;</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  A a<span class="token punctuation">;</span>
  <span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> x <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> x<span class="token punctuation">.</span>i <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="66">
<li><span class="pn">Page 161</span>被标记为顶层 const 的对象无法被移动（所以移动函数没有 const），哪怕通过 std::move 变成右值也是如此。</li>
<li><span class="pn">Page 163</span>std::move 与 std::forward <strong>均为编译时行为</strong>。</li>
<li><span class="pn">Page 165</span>“Universal References” 又被称为 “Forwarding-References”，主要有以下两种形式：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 基于模板；</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
  <span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> x <span class="token operator">=</span> v<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 基于 auto，x 为 const int &amp;x（CV 自动推导）；</span>
  <span class="token function">foo</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="69">
<li><span class="pn">Page 166</span><strong>CV 限定符会破坏 Universal Reference 的可推导性</strong>：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// const auto&amp;&amp; r = x;  // r 为常量右值引用，因此左值变量 x 不能赋给 r；</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    
<span class="token punctuation">}</span> 
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="70">
<li><span class="pn">Page 167</span>std::vector&lt;T,Allocator&gt;::push_back(T&amp;&amp; value) 由于其函数参数直接与 T 相关（vector 在实例化时 T 已经确定），因此无法进行类型推导，只能按照左值右值调用不同的重载版本；而对应的 <strong>emplace_back(Args&amp;&amp;… args) 则由于其参数与 T 无关，因此可以进行引用折叠和类型推导</strong>，因为该函数为 in-place 构造，所以需要把参数通过 std::forward 直接传递给容器元素的构造函数（参见本文后面几条规则）。</li>
<li><span class="pn">Page 171</span>相较于分别为左值和右值单独重载对应的函数，<strong>使用 “Universal Reference” 的好处在于可以直接进行构造/赋值，省去了临时值的创建、移动和销毁的过程</strong>。</li>
<li><span class="pn">Page 175</span><strong>不要试图在函数中通过 std::move 返回一个本地临时对象（包括实参生成的）</strong>。因为相较于这样产生的移动操作，借由编译器的 RVO/NRVO 优化（当返回一个本地对象且对象类型与返回值类型完全相同时）可以直接在返回地址处构造对象，进而省去了移动的过程。注意：<strong>仅将 std::move 用在右值引用上；将 std::forward 用在 “Universal Reference” 上</strong>。</li>
<li><span class="pn">Page 176</span>对于一个直接返回临时值对象，且该对象类型与函数返回值类型（传值）相同的函数来说，编译器可以保证在 RVO/NRVO 优化无法进行时，至少<strong>以隐式 std::move 的方式将对象返回</strong>。</li>
<li><span class="pn">Page 183</span>对于一个类，当模板方法和成员方法具有相同的调用优先级时（实际参数完全匹配），编译器更倾向于使用成员函数版本。否则则使用 “Universal Reference” 的模板函数版本。</li>
<li><span class="pn">Page 183</span><strong>不建议使用基于 “Universal Reference” 的模板构造（拷贝、移动）函数，而且也不建议基于该模板函数进行任何同名函数重载匹配</strong>。</li>
<li><span class="pn">Page 187</span>“Tag Dispatch” 方法（让所有参数都走 “Universal Reference” 版本，然后在其内部再通过新加的 “Tag” 参数来区分需要重载的具体实现）：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> A <span class="token punctuation">{</span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 入口函数；</span>
    <span class="token function">fooImpl</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">,</span> 
      <span class="token comment" spellcheck="true">// 第二个参数作为 Tag；</span>
      std<span class="token operator">::</span>integral_constant<span class="token operator">&lt;</span>
        <span class="token keyword">bool</span><span class="token punctuation">,</span> 
        std<span class="token operator">::</span>is_integral<span class="token operator">&lt;</span>std<span class="token operator">::</span>remove_reference_t<span class="token operator">&lt;</span>T<span class="token operator">></span>
      <span class="token operator">></span><span class="token operator">::</span>value<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
  <span class="token keyword">void</span> <span class="token function">fooImpl</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span><span class="token punctuation">,</span> std<span class="token operator">::</span>false_type<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"non-int called."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
  <span class="token keyword">void</span> <span class="token function">fooImpl</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span><span class="token punctuation">,</span> std<span class="token operator">::</span>true_type<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"int called."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  A a<span class="token punctuation">;</span>
  a<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  a<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">1.3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="77">
<li><span class="pn">Page 194</span>使用 std::enable_if 控制模板函数的有效性，以防止由另一个对象创建新对象的过程调用到模板实例化的拷贝构造函数：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> nameFromIdx <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"YHSPY"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token comment" spellcheck="true">// 使用 “Universal Reference” 构造函数的好处在于可以保持初始化参数的左右值状态，在适当情况下调用对应的移动构造函数进行初始化；</span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span>
    <span class="token keyword">typename</span> T<span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">// std::enable_if_t 基于 SFINAE 条件编译其 ::type；</span>
    <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token operator">::</span>enable_if_t<span class="token operator">&lt;</span>
      <span class="token operator">!</span>std<span class="token operator">::</span>is_base_of<span class="token operator">&lt;</span>Person<span class="token punctuation">,</span> std<span class="token operator">::</span>decay_t<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token operator">::</span>value <span class="token operator">&amp;&amp;</span>
      <span class="token operator">!</span>std<span class="token operator">::</span>is_integral<span class="token operator">&lt;</span>std<span class="token operator">::</span>remove_reference_t<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token operator">::</span>value
    <span class="token operator">></span>
  <span class="token operator">></span>
  <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> n<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 编译时检查；</span>
    <span class="token keyword">static_assert</span><span class="token punctuation">(</span>std<span class="token operator">::</span>is_constructible<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> T<span class="token operator">></span><span class="token operator">::</span>value<span class="token punctuation">,</span> 
      <span class="token string">"Parameter n can't be used to construct a std::string"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>nameFromIdx<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  std<span class="token operator">::</span>string name<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Person p1<span class="token punctuation">{</span><span class="token number">1.3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  Person <span class="token function">p2</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="78">
<li><span class="pn">Page 199</span>引用折叠：当两个引用有一个为左值引用时，结果为左值引用；否则为右值引用。</li>
<li><span class="pn">Page 202</span>会发生“引用折叠”的几个地方：模板初始化、auto 推导、using / typedef、decltype。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> T<span class="token operator">&amp;&amp;</span> RvalueRefToT<span class="token punctuation">;</span>
<span class="token keyword">using</span> RvalueRefToT <span class="token operator">=</span> T<span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ol start="80">
<li><span class="pn">Page 209</span>以 “{}” 构造的初始化表达式不能直接传给模板函数进行推导或者完美转发。可以选择用 auto 作为中转作为一种解决方案。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> i <span class="token operator">:</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Arg<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">forwardFunc</span><span class="token punctuation">(</span>Arg<span class="token operator">&amp;&amp;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">foo</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Arg<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">auto</span> p <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token function">forwardFunc</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    
<span class="token punctuation">}</span>  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="81">
<li><span class="pn">Page 209</span>使用 nullptr 代替 NULL 或者 0 来作为完美转发的实际参数，以防止模板推断将其参数推导为整数类型。</li>
<li><span class="pn">Page 210</span><strong>没有被取地址使用的、无定义的类静态常量成员，通常会被编译器通过常量传播直接替换到被使用的地方</strong>。否则若没有定义，则在链接时会报出找不到符号的错误。<strong>所以对于类静态成员，最好均在类外进行定义</strong>。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>arg <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">struct</span> A <span class="token punctuation">{</span> <span class="token keyword">static</span> <span class="token keyword">const</span> std<span class="token operator">::</span>size_t minVal <span class="token operator">=</span> <span class="token number">28</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> std<span class="token operator">::</span>size_t A<span class="token operator">::</span>minVal<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 定义；</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">foo</span><span class="token punctuation">(</span>A<span class="token operator">::</span>minVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="83">
<li><span class="pn">Page 213</span>当传递重载的函数指针或者模板函数给 “Universal Reference” 时，需要指定该函数或模板函数的具体类型。</li>
<li><span class="pn">Page 214</span>只有常量引用才可以指向位域中的成员。</li>
</ol>
<h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><ol start="85">
<li><span class="pn">Page 221</span>lambda 表达式在类对象中以值捕获 “=” 时，<strong>会捕获当前类对象的 this 指针</strong>。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> A <span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// [this]() { std::cout &lt;&lt; v &lt;&lt; std::endl; }();</span>
    <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> v <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  A a<span class="token punctuation">;</span>
  a<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    
<span class="token punctuation">}</span> 
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="86">
<li><span class="pn">Page 223</span>静态生存期：一个对象的生存期和程序的运行的生存期一样长，比如被标记为 static 的变量。而 <strong>lambda 表达式无法捕获具有静态生存期的变量</strong>。</li>
<li><span class="pn">Page 225</span><strong>C++14 Init Capture</strong>，可以方便地移动资源到闭包中：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword">auto</span> up <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">make_unique</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">[</span>x <span class="token operator">=</span> x<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">[</span>x <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">[</span>x <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>up<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>x <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="88">
<li><span class="pn">Page 227</span>在 C++11 中模拟 C++14 的 Init Capture：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>vector vA <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> vB <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// C++14 Init Capture；</span>
  <span class="token keyword">auto</span> fA <span class="token operator">=</span> <span class="token punctuation">[</span>v <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>vA<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> e <span class="token operator">:</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// C++11 将被移动的资源存储在 std::bind 对象中；</span>
  <span class="token keyword">auto</span> fB <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>vector v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> e <span class="token operator">:</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>vB<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="89">
<li><span class="pn">Page 232</span>可以进行完美转发的 lambda 表达式：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// std::forward 的简单实现；</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>                         
T<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span>std<span class="token operator">::</span>remove_reference_t<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
  <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>T<span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-text"><code class="language-text">(param = int& / T = int&) -> decltype(param) = int&
(param = int&& / T = int) -> decltype(param) = int&&
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">auto</span> fA <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> std<span class="token operator">::</span>forward<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="90">
<li><span class="pn">Page 233</span>C++14 定义的一些时间字面常量类型：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>literals<span class="token operator">::</span>chrono_literals<span class="token operator">:</span><span class="token operator">*</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ol start="91">
<li><span class="pn">Page 237</span>std::bind 默认是传值，通过 std::ref() 可以传递引用。当<strong>需要延迟 std::bind 参数的求值过程时，可以用 std::bind 将需要延迟求值的表达式进行包装</strong>：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">auto</span> f <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>
    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> v <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> 
    std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>
      std<span class="token operator">::</span>plus<span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
      <span class="token number">10</span><span class="token punctuation">,</span> 
      std<span class="token operator">::</span>placeholders<span class="token operator">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="92">
<li><span class="pn">Page 239</span>std::bind 常用的两个用途：</li>
</ol>
<ul>
<li>在 C++11 中模拟 C++14 的 Move Capture；</li>
<li>构造多态的函数对象（在 C++14 中可以直接使用 auto&amp;&amp; 的 lambda 来实现）；</li>
</ul>
<ol start="93">
<li><span class="pn">Page 240</span>在 C++14 下，几乎没有场景需要使用 std::bind，如果有用到，则需要思考使用方式是否正确。</li>
</ol>
<h3 id="并发-API"><a href="#并发-API" class="headerlink" title="并发 API"></a>并发 API</h3><p>（暂时用不上，先跳过了）</p>
<h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ol start="94">
<li><span class="pn">Page 292</span>对于可拷贝，并且易于移动的对象。以传值的方式可以获得近似传递引用的效率，并且可以减少目标文件的体积，且易于实现。对于诸如 std::string 以及 std::vector 类型，拷贝构造的花销可能会大于拷贝赋值的花销（前者需要一次动态内存的生成与释放，后者可以复用已经初始化好的内存段）。</li>
<li><span class="pn">Page 294</span>push_back 直接接收一个对象，然后通过移动 / 拷贝构造在容器内构造对象；emplace_back 接收需要构造的参数，然后直接在容器内部 in-place 构造对象，进而省去了临时值的构造以及被移动后的析构过程。</li>
<li><span class="pn">Page 296</span>何时优先使用 emplace：</li>
</ol>
<ul>
<li>当新值可以被构造到容器，而非赋值时；</li>
<li>传递给容器的参数类型与容器的元素类型不同（需要构造的）；</li>
<li>容器不需要对新增元素进行比较（比如需要构造临时对象用于比较是否重复）；</li>
</ul>
<ol start="97">
<li><span class="pn">Page 298</span>不应该将类似 ”new A“ 的表达式作为参数传递给 emplace 函数或者 push_back，甚至是其他函数。</li>
<li><span class="pn">Page 300</span>emplace_back 内部进行的是直接构造初始化；push_back 则是拷贝 / 移动构造初始化；两者区别在于：<strong>对 explicit 构造函数一个是直接调用，另一个则没有调用（拷贝或移动）</strong>。</li>
</ol>
<br><div class="article-bottom-meta"><span class="post-meta">Last built on<time itemprop="dateModified" datetime="2020-05-23T09:19:08.000Z"> 2023 / 10 / 26, 11:37:10</time></span></div></div></article><br><span class="next-post"><a href="/2020/05/24/C-字符串拷贝优化策略：Eager-Copy、SSO-与-COW/" itemprop="url">下一篇 ⇒</a></span><span class="prev-post"><a href="/2020/05/14/Effective-Modern-C-读书笔记（一）/" itemprop="url">⇐ 上一篇</a></span><br><section id="comments"><h4>评论 | Comments</h4><br><script src="https://utteranc.es/client.js" repo="Becavalier/utterances-comments" issue-term="title" label="[Comment]" theme="github-light" crossorigin="anonymous" async></script></section><br><br></main><script src="/scripts/index.js" type="text/javascript"></script></body></html>