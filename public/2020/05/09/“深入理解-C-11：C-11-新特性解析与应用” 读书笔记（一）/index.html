<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>《深入理解 C++11：C++11 新特性解析与应用》读书笔记（一） | 曜彤.手记</title><meta name="baidu-site-verification" content="codeva-P9jyH0b1lv"><meta name="description" content="作为一本之前已经读过两遍的书，终于决定在第三次“复习”的时候做下读书笔记了。鉴于之前已经完整读过《Primer C++ 5th》、《Effective C++ 3th》两本书，因此本文仅作为查缺补漏之用，对于前两本书中没有提到一些诸如“最小垃圾回收”、以及“原子类型与原子操作”等内容进行回顾与记录。整个 C++ 系列还有一本想完整仔细阅读的《Effective Modern C++ - 42 Specific Ways to Improve Your Use of C++11 and C++14》可能会稍微往后放了，由于 C++14 仅作为 C++11 的微小改进和补充，对于一些常用的特性其实已经在实际项目中开始使用了。而对于诸如 std::future 以及 std::promise 等特性，由于其涉及异步和并发相关场景，因此可以参考《C++ Concurrency in Action 2th》一书，暂时没有实际需求便先不打算进行了解。"><meta name="generator" content="曜彤.手记"><meta name="keywords" content="博客, C++, C, Rust, Web, Java, IT, 编程, 开发, Android, Python, MySQL, 科技, 黑客, 技术, Javascript, 云, 大数据, 计算, 机器学习, AI, 人工智能, 创业, 产品, 公司, WebAssembly, Wasm"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.jpg"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.jpg"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.jpg"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.jpg"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.jpg"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.jpg"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.jpg"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.jpg"><link rel="apple-touch-icon" sizes="196x196" href="/images/apple-touch-icon-196x196.jpg"><link rel="apple-touch-icon" sizes="310x310" href="/images/apple-touch-icon-310x310.jpg"><link href="/images/splash/iphone5_splash.png" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphone6_splash.png" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphoneplus_splash.png" media="(device-width: 621px) and (device-height: 1104px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/iphonex_splash.png" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/iphonexr_splash.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphonexsmax_splash.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/ipad_splash.png" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro1_splash.png" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro3_splash.png" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro2_splash.png" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="128x128" href="/images/favicon-128.png"><link rel="icon" type="image/png" sizes="196x196" href="/images/favicon-196x196.png"><meta name="msapplication-TileColor" content="#FFFFFF"><meta name="msapplication-TileImage" content="mstile-144x144.png"><meta name="msapplication-square70x70logo" content="mstile-70x70.png"><meta name="msapplication-square150x150logo" content="mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="mstile-310x150.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"><link rel="manifest" href="/manifest.webmanifest"><link rel="alternate" type="application/atom+xml" title="Atom 0.3" href="/atom.xml"><link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body itemscope itemtype="https://schema.org/WebPage"><div class="canvas-containter"><span>X</span></div><header itemscope itemtype="https://schema.org/WPHeader"><div class="logo"></div><h1 class="title"><a href="/" alt="曜彤.手记" title="曜彤.手记" itemprop="headline">曜彤.手记</a><a title="Atom 0.3" target="__blank" href="/atom.xml" class="rss"><img src="/images/rss.png"></a></h1><p itemprop="description" class="description">随记，关于互联网技术、产品与创业</p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name" class="menu-item"><a href="/ " alt="首页" title="首页" itemprop="url">首页</a></li><li itemprop="name" class="menu-item"><a href="/articles" alt="文章" title="文章" itemprop="url">文章</a></li><li itemprop="name" class="menu-item"><a href="/readings" alt="阅读" title="阅读" itemprop="url">阅读</a></li><li itemprop="name" class="menu-item"><a href="/cards" alt="快记" title="快记" itemprop="url">快记</a></li><li itemprop="name" class="menu-item"><a href="/tags" alt="标签" title="标签" itemprop="url">标签</a></li><li itemprop="name" class="menu-item"><a href="/about" alt="关于" title="关于" itemprop="url">关于</a></li></ul></nav><div class="dynamic-slot"></div><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><script src="https://shadow.elemecdn.com/npm/zoomage.js@latest/dist/zoomage.min.js" type="text/javascript"></script><script src="https://shadow.elemecdn.com/npm/axios@0.18.0/dist/axios.min.js" type="text/javascript"></script><script src="/scripts/post.js" type="text/javascript"></script><div class="touch-top"><span></span></div><article post-id="《深入理解 C++11：C++11 新特性解析与应用》读书笔记（一）" class="full article-post"><h1 itemprop="headline" class="align-center">《深入理解 C++11：C++11 新特性解析与应用》读书笔记（一）</h1><div class="content"><div class="article-meta"><span class="post-meta"><br>Created on<time itemprop="dateCreated" datetime="2020-05-09T02:22:12.000Z"> 2020 / 05 / 09, 10:22:12</time></span><span class="page-tag-anchor"><a href="/tags/Cpp" itemprop="url">#Cpp</a>&nbsp;&nbsp;</span></div><p>作为一本之前已经读过两遍的书，终于决定在第三次“复习”的时候做下读书笔记了。鉴于之前已经完整读过《Primer C++ 5th》、《Effective C++ 3th》两本书，因此本文仅作为查缺补漏之用，对于前两本书中没有提到一些诸如“<strong>最小垃圾回收</strong>”、以及“<strong>原子类型与原子操作</strong>”等内容进行回顾与记录。整个 C++ 系列还有一本想完整仔细阅读的《Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14》可能会稍微往后放了，由于 C++14 仅作为 C++11 的微小改进和补充，对于一些常用的特性其实已经在实际项目中开始使用了。而对于诸如 std::future 以及 std::promise 等特性，由于其涉及异步和并发相关场景，因此可以参考《C++ Concurrency in Action 2th》一书，暂时没有实际需求便先不打算进行了解。</p>
<ol>
<li><span class="pn">Page 20</span>C++98/03 标准：C++03 标准产生于2003年 WG21 提交的 TC1 技术勘误表，对语言核心内容没有改动。因此常被合在一起称为 C++98/03 标准。</li>
<li><span class="pn">Page 21</span>WG21：C++ 语言标准委员会；WG14：C 语言标准委员会。其中 WG21 更<strong>倾向于使用库而不是扩展语言来实现新的 C++ 特性</strong>。</li>
<li><span class="pn">Page 31</span>final 与 override 为标识符，并非关键字，因此可以被当做变量名进行重定义。</li>
<li><span class="pn">Page 33</span>const 与 constexpr 区别：const 不一定保证编译时的常量性，只保证运行时变量无法变更；而 constexpr 则可以保证编译时的常量性。</li>
<li><span class="pn">Page 39</span>一些用于检查机器对 C 标准以及 C 库支持情况的预定义宏，使用前先检查是否被定义（#ifdef）：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> __STDC_HOSTED__ <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 是否包含完整的标准 C 库；</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> __STDC__ <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 实现是否与 C 标准一致；</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> __STDC_VERSION__ <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 支持的 C 标准版本；</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> __STDC_ISO_10646__ <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 表示 C++ 编译环境符合某个版本的 IOS/IEC 10646 标准（通用字符集）版本；</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="6">
<li><span class="pn">Page 40</span>在 C++11 中，宏 <code>__func__</code> 可返回所在函数/类的名字，可用于轻量级的代码调试。实现上编译器会自动隐式地在函数定义之后定义 <strong>func</strong> 标识符。</li>
<li><span class="pn">Page 41</span>在 C++11 中，宏 <code>_Pragma</code> 的用法类似 #pragma，用于向编译器传达语言标准以外的信息。但作为操作符，其可以用于宏定义并进行宏展开。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 示例来源于 OpenMP 应用（一套支持跨平台共享内存方式的多线程并发的编程API）；</span>
<span class="token macro property">#<span class="token directive keyword">define</span> Pragma(x) _Pragma(#x)</span>
<span class="token macro property">#<span class="token directive keyword">define</span> OMP(directive) Pragma(omp directive)</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">omp_set_dynamic</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">omp_set_num_threads</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">OMP</span><span class="token punctuation">(</span>parallel<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 其内部的语句将被多个线程并行执行；</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="8">
<li><span class="pn">Page 42</span>变长参数宏与 std::fprintf：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span>
<span class="token macro property">#<span class="token directive keyword">define</span> LOG(...) { \
  fprintf(stderr, "%s: Line %d:\t", __FILE__, __LINE__); \
  fprintf(stderr, __VA_ARGS__); \
  fprintf(stderr, "\n"); \
}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
  <span class="token function">LOG</span><span class="token punctuation">(</span><span class="token string">"x = %d"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// "x.cpp: Line 12: x = 3"</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="9">
<li><span class="pn">Page 43</span>C++ 标准规定 long long 至少有64位长度。</li>
<li><span class="pn">Page 44</span><strong>强类型的语言遇到函数引数类型和实际调用类型不符合的情况经常会直接出错或者编译失败</strong>；而弱类型的语言常常会实行隐式转换，或者产生难以意料的结果。所以从这方面来看，<strong>C/C++ 是一种弱类型语言</strong>。</li>
<li><span class="pn">Page 45</span>数据类型的 rank 相同时，一般按照<strong>低等级整型转换为高等级整型，有符号的转换为无符号</strong>。</li>
<li><span class="pn">Page 46</span>使用 __cplusplus 宏判断编译使用的 C++ 版本：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">if</span> __cplusplus &lt; 201103L</span>
  <span class="token macro property">#<span class="token directive keyword">error</span> "should use C++11 implementaton."</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ol start="13">
<li><span class="pn">Page 51</span>如上一条所示，#error 宏为预处理时的”断言“；而 static_assert() 为编译时静态断言，可达到率百分之百。其中使用的表达式必须为常量表达式；assert() 为动态运行时断言，只能断言到被运行到的代码块。</li>
<li><span class="pn">Page 59</span>在 C++11 中，可以使用 sizeof 对类成员表达式（非类实例成员）进行操作。</li>
<li><span class="pn">Page 61</span>形如 <code>friend int;</code> 在内置类型上的友元声明一般会被编译器忽略，因此这对于模板友元是一个方便的地方。</li>
<li><span class="pn">Page 65</span>final 和 override 关键字：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> A <span class="token punctuation">{</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> B <span class="token operator">:</span> <span class="token keyword">public</span> A <span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> final override <span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  A a<span class="token punctuation">,</span> <span class="token operator">*</span>fa <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
  B b<span class="token punctuation">,</span> <span class="token operator">*</span>fb <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>
  fb<span class="token operator">-</span><span class="token operator">></span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 动态调用，若派生类没实现，则调用基类的同名同参虚函数，使用 final 可以防止虚函数被派生类复写；</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="17">
<li><span class="pn">Page 67</span>override 关键字可以帮助开发者确认被标记的函数正确地重载了其父类中的虚函数，而非想要新添加成员函数。这在多继承或派生类继承链较深的情况下十分有帮助。</li>
<li><span class="pn">Page 68</span>模板参数对于非引用类型，在推导时会丢失 top-level 常量性。若为引用类型，当模板参数为 “&amp;&amp;” 右值引用时可以保持引用的左值性和常量性。其中对于 T，仅能推导出原类型或者对应的左值引用类型。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">ftVal</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">ftRef</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> vInt <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> vIntRR <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> vChar <span class="token operator">=</span> <span class="token string">"Hello, world!"</span><span class="token punctuation">;</span>
  <span class="token keyword">auto</span><span class="token operator">&amp;</span> vIntRef <span class="token operator">=</span> vInt<span class="token punctuation">;</span>
  <span class="token function">ftVal</span><span class="token punctuation">(</span>vInt<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// "i";</span>
  <span class="token function">ftVal</span><span class="token punctuation">(</span>vChar<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// "PKc";</span>
  <span class="token function">ftRef</span><span class="token punctuation">(</span>vIntRR<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// T = const int&amp;;</span>
  <span class="token function">ftRef</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// T = int;</span>
  <span class="token function">ftRef</span><span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// T = char;</span>
  <span class="token function">ftRef</span><span class="token punctuation">(</span>vInt<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// T = const int&amp;;</span>
  <span class="token function">ftRef</span><span class="token punctuation">(</span>vChar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// T = const char* const&amp;;</span>
  <span class="token function">ftRef</span><span class="token punctuation">(</span>vIntRef<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// T = const int&amp;;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="19">
<li><span class="pn">Page 72</span>外部（extern）模板声明可以放置在头文件中以便于使用。</li>
<li><span class="pn">Page 73</span>一般来说，外部模板声明可用于优化编译及链接时间，<strong>建议仅在项目比较大的情况下再使用</strong>。对于大部分正常的模板实例化，编译器已经会进行一定程度的冗余实例优化。</li>
<li><span class="pn">Page 74</span>接受匿名和局部类型的模板：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">struct</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> so<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> si<span class="token punctuation">;</span>
  <span class="token function">foo</span><span class="token punctuation">(</span>si<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">foo</span><span class="token punctuation">(</span>so<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="22">
<li><span class="pn">Page 78</span>根据 C++ 名字查找规则，派生类中的同名成员函数会覆盖基类中的函数，而不能跨作用域进行重载。但经过 using 改变作用域可见性后，在派生类中便可以与基类中同名成员函数组成重载关系。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> A <span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'A'</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> B <span class="token operator">:</span> <span class="token keyword">public</span> A <span class="token punctuation">{</span>
  <span class="token keyword">using</span> A<span class="token operator">::</span>foo<span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'B'</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  B b<span class="token punctuation">;</span>
  b<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  b<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="23">
<li><span class="pn">Page 80</span>在派生类中发生冲突的多继承类构造函数，需要被单独定义。</li>
<li><span class="pn">Page 81</span>继承的构造函数不受 using 可见性的影响。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> A <span class="token punctuation">{</span>
  <span class="token keyword">int</span> v<span class="token punctuation">;</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">v</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token keyword">public</span> A <span class="token punctuation">{</span>
  <span class="token keyword">using</span> A<span class="token operator">::</span>A<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  B <span class="token function">b</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="25">
<li><span class="pn">Page 83</span><strong>委派构造函数（调用其他构造函数进行初始化）不能有初始值列表</strong>，即构造函数不能同时“委派”和使用初值列表。对于剩余的初始化操作，只能在构造函数的函数体中进行。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> A <span class="token punctuation">{</span>
  <span class="token keyword">int</span> x<span class="token punctuation">;</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// A(int x) : A(), x(x) {}  // wrong!</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="26">
<li><span class="pn">Page 84</span>由于目标构造函数的执行总是优先于委派构造函数，因此避免目标构造函数和委托构造函数中初始化相同的成员通常是必要的。</li>
<li><span class="pn">Page 85</span>基于委派构造，使用构造模板函数产生目标的泛型构造函数：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> A <span class="token punctuation">{</span>
  std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lst<span class="token punctuation">;</span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
  <span class="token function">A</span><span class="token punctuation">(</span>T start<span class="token punctuation">,</span> T end<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">lst</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  A <span class="token function">a</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> e <span class="token operator">:</span> a<span class="token punctuation">.</span>lst<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="28">
<li><span class="pn">Page 94</span>将亡值：<code>std::move</code> 的返回值、类型为 T&amp;&amp; 将要被移动的对象（被右值引用类型变量标记的右值）；纯右值：返回的临时变量值、字面量值、lambda 表达式、运算表达式、类型转换函数的返回值。</li>
<li><span class="pn">Page 95</span>左值引用是<strong>具名</strong>变量值的别名，右值引用是<strong>不具名</strong>（匿名）变量的别名。</li>
<li><span class="pn">Page 101</span>移动构造的常用方式：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> A <span class="token punctuation">{</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
  A<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
  <span class="token function">A</span><span class="token punctuation">(</span>A<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token operator">:</span> <span class="token function">p</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span> rhs<span class="token punctuation">.</span>p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  A<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>A<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> p <span class="token operator">=</span> rhs<span class="token punctuation">.</span>p<span class="token punctuation">;</span> rhs<span class="token punctuation">.</span>p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">int</span> <span class="token function">getPV</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token punctuation">}</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
A <span class="token function">getTempA</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">A</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">auto</span> a <span class="token operator">=</span> <span class="token function">getTempA</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 自 C++17 起，某些 RVO/NRVO 类似的临时值消除过程会由编译器强制执行，而不受 -fno-elide-constructors 参数的影响；</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">.</span><span class="token function">getPV</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="31">
<li><span class="pn">Page 103</span>标准库 STL 中的一些容器类型只会使用被标记为不会抛出异常的移动构造和移动赋值函数。std::move_if_noexcept()</li>
<li><span class="pn">Page 105</span>使用 <code>std::forward</code> 保持模板传递时的参数类型：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"int&amp; v"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"const int&amp; v"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"int&amp;&amp; v"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"const int&amp;&amp; v"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">bar</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> z <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> k <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
  <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// "int&amp; v";</span>
  <span class="token function">foo</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// "const int&amp; v";</span>
  <span class="token function">foo</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// "int&amp; v";</span>
  <span class="token function">foo</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// "const int&amp; v";</span>
  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// "int&amp;&amp; v";</span>
  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// "const int&amp;&amp; v";</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="33">
<li><span class="pn">Page 108</span>利用完美转发做包装函数：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span> U<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">PerfectForward</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">,</span> U<span class="token operator">&amp;</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ol start="34">
<li><span class="pn">Page 109</span><strong>在构造函数有默认参数值的情况下，构造函数仍有可能被隐式调用</strong>：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> A <span class="token punctuation">{</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  A a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="35">
<li><span class="pn">Page 110</span>将 explicit 应用于自定义类型转换操作符以阻止自定义类型的隐式自动转换：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> A <span class="token punctuation">{</span>
  <span class="token keyword">explicit</span> <span class="token keyword">operator</span> <span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  A x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// std::cout &lt;&lt; x + y &lt;&lt; std::endl; // 2;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="36">
<li><span class="pn">Page 116</span>对于 const 变量来说，如果新类型可以完整存放其值，则通过列表初始化方式赋值时并不会出现 narrowing 问题。</li>
<li><span class="pn">Page 127</span>若非受限联合体有非 POD 成员，且该成员有非平凡的构造函数，则该联合体的默认构造函数/析构函数将被标记为删除，需要进行自定义。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">union</span> T <span class="token punctuation">{</span>
  std<span class="token operator">::</span>string s<span class="token punctuation">;</span>
  <span class="token keyword">int</span> v<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// T t;  // wrong!</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="38">
<li><span class="pn">Page 128</span>pseudo-destructor：伪析构函数需要保证显式调用非类类型的析构函数的语法是有效，因此可以编写代码而不必知道给定类型是否存在析构函数（内置类型 or 自定义类型）。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> A <span class="token punctuation">{</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
  <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Real Destructor A."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> TypeA <span class="token operator">=</span> A<span class="token punctuation">;</span>
<span class="token keyword">using</span> TypeInt <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  TypeA v<span class="token punctuation">;</span>
  TypeInt i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  v<span class="token punctuation">.</span><span class="token operator">~</span><span class="token function">TypeA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  i<span class="token punctuation">.</span><span class="token operator">~</span><span class="token function">TypeInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="39">
<li><span class="pn">Page 131</span>自定义字面量值（operator “” [_Literal]）：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> A <span class="token punctuation">{</span>
  <span class="token keyword">int</span> v<span class="token punctuation">;</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">v</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
A <span class="token keyword">operator</span> <span class="token string">""</span> <span class="token function">_toA</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">A</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">auto</span> t <span class="token operator">=</span> 10_toA<span class="token punctuation">;</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span>v <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="40">
<li><span class="pn">Page 132</span>自定义字面量值（operator “”）的参数要求：</li>
</ol>
<ul>
<li><strong>整数型</strong>：unsigned long long / const char*；</li>
<li><strong>浮点数</strong>：long double / const char*；</li>
<li><strong>字符串</strong>：const char* + size_t；</li>
<li><strong>字符</strong>：char；</li>
</ul>
<ol start="41">
<li><span class="pn">Page 140</span>SFINEA 规则：匹配失败不是错误。即<strong>对重载的模板参数进行展开的时候，如果展开导致了一些类型不匹配，编译器并不会报错</strong>。基于此规则，编译器会对某些模板使用更为精确的版本来实例化，另外一些则使用通用版本进行实例化。</li>
<li><span class="pn">Page 144</span>一般函数内没有声明为 static 的变量总是具有自动存储期的局部变量。</li>
<li><span class="pn">Page 150</span>auto 关键字不能保持<strong>变量</strong>而非引用的顶层 CV（const/volatile）特性。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>
  <span class="token keyword">auto</span><span class="token operator">&amp;</span> z <span class="token operator">=</span> y<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// "const int &amp;z";</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="44">
<li><span class="pn">Page 151</span>auto 实际上是一个将要推导出类型的占位符。</li>
<li><span class="pn">Page 152</span>使用 auto 推导数组类型时需要<strong>显式指定类型为指针</strong>，否则会退化为指针地址对应的整型。</li>
<li><span class="pn">Page 160</span>decltype(e) 的类型推导规则：</li>
</ol>
<ul>
<li>如果 e 是一个没有带括号的标记符（一般为程序员自定义的标记）表达式或类成员访问表达式，则推导结果为 e 所命名的实体类型；</li>
<li>否则，若 e 的类型为 T，若 e 为将亡值 <strong>xvalue</strong>（一般为 <code>std::move(x)</code>；而字面量值通常为纯右值 <strong>prvalue</strong>），则推导结果为 T&amp;&amp;；</li>
<li>否则，若 e 的类型为 T，若 e 为一个左值（引用），则推导结果为 T&amp;；</li>
<li>否则，若 e 的类型为 T，推导结果为 T；</li>
</ul>
<ol start="47">
<li><span class="pn">Page 161</span>注意 decltype 在推导自增运算符表达式时的区别：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword">decltype</span><span class="token punctuation">(</span>i<span class="token operator">++</span><span class="token punctuation">)</span> x<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// int；</span>
  <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token operator">++</span>i<span class="token punctuation">)</span> x <span class="token operator">=</span> i<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// "int&amp;"；</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="48">
<li><span class="pn">Page 164</span>与 auto 不同的是，放置于 decltype 后面的*号不会被编译器忽略，因此在推导指针类型时不需要另外放置该符号。</li>
<li><span class="pn">Page 165</span>追踪返回类型：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T1<span class="token punctuation">,</span> <span class="token keyword">typename</span> T2<span class="token operator">></span>
<span class="token keyword">auto</span> <span class="token function">sum</span><span class="token punctuation">(</span>T1<span class="token operator">&amp;</span> t1<span class="token punctuation">,</span> T2<span class="token operator">&amp;</span> t2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>t1 <span class="token operator">+</span> t2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> t1 <span class="token operator">+</span> t2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="50">
<li><span class="pn">Page 167</span>定义类型：“一个函数返回一个函数指针，这个函数指针的返回值是一个函数指针”：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>foo<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">auto</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ol start="51">
<li><span class="pn">Page 179</span>非强类型枚举类的缺点：非强类型作用域（污染全局环境）、允许隐式转换为整型、占用存储空间及符号性不确定；</li>
<li><span class="pn">Page 184</span>只能使用<strong>右值来初始化一个 std::unique_ptr</strong>，而 std::unique_ptr 可以通过 std::move 来交换所有权：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">auto</span> up <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">auto</span> nup <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>up<span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>up <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 1;</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>nup <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 10;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="53">
<li><span class="pn">Page 186</span>由于 std::shared_ptr 控制块堆内存的释放与引用托管对象的 std::weak_ptr 的数量有关。因此在不需要使用 std::weak_ptr 时，可以通过 std::weak_ptr<T>::reset 及时切断引用。</li>
<li><span class="pn">Page 187</span>两种常用的垃圾回收方式：</li>
</ol>
<ul>
<li>基于引用计数：优点实现简单，缺点容易造成循环引用（参考 std::shared_ptr）；</li>
<li>基于跟踪处理：<ul>
<li>标记-清除（Mark-Sweep）：查找程序使用对象的堆空间，并做标记，所有被标记的对象便为可达对象，没有被标记的对象将在“清除”步骤被清理。<strong>存在内存碎片问题</strong>；</li>
<li>标记-整理（Mark-Compact）：同上，但标记之后不做清理，而是将所有可达对象向内存一端移动，以解决碎片问题；<strong>存在需要更新程序中所有堆内存引用的问题</strong>。</li>
<li>标记-拷贝（Mark-Copy）：From-To，现在 From 里分配内存，分配满之后开始垃圾回收，将 From 中所有可达对象向 To 拷贝。然后交换角色重复上述过程。<strong>存在堆内存利用率低的问题</strong>；</li>
</ul>
</li>
</ul>
<ol start="55">
<li><span class="pn">Page 189</span>C++ 垃圾回收：贝姆（Boehm）垃圾收集器。</li>
<li><span class="pn">Page 190</span>检查是否支持最小垃圾回收及安全派生指针：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Pointer safety: "</span><span class="token punctuation">;</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">get_pointer_safety</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> std<span class="token operator">::</span>pointer_safety<span class="token operator">::</span>strict<span class="token operator">:</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"strict\n"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> std<span class="token operator">::</span>pointer_safety<span class="token operator">::</span>preferred<span class="token operator">:</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"preferred\n"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> std<span class="token operator">::</span>pointer_safety<span class="token operator">::</span>relaxed<span class="token operator">:</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"relaxed\n"</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="57">
<li><span class="pn">Page 193</span>数组大小参数、switch-case 的 case 语句以及枚举类成员都需要使用编译期常量进行初始化。</li>
<li><span class="pn">Page 195</span>constexpr 函数：</li>
</ol>
<ul>
<li>函数体只有单一的 return 语句（可以有 using、typedef 以及 assert）；</li>
<li>函数必须有返回值（不能是 void 函数）；</li>
<li>函数在使用前必须已有定义；</li>
<li>函数的 return 返回语句中不能使用非常量表达式的函数、全局数据，且必须是一个常量表达式；</li>
</ul>
<ol start="59">
<li><span class="pn">Page 197</span>const 常量和 constexpr 常量的区别：大多数情况下两者没有区别。但如果在全局命名空间中，编译器一定会为 const 产生数据，而 constexpr 除非有代码显式使用了它的地址，否则一般不会为其生成数据，而仅当做编译期的值（编译时替换），类似枚举值。</li>
<li><span class="pn">Page 198</span>constexpr 构造函数：</li>
</ol>
<ul>
<li>函数体必须为空；</li>
<li>初始化列表只能由常量表达式（包括字面量值）来赋值；</li>
</ul>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> i<span class="token punctuation">;</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">constexpr</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> 
  <span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">getV</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">constexpr</span> <span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword">constexpr</span> A a<span class="token punctuation">{</span>v<span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> arr<span class="token punctuation">[</span>a<span class="token punctuation">.</span><span class="token function">getV</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="61">
<li><span class="pn">Page 199</span>当声明为常量表达式的模板函数后，而某个其实例化结果不满足常量表达式的需求的话，则 constexpr 关键字会被自动忽略。</li>
<li><span class="pn">Page 202</span>constexpr 元编程 / template 元编程，两者均是图灵完备的。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// template - TMP;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span>size_t n<span class="token operator">></span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> fib<span class="token operator">&lt;</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> fib<span class="token operator">&lt;</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span> <span class="token keyword">constexpr</span> <span class="token keyword">int</span> fib<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span> <span class="token keyword">constexpr</span> <span class="token keyword">int</span> fib<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// constexpr - CMP;</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> i <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token function">fib</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fib</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> arrA<span class="token punctuation">[</span><span class="token function">fib</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> arrB<span class="token punctuation">[</span>fib<span class="token operator">&lt;</span><span class="token number">3</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<br><div class="article-bottom-meta"><span class="post-meta">Last built on<time itemprop="dateModified" datetime="2020-05-09T02:22:12.000Z"> 2023 / 10 / 26, 11:37:10</time></span></div></div></article><br><span class="next-post"><a href="/2020/05/12/“深入理解-C-11：C-11-新特性解析与应用”-读书笔记（二）/" itemprop="url">下一篇 ⇒</a></span><span class="prev-post"><a href="/2020/05/06/C-聚合类与-POD/" itemprop="url">⇐ 上一篇</a></span><br><section id="comments"><h4>评论 | Comments</h4><br><div class="comment-container"><div class="loading-mask">Loading ...</div><script src="https://utteranc.es/client.js" repo="Becavalier/utterances-comments" issue-term="title" label="[Comment]" theme="github-light" crossorigin="anonymous" async></script></div></section><br><br></main><script src="/scripts/index.js" type="text/javascript"></script></body></html>