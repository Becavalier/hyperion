<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>《Primer C++ 5th》完全笔记（第 1-8 章） | 曜彤.手记</title><meta name="baidu-site-verification" content="codeva-P9jyH0b1lv"><meta name="description" content="最近趁新冠肺炎在家工作（WFH）期间的“充足”闲暇时间，把 Primer C++（第五版）整本书又完整地看了一遍。花了将近一个月的时间，整理出近 300 条左右的笔记，基本涵盖了所有 C++ 语言（C++11）需要注意的细节，而本文将首先记录全书第1-8章中出现的知识点。注意这些知识点的记录完全遵循我个人的想法，因此也仅适配我个人的情况和需求，未记录的其他知识点并非不重要。"><meta name="generator" content="曜彤.手记"><meta name="keywords" content="博客, C++, C, Rust, Web, Java, IT, 编程, 开发, Android, Python, MySQL, 科技, 黑客, 技术, Javascript, 云, 大数据, 计算, 机器学习, AI, 人工智能, 创业, 产品, 公司, WebAssembly, Wasm"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.jpg"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.jpg"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.jpg"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.jpg"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.jpg"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.jpg"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.jpg"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.jpg"><link rel="apple-touch-icon" sizes="196x196" href="/images/apple-touch-icon-196x196.jpg"><link rel="apple-touch-icon" sizes="310x310" href="/images/apple-touch-icon-310x310.jpg"><link href="/images/splash/iphone5_splash.png" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphone6_splash.png" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphoneplus_splash.png" media="(device-width: 621px) and (device-height: 1104px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/iphonex_splash.png" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/iphonexr_splash.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphonexsmax_splash.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/ipad_splash.png" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro1_splash.png" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro3_splash.png" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro2_splash.png" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="128x128" href="/images/favicon-128.png"><link rel="icon" type="image/png" sizes="196x196" href="/images/favicon-196x196.png"><meta name="msapplication-TileColor" content="#FFFFFF"><meta name="msapplication-TileImage" content="mstile-144x144.png"><meta name="msapplication-square70x70logo" content="mstile-70x70.png"><meta name="msapplication-square150x150logo" content="mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="mstile-310x150.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"><link rel="manifest" href="/manifest.webmanifest"><link rel="alternate" type="application/atom+xml" title="Atom 0.3" href="/atom.xml"><link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body itemscope itemtype="https://schema.org/WebPage"><div class="canvas-containter"><span>X</span></div><header itemscope itemtype="https://schema.org/WPHeader"><div class="logo"></div><h1 class="title"><a href="/" alt="曜彤.手记" title="曜彤.手记" itemprop="headline">曜彤.手记</a><a title="Atom 0.3" target="__blank" href="/atom.xml" class="rss"><img src="/images/rss.png"></a></h1><p itemprop="description" class="description">随记，关于互联网技术、产品与创业</p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name" class="menu-item"><a href="/ " alt="首页" title="首页" itemprop="url">首页</a></li><li itemprop="name" class="menu-item"><a href="/articles" alt="文章" title="文章" itemprop="url">文章</a></li><li itemprop="name" class="menu-item"><a href="/readings" alt="阅读" title="阅读" itemprop="url">阅读</a></li><li itemprop="name" class="menu-item"><a href="/cards" alt="快记" title="快记" itemprop="url">快记</a></li><li itemprop="name" class="menu-item"><a href="/tags" alt="标签" title="标签" itemprop="url">标签</a></li><li itemprop="name" class="menu-item"><a href="/about" alt="关于" title="关于" itemprop="url">关于</a></li></ul></nav><div class="dynamic-slot"></div><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><script src="https://shadow.elemecdn.com/npm/zoomage.js@latest/dist/zoomage.min.js" type="text/javascript"></script><script src="https://shadow.elemecdn.com/npm/axios@0.18.0/dist/axios.min.js" type="text/javascript"></script><script src="/scripts/post.js" type="text/javascript"></script><div class="touch-top"><span></span></div><article post-id="《Primer C++ 5th》完全笔记（第 1-8 章）" class="full article-post"><h1 itemprop="headline" class="align-center">《Primer C++ 5th》完全笔记（第 1-8 章）</h1><div class="content"><div class="article-meta"><span class="post-meta"><br>Created on<time itemprop="dateCreated" datetime="2020-04-10T05:20:03.000Z"> 2020 / 04 / 10, 13:20:03</time></span><span class="page-tag-anchor"><a href="/tags/Cpp" itemprop="url">#Cpp</a>&nbsp;&nbsp;</span></div><p>最近趁新冠肺炎在家工作（WFH）期间的“充足”闲暇时间，把 Primer C++（第五版）整本书又完整地看了一遍。花了将近一个月的时间，整理出近 <strong>300</strong> 条左右的笔记，基本涵盖了所有 C++ 语言需要注意的细节，而本文将首先记录全书第1-8章中出现的知识点。注意这些知识点的记录完全遵循我个人的想法，因此也仅适配我个人的情况和需求，未记录的其他知识点并非不重要。</p>
<ol>
<li><p>(Page：4) 可用于 Shell 脚本：<br><code>echo $?</code> 上一次程序退出的返回值，0 通常表示没有错误，其他表示失败；<br><code>echo $$</code> 当前脚本运行所在进程的 ID 号；<br><code>echo $#</code> 传入脚本的参数个数（同主函数的 argc 参数）；<br><code>echo $0</code> 脚本名称（同主函数的 args[] 参数）；<br><code>echo $1</code> 传入脚本的第一个参数；<br><code>echo $2</code> 传入脚本的第二个参数；</p>
</li>
<li><p><span class="pn">Page 5</span><em><strong>ios</strong></em> <em><strong>istream</strong></em> <em><strong>ostream</strong></em> 与 <em><strong>iostream</strong></em> 是对应模板类的一个常用 char 类型特化；每一个类都有对应的 wchar_t 宽字符类型特化版本；其中 basic_istream 和 basic_ostream <strong>虚继承</strong>自 basic_ios，以保证 basic_iostream 对象只有一份 basic_ios 实例。</p>
</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> std<span class="token operator">::</span>basic_ios<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> ios<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> std<span class="token operator">::</span>basic_istream<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> istream<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> std<span class="token operator">::</span>basic_ostream<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> ostream<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> std<span class="token operator">::</span>basic_iostream<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> iostream<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="1.png"></p>
<ol start="3">
<li><span class="pn">Page 7</span>std::cout 和 std::cin 两个对象均返回其自身作为表达式的运算结果，因此这里可以通过 “&lt;&lt;” 运算符进行链式调用。</li>
<li><span class="pn">Page 13</span>通常使用 <code>while (std::cin &gt;&gt; value) &#123;&#125;</code> 来判断输入流是否有效；或使用 <code>cin::good()</code> 来判断：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>ifstream <span class="token function">file</span><span class="token punctuation">(</span><span class="token string">"./file.txt"</span><span class="token punctuation">,</span> std<span class="token operator">::</span>ios<span class="token operator">::</span>binary<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> c<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// eofbit / failbit / badbit 三个 std::ios_base::iostate 位均为 false；</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">good</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> file <span class="token operator">>></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  cout <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="5">
<li><span class="pn">Page 30</span>用于国际化支持的类型：wchar_t 及 char16_t / char32_t（用于 Unicode 字符集）；一个约定即：<strong>更大值类型至少和次大值类型的可取值范围一样大</strong>，比如：一个 int 至少和一个 short 一样大；一个 long 至少和一个 int 一样大。</li>
<li><span class="pn">Page 31</span>写法上：unsigned int 和 unsinged 是一样的；</li>
<li><span class="pn">Page 32</span>计算机内部采用 2 的补码（Two’s Complement）表示负数。</li>
</ol>
<ul>
<li>正数补码：与原码相同；</li>
<li>负数补码：<strong>原码（首位为1）除首位外取反再加一</strong>。因为进位的原因导致 <strong>-0 和 +0 的补码相同，而原码不同</strong>，因此补码相较原码便可多表示一个数字。如 10000000（比如8位二进制码，将原码补码按照从 +127 逐渐递减的方式写出来，会发现最后补码多出来一位即 10000000，按照递减顺序可表示 -128）便为 -128 的补码，而其没有对应的原码和反码。使用这种方式有利于 CPU 电路进行加法运算（比如一个正数加一个负数）：</li>
</ul>
<pre class="line-numbers language-text"><code class="language-text">  ０００１００００ (16)
+ １１１１１０００ (-8)
－－－－－－－－－
１００００１０００
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="8">
<li><span class="pn">Page 32</span>优先使用的 C++ 类型：int / long long / unsigned char / signed char / double。其中由于 char 的符号在不同机器上可能不相同，因此需要明确指出其符号类型。</li>
<li><span class="pn">Page 34</span>C-Implicit Conversions：如果具有 unsigned 整数类型的操作数其 rank 大于或等于另一个操作数的类型的 rank，<strong>则 signed 整数类型的操作数应转换为具有 unsigned 整数类型的操作数类型</strong>。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">unsigned</span> u <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">/**
 * 此处 i 会隐式转换成 unsigned 类型；
 * int -> unsigned int: -42 -> (2^32)4294967296 + (-42);
 */</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>u <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="10">
<li><span class="pn">Page 39</span>常用的值初始化形式：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 使用花括号“{}”的列表初始化会对精度丢失给出警告（Warning）；</span>
<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> 
<span class="token keyword">int</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> x<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="11">
<li><span class="pn">Page 40</span>定义于函数体内的内置类型对象如果没有初始化，则其值未定义。类的对象如果没有显示地初始化，则其值由类确定（不带有 explicit 的默认构造函数）。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> x<span class="token punctuation">;</span>
  cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// x 值未定义；</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="12">
<li><span class="pn">Page 41</span>分离式编译之 extern 用法：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// header.h</span>
<span class="token macro property">#<span class="token directive keyword">ifndef</span> HEADER_H</span>
<span class="token macro property">#<span class="token directive keyword">define</span> HEADER_H</span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> globalX<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 只声明，而非定义（告知编译器类型，在链接时再寻找实际定义的符号）；</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

<span class="token comment" spellcheck="true">// main.cc</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"header.h"</span></span>

<span class="token keyword">int</span> globalX<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 实际定义；</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  globalX <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="13">
<li><span class="pn">Page 44</span>访问全局作用域：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>

<span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">::</span>y <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="14">
<li><span class="pn">Page 46</span>引用：是值绑定而非拷贝，绑定后无法再更改；非常量引用不能用字面量值进行初始化。</li>
<li><span class="pn">Page 48</span>nullptr == NULL == 0；</li>
<li><span class="pn">Page 52</span>指针的引用：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&amp;</span> r <span class="token operator">=</span> p<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ol start="17">
<li><span class="pn">Page 54</span>若需要在多个文件之间共享 const 对象，则必须在变量的声明或定义之前添加 <strong>extern</strong> 关键字。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// header.h</span>
<span class="token macro property">#<span class="token directive keyword">ifndef</span> HEADER_H</span>
<span class="token macro property">#<span class="token directive keyword">define</span> HEADER_H</span>
<span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">int</span> bufferSize<span class="token punctuation">;</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

<span class="token comment" spellcheck="true">// main.cc</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"header.h"</span></span>

<span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">int</span> bufferSize <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 定义；</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="18">
<li><span class="pn">Page 56</span>复杂指针解读：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 从右向左分析：常量指针（本身值不能改）->（指向）const int（整型常量）；</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">const</span> pip <span class="token operator">=</span> <span class="token operator">&amp;</span>pi<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ol start="19">
<li><span class="pn">Page 57</span>两种 const：</li>
</ol>
<ul>
<li>顶层（top-level const）const：指针本身是常量；</li>
<li>底层（low-level const）const：指针所指向对象是个常量；</li>
</ul>
<ol start="20">
<li><span class="pn">Page 58</span>当执行对象拷贝（赋值）时，拷入和拷出对象必须具有<strong>相同的底层 const</strong> 资格（顶层 const 通常被忽略。在使用 auto 关键字时，变量的引用类型和顶层 const 特性需要由用户自己添加，如：<code>const auto&amp; x = y;</code>，否则将会被忽略，即 “Type Decay”），以保证原对象具有统一的可访问性。</li>
<li><span class="pn">Page 59</span>constexpr 变量需要能在<strong>编译过程中就得到求值</strong>，因此对应表达式只能是字面量值或同类的 constexpr 表达式。constexpr 指针的初始值必须是 nullptr 或 0，或存储于某个<strong>固定地址</strong>的对象。而函数体内定义的变量并非存放在固定地址中，因此 constexpr 不能指向这样的变量（地址）。相反，定义于所有函数体之外的对象其地址固定不变，可用来初始化 constexpr 指针。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 函数体之外的变量；</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">constexpr</span> <span class="token keyword">int</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 非常量表达式（编译器自行判断）；</span>
  <span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 可以用来初始化 constexpr 指针；</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="22">
<li><span class="pn">Page 60</span>对指针来说，constexpr 的存在类似于顶层 const：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 指向常量的指针；</span>
<span class="token comment" spellcheck="true">// int* const q = nullptr;</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span><span class="token operator">*</span> q <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 常量指针；</span>
<span class="token comment" spellcheck="true">// const int* const w = nullptr;</span>
<span class="token keyword">constexpr</span> <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> w <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 指向常量的常量指针；</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="23">
<li><span class="pn">Page 61</span>typedef 陷阱：此处声明的 cstr 是常量指针，const 是对给定类型的修饰符.</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">char</span><span class="token operator">*</span> pstring<span class="token punctuation">;</span>
<span class="token keyword">const</span> pstring cstr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 顶层 const；</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ol start="24">
<li><span class="pn">Page 63</span>decltype 与表达式形式：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> r<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// int&amp;;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> d <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// int&amp;;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> e<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// int;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="25">
<li><span class="pn">Page 68</span>头文件保护符：防止头文件的内容被重复包含。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">ifndef</span> SALES_DATA_H</span>
<span class="token macro property">#<span class="token directive keyword">define</span> SALES_DATA_H</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="26">
<li><span class="pn">Page 74</span>C++17 支持的 Multiple Declarators，可以用一个 using 语句进行多个声明。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// clang++ main.cc -o main --std=c++17</span>
<span class="token keyword">using</span> std<span class="token operator">::</span>cout<span class="token punctuation">,</span> std<span class="token operator">::</span>endl<span class="token punctuation">,</span> std<span class="token operator">::</span>cin<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ol start="27">
<li><span class="pn">Page 79</span>尽量保证使用同类型数据进行比较运算，以防止 Implicit Conversions 带来的问题：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>string s <span class="token operator">=</span> <span class="token string">"Hello!"</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// length()/size() 返回 string::size_type 类型为无符号类型；</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ol start="28">
<li><span class="pn">Page 81</span>C++ 中的字符串字面量值并不是 string 对象，因此在进行加法（+）运算时，需确保运算符两侧至少有一个是 string 类型对象，以使另一个对象可以进行隐式的转换。</li>
<li><span class="pn">Page 87</span>初始化 std::vector 对象的几种方式：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>T<span class="token operator">></span> v1<span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">v2</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span>T<span class="token operator">></span> v2 <span class="token operator">=</span> v1<span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">v3</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">v4</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span>T<span class="token operator">></span> v5<span class="token punctuation">{</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span>T<span class="token operator">></span> v6 <span class="token operator">=</span> <span class="token punctuation">{</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="30">
<li><span class="pn">Page 88</span>初始值元素列表只能使用花括号，圆括号会被当做构造函数的调用。C++11 只能对<strong>没有类内初始值</strong>的<strong>聚合类（所有成员均为 public、没有定义显式的构造函数（包括拷贝构造）、没有基类、没有虚函数）</strong>进行聚合类列表初始化，而 C++14 则可以对有类内初始值的聚合类（自 C++14 起，有无类内初始化器不再成为聚合体的要求）进行列表初始化。非聚合体则按照构造函数初始化。{} 会首先尝试进行列表初始化，若无法实现再尝试通过构造函数进行。复制列表初始化（=）会产生临时对象，性能上可能（RVO/NRVO）低于直接列表初始化。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> S <span class="token punctuation">{</span>
  <span class="token function">S</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
  <span class="token function">S</span><span class="token punctuation">(</span>initializer_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> li<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 非聚合类，执行构造初始化；</span>
  <span class="token function">S</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">double</span> d<span class="token punctuation">,</span> string str<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">d</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">str</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span>
  string str<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 直接列表初始化：S s(1, 2.0, "Hello, world!");</span>
  S s <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token string">"Hello, world!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="31">
<li><span class="pn">Page 97</span>iterator / const_iterator。</li>
<li><span class="pn">Page 98</span>不要在 for 循环的迭代中改变容器的大小，比如：通过 push_back 向容器插入元素（会使迭代器失效）。</li>
<li><span class="pn">Page 102</span>数组之间不允许拷贝和赋值：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// int b[2] = arr;  // 错误；</span>
<span class="token keyword">int</span><span class="token operator">*</span> b <span class="token operator">=</span> arr<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 指针可以；</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ol start="34">
<li><span class="pn">Page 103</span>数组指针是个二级指针：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 数组指针；</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token operator">*</span>b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>b <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="35">
<li><span class="pn">Page 105</span>auto 推断数组元素只能得到指针；而 decltype 则可以得到数组类型。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 传递数组引用；</span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>f<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">auto</span> x <span class="token operator">=</span> f<span class="token punctuation">;</span>
  std<span class="token operator">::</span>remove_reference<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">::</span>type y<span class="token punctuation">;</span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Pi;</span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// A10_i;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>agv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 1, 2, 0, 0, 0, 0, 0, 0, 0, 0（多维数组类似）；</span>
  <span class="token function">foo</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="36">
<li>（Page: 108）C++ 内置数组可以使用负索引值，编译器会将其转换成对应的指针加减操作。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 相当于 *(p - 1)；</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ol start="37">
<li><span class="pn">Page 111</span>std::string 可以使用 c_str() 来返回一个字符指针，但其内部仍与 std::string 对象共享同一块内存，因此建议将数组内容重新拷贝一份再继续使用。</li>
<li><span class="pn">Page 114</span>多维数组和 for 语句的结合，注意内层访问需要使用上一层（除最内层外）的引用类型（可以保留数组类型），否则直接传值会被编译器视为指针：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// for (const int (&amp;i)[3] : arr) {}</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>i <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// A3_i；</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> j <span class="token operator">:</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> j <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="39">
<li><span class="pn">Page 121</span>decltype 应用在<strong>结果为左值的表达式</strong>上时类型为对应左值类型的引用；应用在右值上时则为该值的原始类型；</li>
<li><span class="pn">Page 124</span>算数运算符在布尔类型上的陷阱（0 为 false，其余为 true）：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> b <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 1；</span>
<span class="token keyword">bool</span> b2 <span class="token operator">=</span> <span class="token operator">-</span>b<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// -1；</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ol start="41">
<li><span class="pn">Page 125</span>取余和商运算：</li>
</ol>
<pre class="line-numbers language-text"><code class="language-text">-(m/n) = (-m)/n = m/(-n);
m%n = m%(-n);
-(m%n) = (-m)%n;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ol start="42">
<li><span class="pn">Page 131</span>使用复合运算符的性能可能会高于同样的一般运算表达式。使用符合运算符只求值一次，使用普通运算符则求值两次（右侧子表达式求值+赋值运算符求值）。</li>
<li><span class="pn">Page 132</span>建议<strong>优先使用前置版本的递增运算符</strong>以尽量优化性能；前置版本不需要保存变量之前的值，而后置版本则需要暂存变量的原始值。</li>
<li><span class="pn">Page 137</span>取反的一般结论：<b>~n = -(n+1)</b>；</li>
</ol>
<pre class="line-numbers language-text"><code class="language-text">原数-补码（与原码、反码相同）：0000 1000（8）
求反-补码：1111 0111（符号位为 1，表示负数）
求反-原码（再求补码，除符号位求反加 1）：1000 1001（-9）
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>45.<span class="pn">Page 144</span>IO 库定义了从 istream 向布尔值的转换规则，因此可以直接使用 <code>while (cin &gt;&gt; s) &#123;&#125;</code> 来判断读入是否成功（即输入流的状态）。</p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// std::basic_ios 重载了 bool 类型转换操作符；</span>
<span class="token keyword">explicit</span> <span class="token keyword">operator</span> <span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ol start="46">
<li><span class="pn">Page 145</span>const_cast 只能作用于引用和指针，只能改变运算对象的底层 const，并且<strong>无法用于修改常量</strong>。其主要应用场景在于处理重载函数的 const 调用（如用 const 版本重载函数实现非 const 版本重载函数，两者保留一个 const 版本的完整实现即可）：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> <span class="token keyword">const</span> y <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// y 本身的 const 属性不受影响；</span>
<span class="token keyword">auto</span> k <span class="token operator">=</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 无法通过 k 来修改常量 x 的值；</span>

<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>k <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 引用没有顶层 const 的概念；</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="47">
<li><span class="pn">Page 162</span>switch … case 结构中的 case 标签必须是整型常量表达式。</li>
<li><span class="pn">Page 163</span>默认情况下 switch … case 中各语句<strong>均处在同一个作用域中</strong>，而为 case 语句增加大括号便可为其设置独立的作用域以初始化每个语句的“内部”变量。</li>
<li><span class="pn">Page 169</span>由于在范围 for 语句（来源于常规的基于迭代器的循环语句）中预存了尾后迭代器 end() 的值，因此不能在循环中更改容器的大小。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>i <span class="token operator">:</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span> i <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 等价于下面的迭代器循环；</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> beg <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> beg <span class="token operator">!=</span> end<span class="token punctuation">;</span> <span class="token operator">++</span>beg<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span><span class="token operator">*</span>beg<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ol start="50">
<li><span class="pn">Page 172</span>编译器可以直接将 goto 语句对应到类似的机器码（跳转语句），通过跳转到不同的内存地址来决定接下来将要调用的代码。因此相较于函数调用，其性能较高。</li>
<li><span class="pn">Page 175</span>try … catch 会沿着函数的调用栈向上逐层查找对应的 catch 语句，然后对每一个调用栈进行 stack unwinding 析构该作用域内的变量和对象，因此会损耗一定的性能。</li>
<li><span class="pn">Page 185</span><strong>自动对象</strong>：只存在于块（如函数体）执行期间的对象（默认初始化，值随机）；<strong>局部静态对象</strong>：static 对象，生命周期一直到主函数结束（内置类型初始化值为0）；</li>
<li><span class="pn">Page 194</span>显式传递给函数的数组参数（非引用），会被 decay 为对应的指针，失去长度信息。</li>
<li><span class="pn">Page 199</span>initializer_list 中的元素永远是常量值。</li>
<li><span class="pn">Page 201</span>函数返回引用不会生成临时值拷贝，但注意不能返回临时值的引用：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> string<span class="token operator">&amp;</span> <span class="token function">shorterString</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s1<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ol start="56">
<li><span class="pn">Page 205</span>使用 using 简化数组指针：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">using</span> arrT <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// int (*func(int i))[10];</span>
arrT<span class="token operator">*</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 返回数组指针；</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ol start="57">
<li><span class="pn">Page 206</span>使用尾置返回类型返回函数指针：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 返回函数指针；</span>
<span class="token keyword">auto</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// decltype 不会丢失数组类型；</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ol start="58">
<li><span class="pn">Page 211</span>不同作用域之间的函数无法实现重载，必须保证所有一组重载函数在同一个块作用域内。</li>
<li><span class="pn">Page 214</span>constexpr 函数（可用于常量表达式的函数，可以在编译时直接展开）的函数体必须有且只能有一条 return 语句：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> foo <span class="token operator">=</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ol start="60">
<li><span class="pn">Page 216</span>几个常用的调试宏：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp">cout <span class="token operator">&lt;&lt;</span> <span class="token constant">__func__</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 函数名；</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token constant">__FILE__</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 文件名；</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token constant">__TIME__</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 编译时间；</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token constant">__LINE__</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当前行号；</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token constant">__DATE__</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 编译日期；</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="61">
<li><span class="pn">Page 220</span>匹配候选函数时，所有算数类型转换的级别都一样，整数字面量值通常向 “int” 提升，浮点字面量值向 “double” 提升。只有在正好匹配对应形参类型时才会正常调用。</li>
<li><span class="pn">Page 221</span>声明函数指针类似声明数组指针：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 定义一个函数指针；</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 返回函数指针的函数；</span>
<span class="token comment" spellcheck="true">// auto bar(int x, int y) -> int(*)(const std::string);</span>

<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 数组指针</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 返回数组指针的函数；</span>
<span class="token comment" spellcheck="true">// auto foo(int x, int y) -> int(*)[10];</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="63">
<li><span class="pn">Page 230</span>定义在类内部的函数是默认隐式的 inline 函数；在类外部实现的成员方法则需要通过显式添加 inline 关键字来提示内联。</li>
<li><span class="pn">Page 231</span>类对象中各成员函数会隐式保有一个指向该对象的 this <strong>常量指针</strong>，可以通过 <code>this</code> 直接调用。</li>
<li><span class="pn">Page 232</span>常量成员函数：指向常量类对象（底层 const）的常量 this 指针（顶层 const），不能通过该指针修改类对象的内容。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>string <span class="token function">isbn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// const 修饰隐含的 this；</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ol start="66">
<li><span class="pn">Page 234</span>std::istream 与 std::ostream 等 IO 对象只能通过引用传递，无法拷贝和赋值；并且如需使用，则不能使用常量引用（会更改 IO 流）来传递。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>istream<span class="token operator">&amp;</span> <span class="token function">foo</span><span class="token punctuation">(</span>std<span class="token operator">::</span>istream<span class="token operator">&amp;</span> in<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    in <span class="token operator">>></span> x<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> in<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="67">
<li><span class="pn">Page 236</span>类的默认构造函数会为成员变量进行默认初始化：类内初始值（默认值）-&gt; 默认初始化（如数字类型通常为 0）；编译器只有在发现类<strong>不包含任何构造函数时</strong>才会生成默认构造函数并执行默认初始化。因为：</li>
</ol>
<ul>
<li>如果一个类在某种情况下需要控制对象初始化，则该类很可能在所有情况下都需要被控制；</li>
<li>对于内置类型（int）和复合类型（自定义的类），定义任何函数体<strong>之外</strong>的内置类型或复合类型变量将被默认初始化，<strong>对于函数体内的内置类型的对象，若没有初始化，其值是未定义的</strong>；</li>
<li>编译器需要能够为所有类成员进行默认初始化（包括能够调用其他类类型的默认构造函数）；</li>
</ul>
<ol start="68">
<li><span class="pn">Page 241</span>友元（友元类、友元函数）允许其他类或函数访问自己的非公有成员，应用场景包括：Profiling、Logging、Debuging 以及 Process Management：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token function">monitorX</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">monitorX</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">.</span>x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>agv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">monitorX</span><span class="token punctuation">(</span><span class="token number">666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 666；</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="69">
<li><span class="pn">Page 243</span>类内定义的类型别名（typedef / using）也遵循类对象的权限访问策略。</li>
<li><span class="pn">Page 245</span>可变成员（mutable）：即使在 const 函数内也可以修改该成员的值。使用场景：<strong>函数计数器</strong>、<strong>互斥锁</strong>等不会影响类对象外部可见状态的场景。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Screen</span> <span class="token punctuation">{</span>
  <span class="token keyword">mutable</span> size_t access_ctr<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ol start="71">
<li><span class="pn">Page 247</span>const 成员函数只能返回 const 对象的引用（因为这里的隐含 this 将是指向常量的指针，对应的常量对象只能返回给常量引用）。类成员函数可以通过返回类对象的引用来实现”链式调用”。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> A <span class="token punctuation">{</span>
  A<span class="token operator">&amp;</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      val <span class="token operator">+</span><span class="token operator">=</span> x<span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  A<span class="token operator">&amp;</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      val <span class="token operator">-</span><span class="token operator">=</span> x<span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">int</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> val<span class="token punctuation">;</span> <span class="token punctuation">}</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>agv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  A a<span class="token punctuation">;</span>
  cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sub</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="72">
<li><span class="pn">Page 250</span>类允许包含指<strong>向自身类型的引用或指针</strong>，而不能是对象类型：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  B b<span class="token punctuation">;</span>
  A<span class="token operator">*</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="73">
<li><span class="pn">Page 251</span>友元不具有传递性（不能跨链传播 A &lt;- B &lt;- C，C 无法访问 A 的私有成员）；若将某个类设置为友元，则该类下的所有成员函数都可以访问对应类的公有及非公有成员；</li>
<li><span class="pn">Page 252</span>友元的作用仅是影响访问权限，跟函数声明无关（理解为一个权限表，里面有若干函数的签名，符合签名的函数便可以访问该类的私有成员）。</li>
<li><span class="pn">Page 255</span>类的定义分为两部分：</li>
</ol>
<ul>
<li>首先，编译成员的声明；</li>
<li>直到类全部可见后才编译函数体（所以函数体内的符号会优先引用类范围内声明的符号）；</li>
</ul>
<ol start="76">
<li><span class="pn">Page 255</span>类型名的定义（typedef）通常出现在类的开始处，以防类的其他部分优先被外层的定义污染。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">double</span> Money<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Account</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  Money <span class="token function">balance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> bal<span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 类成员声明；函数参数，返回值类型将被优先编译；</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token comment" spellcheck="true">// 错误，不能重复定义类型（优先使用了类外的类型定义）；</span>
  <span class="token comment" spellcheck="true">// typedef double Money;  </span>
  Money bal<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 优先使用了类外的类型定义；</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="77">
<li><span class="pn">Page 258</span>如果没有在构造函数初始值列表中显式地初始化成员，则该成员将在构造函数<strong>之前</strong>执行默认初始化。而 <strong>const、引用类型成员以及属于某种未提供默认构造函数的类类型则必须初始化（通过初始值列表给予初值），而不能在构造函数中进行赋值</strong>。</li>
<li><span class="pn">Page 259</span>构造函数初始值列表没有规定成员的初始化顺序，一般编译器按照类中成员<strong>定义的先后顺序</strong>进行初始化。</li>
<li><span class="pn">Page 261</span>委托构造函数：使用其他构造函数对某个构造函数进行初始化。</li>
<li><span class="pn">Page 265</span>只有<strong>一个参数</strong>的构造函数能够用于隐式转换，多个参数的则无需添加 explicit 关键字（常用的编码规则：只接受一个参数的构造函数通常最好被标记为 explicit 以防不必要的错误隐式转换）。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
  <span class="token keyword">explicit</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>agv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  A a<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 无法隐式调用 A 的 explicit 构造函数；</span>
  a<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="81">
<li><span class="pn">Page 266</span>标准库中含有的显示构造函数类：</li>
</ol>
<ul>
<li>接受一个单参数的 const char* 的 string 构造函数不是 explicit 的；</li>
<li>接受一个容量参数的 vector 构造函数时 explicit 的；</li>
</ul>
<ol start="82">
<li><span class="pn">Page 267</span>聚合类：所有成员 public、没有定义显式构造函数、没有基类，没有虚函数，<strong>C++14及以后可以有类内初始值</strong>；聚合类可以直接使用花括号来初始化（聚合初始化）其成员。</li>
<li><span class="pn">Page 267</span>字面值常量类：聚合类、字面值类型成员 + constexpr 构造函数 + 默认析构函数 + 成员类内初始值只能使用常量表达式初始化（或对应的 constexpr 构造函数）；</li>
<li><span class="pn">Page 268</span>constexpr 构造函数用于生成 constexpr 对象，以及 constexpr 函数的参数或返回类型。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Debug</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token comment" spellcheck="true">// 必须同时符合构造函数和 constexpr 函数的要求，因此一般没有函数体；</span>
  <span class="token comment" spellcheck="true">/**
   * 1、构造函数体必须为空；
   * 2、初始值列表只能由常量表达式来赋值； 
   */</span>
  <span class="token keyword">constexpr</span> <span class="token function">Debug</span><span class="token punctuation">(</span><span class="token keyword">bool</span> b <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">hw</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">io</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">other</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">constexpr</span> <span class="token function">Debug</span><span class="token punctuation">(</span><span class="token keyword">bool</span> h<span class="token punctuation">,</span> <span class="token keyword">bool</span> i<span class="token punctuation">,</span> <span class="token keyword">bool</span> o<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">hw</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">io</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">other</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">constexpr</span> <span class="token keyword">bool</span> <span class="token function">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> hw <span class="token operator">||</span> io <span class="token operator">||</span> other<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">set_io</span><span class="token punctuation">(</span><span class="token keyword">bool</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span> io <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">set_hw</span><span class="token punctuation">(</span><span class="token keyword">bool</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span> hw <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">set_other</span><span class="token punctuation">(</span><span class="token keyword">bool</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span> other <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">bool</span> hw<span class="token punctuation">;</span>
  <span class="token keyword">bool</span> io<span class="token punctuation">;</span>
  <span class="token keyword">bool</span> other<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>agv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">constexpr</span> Debug <span class="token function">prod</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="85">
<li><span class="pn">Page 269</span>类的静态成员函数没有 this 指针，因此也无法被声明为 const 函数（const 函数主要用来修饰隐式的 this 指针）。静态成员可以通过类对象进行访问，或通过类作用域符。由于静态成员不属于任何一个对象，因此它们并不是在创建类对象时被定义的。这意味着我们需要在类的<strong>外部</strong>（对于非 const 静态成员而言；const 成员可以直接在类内部设置默认初始值）定义和初始化每一个静态成员，并只能初始化一次。</li>
<li><span class="pn">Page 271</span>静态成员可以是不完全类型，也可以作为默认实参来使用（因为其仅属于类，而不属于任一对象）；<strong>非常量静态成员如果不在类外初始化，则会丢失该符号</strong>；因此类内只是对编译器做声明之用。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Bar</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> Bar mem<span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 非常量静态成员只能在类外定义；</span>
Bar Bar<span class="token operator">::</span>mem <span class="token operator">=</span> <span class="token function">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>agv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Bar bar<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="87">
<li><span class="pn">Page 281</span>可以通过名为 rdstate() 的方法返回 std::basic_ios 对象的当前流状态（iostate）。</li>
<li><span class="pn">Page 282</span>IO 缓冲区刷新的几种方式：</li>
</ol>
<ul>
<li>main 函数结束；</li>
<li>缓冲区满；</li>
<li>endl 主动刷新；</li>
<li>使用 std::unitbuf / std::nounitbuf 设置流状态来清空缓冲区（std::cout &lt;&lt; std::unitbuf）；</li>
<li>使用 std::flush 刷新缓冲区（std::cout &lt;&lt; std::flush）；</li>
<li>关联流刷新（cin/cerr）-&gt; cout；</li>
</ul>
<ol start="89">
<li><span class="pn">Page 283</span>流的关联：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>agv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>ofstream <span class="token function">os</span><span class="token punctuation">(</span><span class="token string">"text.txt"</span><span class="token punctuation">,</span> std<span class="token operator">::</span>ios_base<span class="token operator">::</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 每当试图从 std::cin 读取数据时都会刷新 std::ofstream（实时写入）；</span>
  std<span class="token operator">::</span>cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>os<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">char</span> c<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>cin <span class="token operator">>></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// os &lt;&lt; c &lt;&lt; std::flush;</span>
      <span class="token operator">*</span>std<span class="token operator">::</span>cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 返回指向绑定流的指针；</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 程序正常退出后 os 才会将数据写入文件；</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>agv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>ofstream <span class="token function">os</span><span class="token punctuation">(</span><span class="token string">"text.txt"</span><span class="token punctuation">,</span> std<span class="token operator">::</span>ios_base<span class="token operator">::</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">char</span> c<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>cin <span class="token operator">>></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
      os <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="90">
<li><span class="pn">Page 285</span>两种打开流的方式：std::basic_fstream 的构造函数 / std::basic_fstream 对象的 open 方法。</li>
<li><span class="pn">Page 285</span>当一个 std::fstream 对象被销毁时，std::basic_fstream::close() 会被自动调用。</li>
<li><span class="pn">Page 286</span>常用文件模式：</li>
</ol>
<ul>
<li>std::ios_base::in；</li>
<li>std::ios_base::out；</li>
<li>std::ios_base::app(append)；</li>
<li>std::ios_base::ate(at end)；</li>
<li>std::ios_base::trunc；</li>
<li>std::ios_base::binary；</li>
</ul>
<ol start="93">
<li><span class="pn">Page 288</span>istringstream 的使用技巧：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>agv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  string line<span class="token punctuation">,</span> word<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 每次读取一行输入；</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    istringstream <span class="token function">record</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 获取每行的首个单词；</span>
      record <span class="token operator">>></span> word<span class="token punctuation">;</span>
      cout <span class="token operator">&lt;&lt;</span> word <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<br><div class="article-bottom-meta"><span class="post-meta">Last built on<time itemprop="dateModified" datetime="2020-04-10T05:20:03.000Z"> 2025 / 04 / 08, 10:31:32</time></span></div></div></article><br><span class="next-post"><a href="/2020/04/12/Primer-C-完全笔记（第 9-13 章）/" itemprop="url">下一篇 ⇒</a></span><span class="prev-post"><a href="/2020/03/12/WebAssembly-Summit-2020-—-议题深度解析（下）/" itemprop="url">⇐ 上一篇</a></span><br><section id="comments"><h4>评论 | Comments</h4><br><div class="comment-container"><div class="loading-mask">Loading ...</div><script src="https://utteranc.es/client.js" repo="Becavalier/utterances-comments" issue-term="title" label="[Comment]" theme="github-light" crossorigin="anonymous" async></script></div></section><br><br></main><script src="/scripts/index.js" type="text/javascript"></script></body></html>