<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>《Effective C++ 3th》读书笔记（二） | 曜彤.手记</title><meta name="baidu-site-verification" content="codeva-P9jyH0b1lv"><meta name="description" content="文接上回，本文将继续记录常见的 C++ 高效开发范式，这些范式均总结于《Effective C++ 3th》一书。由于该书出版年代较为久远，因此对于书中条款的不适用之处，作者将尽量予以纠正并给出自己的建议。"><meta name="generator" content="曜彤.手记"><meta name="keywords" content="博客, C++, C, Rust, Web, Java, IT, 编程, 开发, Android, Python, MySQL, 科技, 黑客, 技术, Javascript, 云, 大数据, 计算, 机器学习, AI, 人工智能, 创业, 产品, 公司, WebAssembly, Wasm"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.jpg"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.jpg"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.jpg"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.jpg"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.jpg"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.jpg"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.jpg"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.jpg"><link rel="apple-touch-icon" sizes="196x196" href="/images/apple-touch-icon-196x196.jpg"><link rel="apple-touch-icon" sizes="310x310" href="/images/apple-touch-icon-310x310.jpg"><link href="/images/splash/iphone5_splash.png" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphone6_splash.png" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphoneplus_splash.png" media="(device-width: 621px) and (device-height: 1104px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/iphonex_splash.png" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/iphonexr_splash.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphonexsmax_splash.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/ipad_splash.png" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro1_splash.png" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro3_splash.png" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro2_splash.png" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="128x128" href="/images/favicon-128.png"><link rel="icon" type="image/png" sizes="196x196" href="/images/favicon-196x196.png"><meta name="msapplication-TileColor" content="#FFFFFF"><meta name="msapplication-TileImage" content="mstile-144x144.png"><meta name="msapplication-square70x70logo" content="mstile-70x70.png"><meta name="msapplication-square150x150logo" content="mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="mstile-310x150.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"><link rel="manifest" href="/manifest.webmanifest"><link rel="alternate" type="application/atom+xml" title="Atom 0.3" href="/atom.xml"><link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body itemscope itemtype="https://schema.org/WebPage"><div class="canvas-containter"><span>X</span></div><header itemscope itemtype="https://schema.org/WPHeader"><div class="logo"></div><h1 class="title"><a href="/" alt="曜彤.手记" title="曜彤.手记" itemprop="headline">曜彤.手记</a><a title="Atom 0.3" target="__blank" href="/atom.xml" class="rss"><img src="/images/rss.png"></a></h1><p itemprop="description" class="description">随记，关于互联网技术、产品与创业</p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name" class="menu-item"><a href="/ " alt="首页" title="首页" itemprop="url">首页</a></li><li itemprop="name" class="menu-item"><a href="/articles" alt="文章" title="文章" itemprop="url">文章</a></li><li itemprop="name" class="menu-item"><a href="/readings" alt="阅读" title="阅读" itemprop="url">阅读</a></li><li itemprop="name" class="menu-item"><a href="/cards" alt="快记" title="快记" itemprop="url">快记</a></li><li itemprop="name" class="menu-item"><a href="/tags" alt="标签" title="标签" itemprop="url">标签</a></li><li itemprop="name" class="menu-item"><a href="/about" alt="关于" title="关于" itemprop="url">关于</a></li></ul></nav><div class="dynamic-slot"></div><div class="toc-body"><div class="bookmark"></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1"><span class="toc-text">继承与面向对象设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="toc-text">模板与泛型编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E5%88%B6-new-%E5%92%8C-delete"><span class="toc-text">定制 new 和 delete</span></a></li></ol></div><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><script src="https://shadow.elemecdn.com/npm/zoomage.js@latest/dist/zoomage.min.js" type="text/javascript"></script><script src="https://shadow.elemecdn.com/npm/axios@0.18.0/dist/axios.min.js" type="text/javascript"></script><script src="/scripts/post.js" type="text/javascript"></script><div class="touch-top"><span></span></div><article post-id="《Effective C++ 3th》读书笔记（二）" class="full article-post"><h1 itemprop="headline" class="align-center">《Effective C++ 3th》读书笔记（二）</h1><div class="content"><div class="article-meta"><span class="post-meta"><br>Created on<time itemprop="dateCreated" datetime="2020-04-26T13:28:21.000Z"> 2020 / 04 / 26, 21:28:21</time></span><span class="page-tag-anchor"><a href="/tags/Cpp" itemprop="url">#Cpp</a>&nbsp;&nbsp;</span></div><p>文接上回，本文将继续记录常见的 C++ 高效开发范式，这些范式均总结于《Effective C++ 3th》一书。由于该书出版年代较为久远，因此对于书中条款的不适用之处，作者将尽量予以纠正并给出自己的建议。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ol start="49">
<li><span class="pn">Page 148</span>尽量延后变量定义的出现时机，并且<strong>以构造初始化代替先默认构造再赋值</strong>。这样可以增加程序的清晰度并改善程序效率。</li>
<li><span class="pn">Page 155</span>如果可以，应该避免使用转型，尤其是 dynamic_cast，<strong>可以选择 virtual 函数或保存派生类对象智能指针的方式加以避免</strong>；如果转型是必要的，试着将它隐藏于某个函数背后，而不需要客户自己去调用（对用户友好）；尽可能使用 C++ 的显式转型，以便于代码审查。</li>
<li><span class="pn">Page 158</span>避免返回的引用、指针以及迭代器指向对象内部的成员。遵守这个条款可以增加类的封装性，以避免出现类内成员比类对象生存期长的问题。若需要返回引用，请确保引用的常量性（const）与所指向成员的可访问性（private）保持一致。</li>
<li><span class="pn">Page 160</span>保证异常安全的两个条件：</li>
</ol>
<ul>
<li>不泄露任何资源（利用 RAII，将资源以对象的形式进行管理，然后通过对象的析构函数来释放）；</li>
<li>不允许数据被破坏（原子性与事务）；</li>
</ul>
<ol start="53">
<li><span class="pn">Page 161</span>异常安全函数提供以下三个保证之一：</li>
</ol>
<ul>
<li><strong>基本承诺</strong>：如果异常被抛出，程序内的任何事物仍然保持在<strong>有效状态</strong>（状态不唯一，合法即可）下。没有任何数据或对象会因此而败坏。所有对象都处于一种内部前后一致的状态（对异常的补偿，比如用默认资源占位）；</li>
<li><strong>强烈保证</strong>：如果异常被抛出，程序状态不改变。即：<strong>函数成功就是完全成功，失败则回退到调用函数之前的状态</strong>；</li>
<li><strong>不抛出异常（nothrow）保证</strong>：承诺绝不抛出异常；</li>
</ul>
<ol start="54">
<li><span class="pn">Page 162</span>不要为了表示某件事情发生而改变对象状态，除非那件事情真的发生了。</li>
<li><span class="pn">Page 165</span>一个软件系统要么具备异常安全性，要么就完全不具备，没有所谓的“局部异常安全系统”。</li>
<li><span class="pn">Page 166</span>结合 Pimpl 与 copy-and-swap 来提供一定的异常安全性保证（一般可以提供强烈保证）：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> NS <span class="token punctuation">{</span>
  <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 实现类；</span>
    <span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
   <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">v</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token function">A</span><span class="token punctuation">(</span>A<span class="token operator">&amp;&amp;</span> o<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> v <span class="token operator">=</span> o<span class="token punctuation">.</span>v<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    A<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>A<span class="token operator">&amp;&amp;</span> o<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> v <span class="token operator">=</span> o<span class="token punctuation">.</span>v<span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span> v <span class="token operator">=</span> o<span class="token punctuation">.</span>v<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">int</span> <span class="token function">getV</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> v<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">setV</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span> v <span class="token operator">=</span> val<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 对外接口类；</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">></span> impl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 隐藏指向实现类的指针；</span>
   <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">impl</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>A<span class="token operator">></span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">operator</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> impl<span class="token operator">-</span><span class="token operator">></span><span class="token function">getV</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    B<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">using</span> spA <span class="token operator">=</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">namespace</span> std <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 被交换对象需要有 noexcept 的移动构造函数；</span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span> <span class="token keyword">void</span> swap<span class="token operator">&lt;</span>NS<span class="token operator">::</span>spA<span class="token operator">></span><span class="token punctuation">(</span>NS<span class="token operator">::</span>spA<span class="token operator">&amp;</span> x<span class="token punctuation">,</span> NS<span class="token operator">::</span>spA<span class="token operator">&amp;</span> y<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> x<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
NS<span class="token operator">::</span>B<span class="token operator">&amp;</span> NS<span class="token operator">::</span>B<span class="token operator">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 注意全特化 swap 定义和调用处的顺序；</span>
  <span class="token keyword">auto</span> copyImpl <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>A<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">*</span>impl<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 当前实现体拷贝；</span>
  copyImpl<span class="token operator">-</span><span class="token operator">></span><span class="token function">setV</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span>impl<span class="token operator">-</span><span class="token operator">></span><span class="token function">getV</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">using</span> std<span class="token operator">::</span>swap<span class="token punctuation">;</span>
  <span class="token function">swap</span><span class="token punctuation">(</span>copyImpl<span class="token punctuation">,</span> impl<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 交换；</span>
  <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  NS<span class="token operator">::</span>B <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  y <span class="token operator">=</span> x<span class="token punctuation">;</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="57">
<li><span class="pn">Page 171</span>将大多数 inlining <strong>限制在小型、被频繁调用的函数</strong>身上。这可使日后的调试过程和二进制升级更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。</li>
<li><span class="pn">Page 175</span>尽量让头文件能够“自我满足”，万一做不到则让它与其他文件内的声明式（非定义式）相依赖。简单的设计策略：</li>
</ol>
<ul>
<li>如果使用对象<strong>引用</strong>或<strong>指针</strong>（不需要提前自动类定义式）可以完成任务，就不要使用对象本身；</li>
<li>如果能够，尽量以类声明式替换类定义式；</li>
<li>为声明式和定义式提供不同的头文件；</li>
</ul>
<ol start="59">
<li><span class="pn">Page 180</span>支持“编译依存性最小化”的一般构想是：相依于声明式而非定义式。采用 Handle Classes 和 Interface Classes（对应对象只能以指针或引用形式使用）两种模式。</li>
<li><span class="pn">Page 180</span>头文件应该以“<strong>完全且仅有声明式</strong>”的形式存在。这种做法不论是否涉及 template 都适用。</li>
</ol>
<h3 id="继承与面向对象设计"><a href="#继承与面向对象设计" class="headerlink" title="继承与面向对象设计"></a>继承与面向对象设计</h3><ol start="61">
<li><span class="pn">Page 187</span>“public 继承”意味 <strong>is-a</strong>。适用于基类身上的每一件事也一定适用于派生类身上，因为每一个派生类也都是一个基类对象。</li>
<li><span class="pn">Page 193</span>派生类内的名称会覆盖基类内的名称，可以使用 using 声明或转交函数来解决这个问题。</li>
<li><span class="pn">Page 194</span>声明一个纯虚函数的目的是为了让派生类只继承函数<strong>接口</strong>。声明非纯虚函数是为了让派生类继承该函数的<strong>接口和默认实现</strong>，但常见的问题是：对于没有覆盖基类虚函数的派生类将会自动使用基类的默认实现，而无法被控制。而声明一般的成员函数，则意味着该函数不打算在派生类中有不同的行为，即继承<strong>接口与一份强制实现</strong>。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">v</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 利用纯虚函数为派生类提供默认实现；</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> A<span class="token operator">::</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"default implementation."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 纯虚函数的默认实现；</span>
<span class="token keyword">struct</span> B <span class="token operator">:</span> <span class="token keyword">public</span> A <span class="token punctuation">{</span>
  <span class="token keyword">using</span> A<span class="token operator">::</span>A<span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> A<span class="token operator">::</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 默认实现需要被主动调用；</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  B <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  x<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="64">
<li><span class="pn">Page 203</span><strong>NVI</strong>（Non-Virtual Interface）手法（<strong>模板设计模式</strong>在 C++ 下的一种实现形式。其他方式还可以通过诸如“<strong>元编程</strong>”来实现该设计模式）：通过公有的普通成员函数（固定模板）间接调用私有的虚函数（核心实现部分采用不同的派生类实现）。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 私有虚函数，隐藏核心实现；</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"do sth before."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 调用核心实现（不同派生类不同）；</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"do sth after."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token keyword">public</span> A <span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="65">
<li><span class="pn">Page 209</span>将虚函数替换为函数指针成员变量指向外界的函数实现，这是策略设计模式的一种特殊形式。将继承体系内的虚函数替换为另一个继承体系内的虚函数（以私有指针的形式指向该继承体系的类对象），这是策略设计模式的传统实现手法。</li>
<li><span class="pn">Page 211</span>任何情况下都不应该重新定义一个继承而来的非虚函数。</li>
<li><span class="pn">Page 215</span>绝对<strong>不要重新定义一个继承而来的缺省参数值</strong>，因为<strong>缺省参数值都是静态绑定，而虚函数却是动态绑定</strong>的，因此某些情况下默认参数与实际对象可能并不是正确对应的：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> A <span class="token punctuation">{</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A"</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> B <span class="token operator">:</span> <span class="token keyword">public</span> A <span class="token punctuation">{</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> override <span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B"</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  B b<span class="token punctuation">;</span>
  A<span class="token operator">*</span> a <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>
  a<span class="token operator">-</span><span class="token operator">></span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// A 的静态默认参数传递给了 B 的 foo 函数；</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="68">
<li><span class="pn">Page 218</span>组合意味着 “has-a”（拥有）或 “is-implemented-in-terms-of”（根据某物实现出），而 public 继承意味着 “is-a”。</li>
<li><span class="pn">Page 220</span>private 继承意味着“<strong>根据某物实现而得</strong>”。应尽可能使用组合，必要时（比如：派生类需要访问基类的 protected 成员时、考虑 EBO 的内存空间优化时）才使用 private 继承。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> Timer <span class="token punctuation">{</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">onTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 使用组合；</span>
  <span class="token keyword">struct</span> ATimer <span class="token operator">:</span> <span class="token keyword">public</span> Timer <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">onTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ATimer"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  ATimer timer<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="70">
<li><span class="pn">Page 222</span><strong>空类对象（无 non-static 成员）的占用大小为1字节</strong>，因此对于组合和 private 继承来说，后者对空间的利用率会稍高。</li>
<li><span class="pn">Page 229</span>多重继承的一个较为合理的应用场景：<strong>使用公有继承某个接口类，使用私有继承某个实现类</strong>。</li>
<li><span class="pn">Page 230</span>虚继承会增加应用大小、运行速度以及初始化复杂度等成本。如果虚基类不带有任何数据（不需要底层派生类为其进行初始化），将是最具实用价值的情况。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> A <span class="token punctuation">{</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
  <span class="token function">A</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">v</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> B <span class="token operator">:</span> <span class="token keyword">virtual</span> <span class="token keyword">public</span> A <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> C <span class="token operator">:</span> <span class="token keyword">virtual</span> <span class="token keyword">public</span> A <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> D <span class="token operator">:</span> <span class="token keyword">public</span> B<span class="token punctuation">,</span> <span class="token keyword">public</span> C <span class="token punctuation">{</span>
  <span class="token function">D</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h3><ol start="73">
<li><span class="pn">Page 231</span><strong>C++ 模板机制自身是一部完整的图灵机</strong>，它可被用来计算任何可计算的值，因此出现了模板元编程 TMP（在编译器内执行并于编译完成时停止执行）。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">int</span> N<span class="token operator">></span> 
<span class="token keyword">struct</span> Factorial <span class="token punctuation">{</span>
  <span class="token keyword">enum</span> <span class="token punctuation">{</span> val <span class="token operator">=</span> Factorial<span class="token operator">&lt;</span>N<span class="token number">-1</span><span class="token operator">></span><span class="token operator">::</span>val <span class="token operator">*</span> N <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span>
<span class="token keyword">struct</span> Factorial<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword">enum</span> <span class="token punctuation">{</span> val <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> Factorial<span class="token operator">&lt;</span><span class="token number">4</span><span class="token operator">></span><span class="token operator">::</span>val <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 编译时求值；</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="74">
<li><span class="pn">Page 235</span>类和模板都支持接口和多态。对类而言接口是显式的，以函数签名为中心；多态则是通过虚函数发生于运行期。对模板参数而言，接口是隐式的，基于有效表达式。多态则是通过模板具现化和函数重载解析发生于编译期。</li>
<li><span class="pn">Page 239</span>使用关键字 typename 标识嵌套从属类型名称；但<strong>不得在类继承列表及成员初始化列表中修饰基类类型</strong>。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">struct</span> A <span class="token punctuation">{</span>
  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">></span> v <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">typename</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>const_iterator headIter<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 模板内使用嵌套从属类型名时需要加 typename；</span>
  <span class="token function">A</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">></span> v<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">v</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span> headIter <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  A<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">a</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>a<span class="token punctuation">.</span>headIter <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="76">
<li><span class="pn">Page 242</span>通常情况下，C++ 不会在模板化的基类内隐式地寻找成员（因为基类实际具现化的接口可能由于模板全特化等原因而不稳定），因此派生类需要在调用处显式地通过 “<b>this-&gt;</b>” 指明想要在模板基类内寻找的名称。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">struct</span> A <span class="token punctuation">{</span>
  T <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">struct</span> B <span class="token operator">:</span> <span class="token keyword">public</span> A<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 需要通过 “this” 显式调用，若使用 “A&lt;T>::foo()” 会导致虚函数动态调用失效；</span>
  <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  B<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="77">
<li><span class="pn">Page 249</span>模板生成多个类和多个函数，所以任何模板代码都不该与某个造成膨胀的模板参数产生相依关系。因非类型模板参数造成的代码膨胀，往往可以消除，做法是<strong>以函数参数或类成员变量替换模板参数（私有继承，并在基类模板中去掉类型模板参数）</strong>；因类型参数造成的代码膨胀，往往可以降低，做法是<strong>让带有完全相同二进制表述的具体类型共享实现代码</strong>。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">struct</span> A <span class="token punctuation">{</span>
  size_t <span class="token function">foo</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> n<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> size_t n<span class="token operator">></span>
<span class="token keyword">struct</span> B <span class="token operator">:</span> <span class="token keyword">private</span> A<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword">using</span> A<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>foo<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 让基类的同名函数可见；</span>
  size_t <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">foo</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  B<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="78">
<li><span class="pn">Page 254</span>模板泛型编程：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> A <span class="token punctuation">{</span> 
  <span class="token keyword">virtual</span> <span class="token keyword">char</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token string">'A'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> 
  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> B <span class="token operator">:</span> <span class="token keyword">public</span> A <span class="token punctuation">{</span> 
  <span class="token keyword">char</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token string">'B'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> 
  <span class="token operator">~</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">SmartPointer</span> <span class="token punctuation">{</span>
  T<span class="token operator">*</span> rp <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">SmartPointer</span><span class="token punctuation">(</span>T<span class="token operator">*</span> rp<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">rp</span><span class="token punctuation">(</span>rp<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">SmartPointer</span><span class="token punctuation">(</span><span class="token keyword">const</span> SmartPointer<span class="token operator">&amp;</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 非泛化的拷贝构造函数；</span>
  SmartPointer<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> SmartPointer<span class="token operator">&amp;</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">const</span> SmartPointer<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> <span class="token keyword">operator</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  T<span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> rp<span class="token punctuation">;</span> <span class="token punctuation">}</span>

  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> U<span class="token operator">></span>
  <span class="token function">SmartPointer</span><span class="token punctuation">(</span><span class="token keyword">const</span> SmartPointer<span class="token operator">&lt;</span>U<span class="token operator">></span><span class="token operator">&amp;</span> o<span class="token punctuation">)</span> <span class="token operator">:</span>  <span class="token comment" spellcheck="true">// 模板拷贝构造函数；</span>
    <span class="token function">rp</span><span class="token punctuation">(</span><span class="token keyword">static_cast</span><span class="token operator">&lt;</span>T<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>o<span class="token operator">-</span><span class="token operator">></span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 根据 U 生成 T；</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  A a<span class="token punctuation">;</span>
  B b<span class="token punctuation">;</span>
  <span class="token keyword">auto</span> bp <span class="token operator">=</span> SmartPointer<span class="token operator">&lt;</span>B<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
  SmartPointer<span class="token operator">&lt;</span>A<span class="token operator">></span> ap <span class="token operator">=</span> bp<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 与原始指针保持一致，支持隐式（implicit）转换；</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> ap<span class="token operator">-</span><span class="token operator">></span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 'B'；</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="79">
<li><span class="pn">Page 254</span>请使用成员函数模板生成“可接受所有兼容类型”的函数。如果声明成员函数模板用于“泛化拷贝构造”或“泛化赋值操作”，你还是需要声明正常的拷贝构造函数和拷贝赋值操作符。</li>
<li><span class="pn">Page 258</span>由于<strong>在模板参数的推导过程中，编译器不会将隐式类型转换函数纳入考虑</strong>。因此在为类模板编写需要带有类型转换的 operator= 运算符时，需要使用<strong>内联的 friend 函数</strong>（friend 不属于对象，以便于接受两个运算数；内联可以解决链接器找不到符号的问题）。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">struct</span> A <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 友元函数的具象化跟随模板类的具象化过程，因此其中一个参数的 T 确定后，则整个函数便被确定；</span>
  <span class="token keyword">friend</span> <span class="token keyword">const</span> A <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> A<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> lhs<span class="token punctuation">.</span>v <span class="token operator">+</span> rhs<span class="token punctuation">.</span>v<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  T v<span class="token punctuation">;</span>
  <span class="token function">A</span><span class="token punctuation">(</span>T v<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">v</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">/*
template&lt;typename T>
const A&lt;T> operator+(const A&lt;T>&amp; lhs, const A&lt;T>&amp; rhs) {  // 无法推导；跟模板类没有直接关系，需要从参数往候选类正向推导；
  return lhs.v + rhs.v;
};
*/</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  A<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">auto</span> z <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> z<span class="token punctuation">.</span>v <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="81">
<li><span class="pn">Page 260</span>C++ 五类迭代器的“卷标结构”：</li>
</ol>
<p><img src="1.png"></p>
<ol start="82">
<li><span class="pn">Page 260</span>traits 模板类主要用于在编译期（<strong>借助重载和 traits 模板类</strong>）/运行时（借助 typeid）来获取某些类型信息。比如：std::iterator_traits 通过自定义类型内的 iterator_category 来获取类型信息。对于内置指针类型，则使用其偏特化版本，并将其指定为“随机访问迭代器”类型。其他 traits 类大同小异。（traits + 重载 = 一种 TMP）</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span>
<span class="token keyword">struct</span> IterWrapper <span class="token punctuation">{</span>
  T iter<span class="token punctuation">;</span>
  <span class="token function">IterWrapper</span><span class="token punctuation">(</span>T iter<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">iter</span><span class="token punctuation">(</span>iter<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 主调函数;</span>
  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">overloadedFoo</span><span class="token punctuation">(</span><span class="token keyword">typename</span> std<span class="token operator">::</span>iterator_traits<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span><span class="token function">iterator_category</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 重载部分的候选函数（编译时选择）;</span>
  <span class="token keyword">void</span> <span class="token function">overloadedFoo</span><span class="token punctuation">(</span>std<span class="token operator">::</span>random_access_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Random Access Iterator."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">overloadedFoo</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Forward Iterator."</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  IterWrapper<span class="token operator">&lt;</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator<span class="token operator">></span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="83">
<li><span class="pn">Page 270</span>TMP 模板元编程的优势：</li>
</ol>
<ul>
<li>可以将工作由运行时移至编译器，因而得以实现早起错误侦测和更高的执行效率；</li>
<li>可被用来生成“基于政策选择组合（policy-based）”的客户定制代码，也可以用来避免生成对某些特殊类型并不合适的代码；</li>
</ul>
<h3 id="定制-new-和-delete"><a href="#定制-new-和-delete" class="headerlink" title="定制 new 和 delete"></a>定制 new 和 delete</h3><ol start="84">
<li><span class="pn">Page 279</span>实现类专属的 new-handlers：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> HandlerHolder <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 保存旧的 handler，析构时自动重置；</span>
  <span class="token keyword">explicit</span> <span class="token function">HandlerHolder</span><span class="token punctuation">(</span>std<span class="token operator">::</span>new_handler nh<span class="token punctuation">)</span> <span class="token punctuation">{</span> handler <span class="token operator">=</span> nh<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token operator">~</span><span class="token function">HandlerHolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token function">HandlerHolder</span><span class="token punctuation">(</span><span class="token keyword">const</span> HandlerHolder<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
  HandlerHolder<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> HandlerHolder<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  std<span class="token operator">::</span>new_handler handler<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> A <span class="token punctuation">{</span>
  <span class="token keyword">static</span> std<span class="token operator">::</span>new_handler <span class="token function">set_new_handler</span><span class="token punctuation">(</span>std<span class="token operator">::</span>new_handler p<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 存储新的 handler，返回旧的 handler，以 RAII 的形式管理；</span>
    <span class="token keyword">auto</span> o <span class="token operator">=</span> currentHandler<span class="token punctuation">;</span>
    currentHandler <span class="token operator">=</span> p<span class="token punctuation">;</span>
    <span class="token keyword">return</span> o<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    HandlerHolder <span class="token function">h</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>currentHandler<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// RAII;</span>
    <span class="token keyword">return</span> <span class="token operator">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">static</span> std<span class="token operator">::</span>new_handler currentHandler<span class="token punctuation">;</span>
  <span class="token keyword">double</span> arr<span class="token punctuation">[</span><span class="token number">100000000000000l</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>new_handler A<span class="token operator">::</span>currentHandler <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  A<span class="token operator">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Memory Allocation Failed!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">auto</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="85">
<li><span class="pn">Page 282</span>何时使用自定义的内存分配器：</li>
</ol>
<ul>
<li>为了检测运用错误；</li>
<li>为了收集动态分配内存的使用统计信息；</li>
<li>为了增加分配和归还的速度；</li>
<li>为了降低缺省内存管理器带来的空间额外消耗；</li>
<li>为了弥补缺省内存管理器中的非最佳齐位；</li>
<li>为了将相关对象集中；</li>
<li>为了获得非传统行为；</li>
</ul>
<ol start="86">
<li><span class="pn">Page 288</span>operator new 及 operator delete 的重写要点：</li>
</ol>
<ul>
<li>operator new 应该包含一个无穷循环，并在里面尝试分配内存，如果无法满足，则调用 new-handler；它同时也应该有处理 0 字节申请的能力。类专属版本还应该处理“比正确大小更大的错误申请（交由 std::operator new）”；</li>
<li>operator delete 应该在收到 nullptr 时不做任何事情；类专属版本还应该处理“比正确大小更大的错误申请（交由 std::operator delete）”；</li>
</ul>
<ol start="87">
<li><span class="pn">Page 293</span>* <strong>当你写一个自定义的 placement operator new 时，也需要写出对应的 placement operator delete</strong>，否则可能会发生隐式（比如在类对象构造函数抛异常时，编译器需要自动调用具有相同参数的 delete operator 来释放内存，否则内存无法被释放）的内存泄露；</li>
</ol>
<ul>
<li>当声明 placement new 和 placement delete 时，请确保不要覆盖标准库的版本；</li>
</ul>
<br><div class="article-bottom-meta"><span class="post-meta">Last built on<time itemprop="dateModified" datetime="2020-04-26T13:28:21.000Z"> 2025 / 03 / 31, 15:59:32</time></span></div></div></article><br><span class="next-post"><a href="/2020/04/27/C-空基类优化（EBO）与私有继承/" itemprop="url">下一篇 ⇒</a></span><span class="prev-post"><a href="/2020/04/26/C-未限定名字查找与-ADL/" itemprop="url">⇐ 上一篇</a></span><br><section id="comments"><h4>评论 | Comments</h4><br><div class="comment-container"><div class="loading-mask">Loading ...</div><script src="https://utteranc.es/client.js" repo="Becavalier/utterances-comments" issue-term="title" label="[Comment]" theme="github-light" crossorigin="anonymous" async></script></div></section><br><br></main><script src="/scripts/index.js" type="text/javascript"></script></body></html>