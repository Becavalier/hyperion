<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>《Primer C++ 5th》完全笔记（第 9-13 章） | 曜彤.手记</title><meta name="description" content="文接上回，本文将记录全书第9-13章中出现的知识点，这几章主要介绍了 C++ 中有关顺序容器、泛型算法、关联容器、动态内存以及拷贝控制等相关内容。注意这些知识点的记录完全遵循我个人的想法，因此也仅适配我个人的情况和需求，未记录的其他知识点并非不重要。"><meta name="generator" content="曜彤.手记"><meta name="about" content="[object Object]"><meta name="keywords" content="博客, C++, C, Rust, Web, Java, IT, 编程, 开发, Android, Python, MySQL, 科技, 黑客, 技术, Javascript, 云, 大数据, 计算, 机器学习, AI, 人工智能, 创业, 产品, 公司, WebAssembly, Wasm"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.jpg"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.jpg"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.jpg"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.jpg"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.jpg"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.jpg"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.jpg"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.jpg"><link rel="apple-touch-icon" sizes="196x196" href="/images/apple-touch-icon-196x196.jpg"><link rel="apple-touch-icon" sizes="310x310" href="/images/apple-touch-icon-310x310.jpg"><link href="/images/splash/iphone5_splash.png" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphone6_splash.png" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphoneplus_splash.png" media="(device-width: 621px) and (device-height: 1104px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/iphonex_splash.png" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/iphonexr_splash.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphonexsmax_splash.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/ipad_splash.png" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro1_splash.png" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro3_splash.png" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro2_splash.png" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="128x128" href="/images/favicon-128.png"><link rel="icon" type="image/png" sizes="196x196" href="/images/favicon-196x196.png"><meta name="msapplication-TileColor" content="#FFFFFF"><meta name="msapplication-TileImage" content="mstile-144x144.png"><meta name="msapplication-square70x70logo" content="mstile-70x70.png"><meta name="msapplication-square150x150logo" content="mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="mstile-310x150.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"><link rel="manifest" href="/manifest.webmanifest"><link rel="alternate" type="application/atom+xml" title="Atom 0.3" href="/atom.xml"><link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body itemscope itemtype="https://schema.org/WebPage"><div class="canvas-containter"><span>X</span></div><header itemscope itemtype="https://schema.org/WPHeader"><div class="logo"></div><h1 class="title"><a href="/" alt="曜彤.手记" title="曜彤.手记" itemprop="headline">曜彤.手记</a><a title="Atom 0.3" target="__blank" href="/atom.xml" class="rss"><img src="/images/rss.png"></a></h1><p itemprop="description" class="description">随记，关于互联网技术、产品与创业</p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name" class="menu-item"><a href="/ " alt="首页" title="首页" itemprop="url">首页</a></li><li itemprop="name" class="menu-item"><a href="/articles" alt="文章" title="文章" itemprop="url">文章</a></li><li itemprop="name" class="menu-item"><a href="/tags" alt="标签" title="标签" itemprop="url">标签</a></li><li itemprop="name" class="menu-item"><a href="/about" alt="关于" title="关于" itemprop="url">关于</a></li></ul></nav><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><script src="https://shadow.elemecdn.com/npm/zoomage.js@latest/dist/zoomage.min.js" type="text/javascript"></script><script src="https://shadow.elemecdn.com/npm/axios@0.18.0/dist/axios.min.js" type="text/javascript"></script><script src="/scripts/post.js" type="text/javascript"></script><div class="touch-top"><span></span></div><article post-id="《Primer C++ 5th》完全笔记（第 9-13 章）" class="full"><h1 itemprop="headline" class="align-center">《Primer C++ 5th》完全笔记（第 9-13 章）</h1><div class="content"><div class="article-meta"><span class="post-meta"><br>Created on<time itemprop="dateCreated" datetime="2020-04-12T09:28:14.000Z"> 2020 / 04 / 12, 17:28:14</time></span><span class="page-tag-anchor"><a href="/tags/Cpp" itemprop="url">#Cpp</a>&nbsp;&nbsp;</span></div><p>文接上回，本文将记录全书第9-13章中出现的知识点，这几章主要介绍了 C++ 中有关顺序容器、泛型算法、关联容器、动态内存以及拷贝控制等相关内容。注意这些知识点的记录完全遵循我个人的想法，因此也仅适配我个人的情况和需求，未记录的其他知识点并非不重要。</p>
<ol start="94">
<li>(Page：292) 常用顺序容器类型：</li>
</ol>
<ul>
<li><strong>vector</strong>：可变大小数组，支持随机访问，尾部以外的位置插入或删除数据可能很慢；</li>
<li><strong>deque</strong>：双端队列。支持随机访问，在头尾插入删除数据很快；</li>
<li><strong>list</strong>：双向链表。只支持 双向顺序访问，任何位置插入/删除数据都很快；</li>
<li><strong>forward_list</strong>：单向链表。单向顺序访问，任何位置插入/删除数据都很快；</li>
<li><strong>array</strong>：固定大小数组；</li>
<li><strong>string</strong>：保存字符，尾部插入/删除速度快；</li>
</ul>
<ol start="95">
<li><span class="pn">Page 295</span>常用的容器类型别名：iterator、const_iterator、size_type、difference_type、value_type、reference、const_reference；</li>
<li><span class="pn">Page 299</span>可以将普通的 iterator 赋值给 const_iterator，反之则不行。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> x <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>const_iterator it <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ol start="97">
<li><span class="pn">Page 300</span>通过迭代器进行容器元素拷贝：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">></span> snippets <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"an"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 对于输入范围的每一个元素，都会隐式调用 string 的构造函数；</span>
std<span class="token operator">::</span>forward_list<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">words</span><span class="token punctuation">(</span>snippets<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> snippets<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ol start="98">
<li><span class="pn">Page 301</span>内置数组不能进行拷贝和赋值操作，但标准库的 std::array 容器类型却可以，但需保证目标容器的大小和元素类型与当前容器相同。</li>
<li><span class="pn">Page 302</span>std::array 类型不支持 assign。<strong>assign 和赋值会导致左侧容器内部的迭代器、引用和指针失效</strong>。而 swap 交换容器内容则不会（std::array 和 std::string 除外）。<strong>swap 两个 array 会真正交换它们的元素</strong>（速度较慢，效率与元素数目成正比），因此指针、引用和迭代器绑定的元素保持不变，但值发生了变化。<strong>其他容器则是指向了新的交换后的元素</strong>（元素本身并未交换，只是容器内部数据结构被交换，因此交换时间是<strong>常数级别</strong>）。</li>
<li><span class="pn">Page 304</span>容器之间的关系运算符比较依赖于其中元素对关系运算符的实现。</li>
<li><span class="pn">Page 308</span>利用 insert() 从容器首位置插入元素：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>string word<span class="token punctuation">;</span>
  std<span class="token operator">::</span>list<span class="token operator">&lt;</span>string<span class="token operator">></span> lst<span class="token punctuation">;</span>
  <span class="token keyword">auto</span> iter <span class="token operator">=</span> lst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    iter <span class="token operator">=</span> lst<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>iter<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 在给定位置之前插入元素，指向新插入元素的迭代器；</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="102">
<li><span class="pn">Page 309</span>使用 emplace \ emplace_back \ emplace_front 可以直接在容器内指定位置构造对象，减少拷贝构造的过程。</li>
<li><span class="pn">Page 309</span>begin() / end() 返回迭代器，front() / back() 返回元素的引用。</li>
<li><span class="pn">Page 310</span>容器的 at() 方法会进行下标访问的 bound-check 越界检测，即下标越界时会抛出 <code>out_of_range</code> 异常，但可以保证元素访问的合法。否则可以直接使用 [] 来更高效地访问元素，但可能会引起运行时错误。</li>
<li><span class="pn">Page 313</span>从 forward_list 单向列表中添加/删除元素一般需要”双指针“，一个指向需要处理的元素，一个指向其<strong>前驱元素</strong>。因为单向链表删除或添加元素会影响前一元素的 next 指针。添加或删除元素只能通过其前驱元素进行操作。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>forward_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> flst <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">auto</span> prev <span class="token operator">=</span> flst<span class="token punctuation">.</span><span class="token function">before_begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">auto</span> curr <span class="token operator">=</span> flst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>curr <span class="token operator">!=</span> flst<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>curr <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      curr <span class="token operator">=</span> flst<span class="token punctuation">.</span><span class="token function">erase_after</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 删除后 curr 会指向无效指针； </span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      prev <span class="token operator">=</span> curr<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="106">
<li><span class="pn">Page 315</span>deque 可以用来判断回文。</li>
<li><span class="pn">Page 316</span>容器 erase() 方法<strong>返回删除元素之后</strong>元素的迭代器；insert() 方法在给定元素之前插入元素，然后<strong>返回指向新元素的迭代器</strong>。</li>
<li><span class="pn">Page 318</span>当不得不获取新的内存空间时，std::vector 和 std::string 通常会分配比新空间需求更大的内存空间以作为备用。在内存连续的容器中，size 表示当前容器存有多少个元素，capacity() 返回当前容器的可用元素空间。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>string str <span class="token operator">=</span> <span class="token string">"Hello, world!"</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// str.reserve(120);</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> str<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="109">
<li><span class="pn">Page 328</span>巧用 find_first_of() 进行字符数字转换：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>string str <span class="token operator">=</span> <span class="token string">"pi = 3.14"</span><span class="token punctuation">;</span>
  <span class="token keyword">double</span> d <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">stod</span><span class="token punctuation">(</span>  <span class="token comment" spellcheck="true">// 转换成浮点数；</span>
    str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>  <span class="token comment" spellcheck="true">// 获得子字符串；</span>
      str<span class="token punctuation">.</span><span class="token function">find_first_of</span><span class="token punctuation">(</span><span class="token string">"+-.0123456789"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 返回第一个匹配的位置；</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> d<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="110">
<li><span class="pn">Page 330</span>容器适配器，基于已有的顺序容器来模拟其他数据结构：stack（deque）、queue（deque）、priority_queue（vector）。</li>
<li><span class="pn">Page 337</span>泛型算法一般通过遍历“<strong>一个左闭右开 [i, j) 的迭代器范围</strong>”来操作容器中的元素。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lst <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">auto</span> result <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span>lst<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lst<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>result<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 返回指向目标元素的迭代器；</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="112">
<li><span class="pn">Page 339</span>算法和元素类型：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span> v <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">", world!"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>string sum <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">accumulate</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 最后参数决定返回值类型，和使用的“+”运算符；</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> sum <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="113">
<li><span class="pn">Page 339</span>那些只接受一个单一迭代器来表示第二个序列的算法，都<strong>假定第二个序列至少与第一个序列一样长</strong>。</li>
<li><span class="pn">Page 340</span>fill() / fill_n() 不能在空容器（size 为 0）上进行，<strong>算法不会执行容器操作，因此它们自身不可能改变容器大小</strong>。但 fill_n() 可以配合<strong>插入迭代器</strong>向空容器插入元素：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vec<span class="token punctuation">;</span>
  std<span class="token operator">::</span><span class="token function">fill_n</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>vec<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="115">
<li><span class="pn">Page 342</span>std::replace 的 copy 版本与 in-place 版本：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lst <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vec<span class="token punctuation">;</span>
  std<span class="token operator">::</span><span class="token function">replace</span><span class="token punctuation">(</span>lst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lst<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// in-place 版替换；</span>
  std<span class="token operator">::</span><span class="token function">replace_copy</span><span class="token punctuation">(</span>lst<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lst<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>vec<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//生成新副本版替换；</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="116">
<li><span class="pn">Page 346</span>lambda 表达式是内联函数，不能有默认实参：</li>
</ol>
<pre class="line-numbers language-text"><code class="language-text">[capture list](params) -> return type { body };
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ol start="117">
<li><span class="pn">Page 348</span>一个 lambda 只有在其捕获列表中捕获一个它<strong>所在函数中的局部变量</strong>，才能够在函数体中使用该变量。</li>
<li><span class="pn">Page 350</span>lambda 会实例化生成对应的类对象，并将捕获列表中的变量变成该类对象的数据成员。lambda 值捕获的变量是在 lambda 创建时进行拷贝，因此一旦创建成功后其值便不会再改变，为此可以使用<strong>引用捕获</strong>。</li>
<li><span class="pn">Page 352</span>lambda 捕获列表：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
  <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 值捕获；</span>
  <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 引用捕获；</span>
  <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> y <span class="token operator">+</span><span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 混合捕获；</span>
  <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">,</span> x<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 混合捕获；</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="120">
<li><span class="pn">Page 352</span>lambda 的非 cosnt 捕获值拷贝（闭包和匿名函数经常被用作同义词。但严格来说，匿名函数就是字面意义上没有被赋予名称的函数，而闭包则实际上是一个函数的实例，也就是说它是存在于内存里的某个结构体。如果从实现上来看的话，匿名函数如果没有捕捉自由变量，那么它其实可以被实现为一个函数指针，或者直接内联到调用点，如果它捕捉了自由变量那么它将是一个闭包；而闭包则意味着同时包括函数指针和环境两个关键元素。在编译优化当中，没有捕捉自由变量的闭包可以被优化成普通函数，这样就无需分配闭包结构体，这种编译技巧被称为函数跃升）：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
  <span class="token keyword">auto</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">mutable</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// mutable 关键字；</span>
    x <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// x 成为 lambda 隐式类对象的非 const 成员；</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 101；</span>
  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 102；</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 100；</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="121">
<li><span class="pn">Page 355</span>使用 bind 装饰 lambda 和普通函数：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">auto</span> foo <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>
    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">int</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> 
    std<span class="token operator">::</span>placeholders<span class="token operator">::</span>_1<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 固定匿名 lambda 的第二个参数；</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="122">
<li><span class="pn">Page 357</span>bind 参数以引用形式传递（默认是值传递）：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
  <span class="token keyword">auto</span> foo <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>
    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">++</span>x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> 
    std<span class="token operator">::</span><span class="token function">ref</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 通过引用传递；</span>
  <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="123">
<li><span class="pn">Page 358</span>insert() 和 inserter 插入迭代器的区别：前者返回插入新元素的迭代器位置，后者扔指向原位置（在给定位置前插入元素，但不移动）。</li>
<li><span class="pn">Page 360</span>流迭代器：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">in_iter</span><span class="token punctuation">(</span>std<span class="token operator">::</span>cin<span class="token punctuation">)</span><span class="token punctuation">,</span> eof<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 从 std::cin 读入数据；</span>
  std<span class="token operator">::</span>ostream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">out_iter</span><span class="token punctuation">(</span>std<span class="token operator">::</span>cout<span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">vec</span><span class="token punctuation">(</span>in_iter<span class="token punctuation">,</span> eof<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 初始化容器；</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> i <span class="token operator">:</span> vec<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">*</span>out_iter <span class="token operator">=</span> i<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// cout &lt;&lt; std::accumulate(in_iter, eof, 0) &lt;&lt; endl;  // 调用泛型算法；</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="125">
<li><span class="pn">Page 363</span>反向迭代器：递增一个反向迭代器会移动到前一个元素；除了 forward_list，其他容器元素均支持该迭代器；无论是正向还是反向迭代器，其对应的首尾迭代器均构成“<strong>左闭右开</strong>”的区间。</li>
</ol>
<p><img src="1.png"></p>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>string line <span class="token operator">=</span> <span class="token string">"FIRST,MIDDLE,LAST"</span><span class="token punctuation">;</span>
  <span class="token keyword">auto</span> rcomma <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">find</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">crbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> line<span class="token punctuation">.</span><span class="token function">crend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span><span class="token function">string</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">crbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rcomma<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// TSAL；</span>
  <span class="token comment" spellcheck="true">// base() 将反向迭代器便为普通迭代器；</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span><span class="token function">string</span><span class="token punctuation">(</span>rcomma<span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> line<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// LAST；</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="2.png"></p>
<ol start="126">
<li><span class="pn">Page 365</span>5类迭代器（层次依次上升，高层次支持低层次的所有操作）：</li>
</ol>
<ul>
<li>输入迭代器；如 std::istream_iterator，只读；可进行判断、++、*、-&gt;；</li>
<li>输出迭代器：如 std::ostream_iterator，只输出；可进行判断、++、*、-&gt;；</li>
<li>前向迭代器：如 std::forward_list<T>::iterator，单向移动；</li>
<li>双向迭代器：如 std::list<T>::iterator，双向移动；</li>
<li>随机访问迭代器（除 std::list / std::forward_list）：常量时间访问序列元素，+=，-=、下标访问；</li>
</ul>
<ol start="127">
<li><span class="pn">Page 369</span>对于 std::list 与 std::forward_list 来说，应该优先使用成员函数版本（改变节点间的链接）算法而非通用算法（需要交换元素，性能低）。</li>
<li><span class="pn">Page 371</span>迭代器的加入使得泛型算法可以与容器类型解耦，作为“中间件”提供了的<strong>统一的操作类型</strong>（五种迭代器类型）。算法从不直接改变它们所操作的序列大小。它们会将元素从一个位置拷贝到另一个位置，但不会直接添加或删除元素。类似 back_inserter 的迭代器为特殊的“输出迭代器”。</li>
<li><span class="pn">Page 372</span>lambda 可以对<strong>单一的返回语句</strong>进行隐式地类型推断。</li>
<li><span class="pn">Page 374</span>8个关联容器被分为三类：</li>
</ol>
<ul>
<li>或是一个 std::set，或是一个 std::map；</li>
<li>或要求不重复关键字，或允许重复关键字（multi）；</li>
<li>按顺序保存元素，或无序保存（unordered）；</li>
</ul>
<ol start="131">
<li><span class="pn">Page 376</span>大多数的容器算法在未找到目标元素时会返回对应的 end() 即尾后迭代器。</li>
<li><span class="pn">Page 378</span>有序关联容器：std::map、std::set、std::multimap、std::multiset；有序关联容器使用 <strong>“&lt;” 运算符</strong>的判断结果来对内容进行排序，因此对于<strong>重载了“&lt;”运算符</strong>（保证一个严格弱序，即“小于等于”）的类型可以将其用作容器的关键字；因此，std::map 与 std::multimap 的元素搜索，插入和删除操作具有对数复杂性。std::map 一般通过<strong>红黑树</strong>实现。</li>
<li><span class="pn">Page 379</span>关联容器使用自定义的排序函数（注意：泛型中的函数指针只是表明了类型，并非真正传入函数指针）：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  multiset<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">bool</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">&lt;=</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> i <span class="token operator">:</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="134">
<li><span class="pn">Page 381</span>关联容器常用类型别名：</li>
</ol>
<ul>
<li>key_type 关键字类型；</li>
<li>mapped_type 关键字关联的类型；</li>
<li>value_type 值类型（std::map 值为 std::pair 类型，std::set 与 key_type 相同）；</li>
</ul>
<ol start="135">
<li><span class="pn">Page 382</span>std::map 的 key_type 与 std::set 的 value_type 均是 const 的，因此无法通过迭代器进行修改。</li>
<li><span class="pn">Page 387</span>对 std::map 使用下标操作，对于<strong>不存在的元素将会添加一个具有此关键字的元素</strong>；相反可以使用 at() 作为替代，对于容器中不存在的元素则会抛出异常。</li>
<li><span class="pn">Page 389</span>std::map / std::unordered_map 的下标操作会产生副作用：对于不在容器中的元素 [] 访问时会插入默认值，可以使用 std::find 来查找特定元素是否在容器中。</li>
<li><span class="pn">Page 389</span>在 std::multimap 与 std::multiset 中，<strong>同名元素相邻存储</strong>。因此在查找到第一个元素的迭代器时，可以通过递增迭代器来访问其他的同名元素。但此时也要保证递增的步数小于等于 count() 方法查找到的目标元素个数。</li>
<li><span class="pn">Page 390</span>关联容器的 lower_bound() 与 upper_bound() 可以构成一个“[)”的迭代器范围，当两者相等时目标元素不存在。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>multiset<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> mset <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> aim <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> begin <span class="token operator">=</span> mset<span class="token punctuation">.</span><span class="token function">lower_bound</span><span class="token punctuation">(</span>aim<span class="token punctuation">)</span><span class="token punctuation">,</span> end <span class="token operator">=</span> mset<span class="token punctuation">.</span><span class="token function">upper_bound</span><span class="token punctuation">(</span>aim<span class="token punctuation">)</span><span class="token punctuation">;</span> begin <span class="token operator">!=</span> end<span class="token punctuation">;</span> <span class="token operator">++</span>begin<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>begin <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="140">
<li><span class="pn">Page 391</span>可以使用 equal_range() 来代替 lower_bound() 与 upper_bound() 的组合。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>multiset<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> mset <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> aim <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> iters <span class="token operator">=</span> mset<span class="token punctuation">.</span><span class="token function">equal_range</span><span class="token punctuation">(</span>aim<span class="token punctuation">)</span><span class="token punctuation">;</span> iters<span class="token punctuation">.</span>first <span class="token operator">!=</span> iters<span class="token punctuation">.</span>second<span class="token punctuation">;</span> <span class="token operator">++</span>iters<span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>iters<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="141">
<li><span class="pn">Page 395</span><strong>无序容器</strong>使用桶来保存具有相同 hash 值的元素，对于 std::unordered_multimap，具有相同关键字的元素会在同一个桶中。因此当桶内元素过多时，按顺序寻找特定元素的过程将会变慢。</li>
<li><span class="pn">Page 396</span>自定义类型在使用<strong>无序容器</strong>时需要自定义对应的 hash 函数以及 “==” 运算符的实现。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> A <span class="token punctuation">{</span>
  <span class="token keyword">friend</span> std<span class="token operator">::</span>hash<span class="token operator">&lt;</span>A<span class="token operator">></span><span class="token punctuation">;</span>
  <span class="token keyword">friend</span> <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> x<span class="token punctuation">,</span> <span class="token keyword">const</span> A<span class="token operator">&amp;</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> x<span class="token punctuation">,</span> <span class="token keyword">const</span> A<span class="token operator">&amp;</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x<span class="token punctuation">.</span>x <span class="token operator">==</span> y<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// std::hash 的一个对类 A 的模板特例化；</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span> <span class="token keyword">struct</span> std<span class="token operator">::</span>hash<span class="token operator">&lt;</span>A<span class="token operator">></span> <span class="token punctuation">{</span>
  size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> ins<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> std<span class="token operator">::</span>hash<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ins<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>unordered_multiset<span class="token operator">&lt;</span>A<span class="token operator">></span> mset <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> mset<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2；</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="143">
<li><span class="pn">Page 397</span>无论在有序容器还是无序容器中，<strong>具有相同关键字的元素都是相邻存储</strong>的。</li>
<li><span class="pn">Page 400</span>三种内存类型：</li>
</ol>
<ul>
<li><strong>静态内存</strong>：static 对象在使用之前分配的内存，程序结束时销毁。比如指向类对象的静态成员；</li>
<li><strong>栈内存</strong>：对应程序块运行时存在；</li>
<li><strong>堆内存</strong>：程序自己控制内存的使用和释放；</li>
</ul>
<ol start="145">
<li><span class="pn">Page 400</span>三种智能指针：</li>
</ol>
<ul>
<li><strong>std::shared_ptr</strong>：允许多个指针指向同一个对象；</li>
<li><strong>std::unique_ptr</strong>：独占所指向的对象；</li>
<li><strong>std::weak_ptr</strong>：弱引用，指向 std::shared_ptr 所管理的对象；</li>
</ul>
<ol start="146">
<li><span class="pn">Page 402</span>std::shared_ptr 基本原理：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> gw<span class="token punctuation">;</span>
  <span class="token keyword">auto</span> sp1 <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// sp1 指向的 int 只有一个引用者；</span>
  <span class="token keyword">auto</span> sp2 <span class="token operator">=</span> sp1<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 递增 sp1 指向对象的引用计数，递减 sp2 原来指向对象的引用计数；</span>
  gw <span class="token operator">=</span> sp1<span class="token punctuation">;</span>
  cout <span class="token operator">&lt;&lt;</span> gw<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2；</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="147">
<li><span class="pn">Page 403</span>如果将 std::shared_ptr 存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用 erase() 删除不需要的元素。</li>
<li><span class="pn">Page 404</span>使用动态内存的一个常见原因是允许多个对象共享相同的状态。</li>
<li><span class="pn">Page 407</span>相较于 new，使用 std::shared_ptr 的对象成员可以在默认拷贝构造函数的情况下省去资源移动/拷贝的烦恼（无需在析构函数中手动释放内存，因此拷贝构造函数对 std::shared_ptr 的拷贝可以确保原对象的堆资源仍旧可以使用，并且不需要在对象间移动）。</li>
<li><span class="pn">Page 408</span>动态对象的直接初始化与默认初始化：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">auto</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 默认初始化，内置类型值未定义；类类型默认构造函数初始化；</span>
  <span class="token keyword">auto</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 值初始化为 0；</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="151">
<li><span class="pn">Page 408</span>对于单一的初始化器可以使用 <strong>auto</strong> 来推断类型：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// auto p = new B();</span>
  <span class="token keyword">auto</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">auto</span><span class="token punctuation">(</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// "P1B"；</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="152">
<li><span class="pn">Page 408</span>动态分配 const 对象：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">const</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 只读；</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="153">
<li><p><span class="pn">Page 411</span>delete 之后重置指针：对于普通指向动态内存的指针来说，在 delete 之后还需将其值重置为 nullptr，以防悬挂指针被使用。</p>
</li>
<li><p><span class="pn">Page 412</span>接受指针参数的智能指针构造函数是 explicit 的，因此不能执行由普通指针到智能指针的隐式转换。</p>
</li>
<li><p><span class="pn">Page 412</span>从 new 指针生成智能指针可能会有性能损耗。在一个典型的实现中 std::shared_ptr 包含有<strong>两个指针</strong>：1、指向<strong>动态对象</strong>（get()）的指针；2、指向一个“<strong>控制块</strong>”的指针；其中“控制块”主要用于维护与 std::shared_ptr 有关的比如：删除器、分配器、托管对象的智能指针引用数量以及引用托管对象的 std::weak_ptr 的数量。当通过 std::make_shared 生成指针时，上述两个指针对应的堆内存将在<strong>一次内存分配</strong>中完成，因此性能较好。而通过 std::shared_ptr 构造函数初始化的智能指针，上述两个对象将在<strong>两次堆内存分配</strong>中完成。注意其中控制块堆内存的释放与引用托管对象的 std::weak_ptr 的数量有关。</p>
</li>
<li><p><span class="pn">Page 413</span>不要混用智能指针与原始指针（原始指针可能被智能指针提前释放，无法很好地控制其生命周期）。</p>
</li>
<li><p><span class="pn">Page 416</span>为 std::shared_ptr 设置自定义删除器：</p>
</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> B <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>B<span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>B<span class="token operator">*</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">delete</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="158">
<li><span class="pn">Page 417</span>std::unique_ptr <strong>不支持普通的拷贝和赋值</strong>，某一时刻只能有一个 std::unique_ptr 指向一个给定对象。可以在 C++14 之后使用 std::make_unique 创建 std::unique_ptr。</li>
<li><span class="pn">Page 418</span>release() 返回 std::unique_ptr 当前保存的指针并将其变量置为空指针，但不会释放内存，<strong>一般用于重新初始化其他类型的智能指针</strong>；reset() 接受一个指针参数，重置对应的 std::unique_ptr 指针，<strong>原指针对应的对象将被释放</strong>。std::unique_ptr 无法被拷贝，但可以作为函数参数或返回值（被移动）。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> B <span class="token punctuation">{</span> 
  <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">int</span> x<span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">auto</span> up1 <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>B<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">auto</span> up2 <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>B<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">auto</span> nup <span class="token operator">=</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>B<span class="token operator">></span><span class="token punctuation">(</span>up1<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 释放 up1 用于初始化 nup；</span>
  up2<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>nup<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 释放 nup 用于重置 up2，up2 原先指向的内存被回收；</span>
  <span class="token comment" spellcheck="true">// 可以移动一个 std::unique_ptr；</span>
  <span class="token keyword">auto</span> moveUp <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>up2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 不需要再对 up2 进行 reset()，默认会变为 nullptr；</span>
  cout <span class="token operator">&lt;&lt;</span> moveUp<span class="token operator">-</span><span class="token operator">></span>x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 10；</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="160">
<li><span class="pn">Page 420</span>std::weak_ptr 不控制所指向对象的生存期，指向由一个 std::shared_ptr 管理的对象。一般用于做 std::shared_ptr 的辅助类来观察对应智能指针的存活状态。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">auto</span> p <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">wp</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> wp<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 与 wp 共享对象的 std::shared_ptr 数量；</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> wp<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> np <span class="token operator">=</span> wp<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 有效则返回 std::shared_ptr 否则返回 nullptr；</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>np <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="161">
<li><span class="pn">Page 424</span>动态数组初始化可以使用列表初始化：std::unique_ptr 可以直接支持管理动态数组，<strong>而 std::shared_ptr 则需要提供自定义的删除器以支持动态数组</strong>：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span><span class="token operator">*</span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 可以创建大小为 0 的空动态数组，但无意义；</span>
  <span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">auto</span> sp <span class="token operator">=</span> shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 自定义 deleter；</span>
  <span class="token keyword">auto</span> up <span class="token operator">=</span> unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="162">
<li><span class="pn">Page 429</span>使用 std::allocator 类将内存分配与对象构造分离：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> B <span class="token punctuation">{</span> 
  <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">int</span> x<span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span>B<span class="token operator">></span> alloc<span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">auto</span> p <span class="token operator">=</span> alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 分配可保存 num 个对象的未初始化内存；</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    alloc<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>p<span class="token operator">++</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 在 p 指向的内存上构造 B 对象；</span>
    alloc<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token operator">--</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 析构对象；</span>
  <span class="token punctuation">}</span>
  alloc<span class="token punctuation">.</span><span class="token function">deallocate</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 释放内存；</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="163">
<li><span class="pn">Page 429</span>使用<strong>伴随算法</strong>填充 std::allocator 分配的未初始化的内存：</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>allocator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> alloc<span class="token punctuation">;</span>
  <span class="token keyword">auto</span> p <span class="token operator">=</span> alloc<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">auto</span> q <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">uninitialized_copy</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 根据输入范围拷贝，返回填充最后元素之后的位置；</span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 1；</span>
  <span class="token comment" spellcheck="true">// uninitialized_fill_n(p, vi.size(), 10);  // 直接填充；</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="164">
<li><span class="pn">Page 444</span>对于内置数组类型，编译器生成的拷贝构造函数可以正常地对其进行拷贝构造。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> B <span class="token punctuation">{</span> 
  <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  B <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// y 从 x 拷贝构造生成；</span>
  cout <span class="token operator">&lt;&lt;</span> y<span class="token punctuation">.</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 1；</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="165">
<li><span class="pn">Page 445</span>析构函数默认会按照构造函数初始化成员顺序（成员定义的先后顺序）的逆序来销毁成员。</li>
<li><span class="pn">Page 448</span>三五法则：<strong>如果类需要析构函数，则同时需要拷贝构造函数以及拷贝赋值函数（否则多个对象会指向同一个将被销毁的堆内存）</strong>；</li>
<li><span class="pn">Page 449</span>当存在用户定义的拷贝构造函数时，用户仍可用关键词 default 强迫编译器生成隐式内联的拷贝构造函数。</li>
<li><span class="pn">Page 450</span>定义成 delete 删除的函数不能被调用，因此可以通过该关键字来阻止类对象的拷贝、赋值和移动。若析构函数被标记为 delete 则该类对象不能被销毁（delete）。</li>
<li><span class="pn">Page 451</span>本质上，<strong>当不能拷贝、赋值或销毁类成员时，类的合成拷贝控制成员就被定义为删除</strong>。</li>
<li><span class="pn">Page 454</span>编写赋值构造函数时需要满足可以进行“<strong>自赋值</strong>”，因此进行资源释放和拷贝的顺序便成了关键。一个好的方式是<strong>先拷贝右侧的运算对象，再释放资源</strong>。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> B <span class="token punctuation">{</span> 
  <span class="token keyword">int</span><span class="token operator">*</span> arr<span class="token punctuation">;</span>
  size_t size<span class="token punctuation">;</span>
  <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">size</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">{</span>x<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token operator">~</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">delete</span> arr<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  B<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> B<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 拷贝构造，不修改原对象；</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>rhs <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">delete</span> arr<span class="token punctuation">;</span>
      size <span class="token operator">=</span> rhs<span class="token punctuation">.</span>size<span class="token punctuation">;</span>
      arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>rhs<span class="token punctuation">.</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token operator">*</span><span class="token punctuation">(</span>arr <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>arr <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 拷贝；</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  B<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>B<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 移动构造函数必须为 noexcept 以适应标准库容器；</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>rhs <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
      <span class="token keyword">delete</span> arr<span class="token punctuation">;</span>
      size <span class="token operator">=</span> rhs<span class="token punctuation">.</span>size<span class="token punctuation">;</span>
      arr <span class="token operator">=</span> rhs<span class="token punctuation">.</span>arr<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 栈上的对象一般需要 std::move，否则会被析构；</span>
      rhs<span class="token punctuation">.</span>arr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 防止原堆数据被原对象析构；</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  B <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  y <span class="token operator">=</span> x<span class="token punctuation">;</span>
  y <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 移动后不能再使用 x；</span>
  y <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> y<span class="token punctuation">.</span>size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span>arr <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="171">
<li><span class="pn">Page 471</span>右值引用指向将要被销毁的对象。变量是左值，因此不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型。我们可以销毁一个移后源对象，也可以赋予它新值，但<strong>不能使用一个移后源对象的值</strong>。要区分“引用了一个右值”和“右值”的区别：引用一个右值就是表示一个右值引用，<strong>这个变量本身还是一个左值</strong>；而右值表示“将亡值”或“纯右值”。</li>
<li><span class="pn">Page 473</span>移动构造函数会帮我们自动接管内存，但需要我们自己处理新对象指针的指向，以防止接管内存被原对象释放。</li>
<li><span class="pn">Page 474</span>通过将<strong>移动构造/赋值函数标记为 noexcept</strong> 来告诉编译器在资源的移动过程中不会发生异常，进而让<strong>标准库容器</strong>优先使用移动构造函数而非拷贝构造函数。</li>
<li><span class="pn">Page 476</span>只有当一个类<strong>没有定义任何自己版本的拷贝控制成员（拷贝构造、赋值和析构函数）</strong>，且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成移动构造或移动赋值函数。</li>
<li><span class="pn">Page 477</span>定义了一个移动构造函数或移动赋值函数的类也必须定义自己的拷贝操作，否则这些成员默认被定义为删除，类对象将不能进行赋值。</li>
<li><span class="pn">Page 479</span>三五法则：一般来说，如果一个类定义了任何一个拷贝操作，那就应该定义所有的五个操作（析构函数、拷贝构造、拷贝赋值、移动构造、移动赋值）。</li>
<li><span class="pn">Page 481</span>移动迭代器：解引用返回右值引用，可以用 std::make_move_iterator 将普通迭代器转换成返回右值的迭代器。</li>
<li><span class="pn">Page 483</span>引用限定符：限定<strong>类对象的 this 是否可以指向一个左值还是右值</strong>；必须同时出现在成员函数的声明和定义中。</li>
</ol>
<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> B <span class="token punctuation">{</span> 
  <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">{</span> sum <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 只能在左值对象上调用；</span>
  <span class="token keyword">int</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> sum<span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 只能在右值对象上调用；</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  B b<span class="token punctuation">;</span>
  b<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="179">
<li><span class="pn">Page 485</span>如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符（必须互不相同）。</li>
</ol>
<br><div class="article-bottom-meta"><span class="post-meta">Last built on<time itemprop="dateModified" datetime="2020-04-12T09:28:14.000Z"> 2023 / 10 / 26, 11:37:10</time></span></div></div></article><br><span class="next-post"><a href="/2020/04/14/Primer-C-完全笔记（第 14-16 章）/" itemprop="url">下一篇 ⇒</a></span><span class="prev-post"><a href="/2020/04/10/Primer-C-完全笔记（第 1-8 章）/" itemprop="url">⇐ 上一篇</a></span><br><section id="comments"><div><h4>文章评论（Utterances）</h4><script src="https://utteranc.es/client.js" repo="Becavalier/utterances-comments" issue-term="title" label="[Comment]" theme="github-light" crossorigin="anonymous" async></script></div></section><br><br></main><script src="/scripts/index.js" type="text/javascript"></script></body></html>