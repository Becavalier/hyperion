<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Redis 源码之内存管理 - zmalloc / zfree | 曜彤.手记</title><meta name="description" content="之前在为 Eufa 添加本地缓存管理的功能时，基本的数据存储功能使用了简单的双向链表来实现，但由于在 Wasm32 架构上的最大可用内存只有 4GB，因此我们需要对本地内存的使用大小做一个限制，但如何才能够精确地获得应用所使用的内存大小呢？我们都知道，譬如 malloc 等标准库中的内存分配函数会根据当前的系统架构类型自动地进行4/8字节的内存对齐，因此对于应用在存储数据时底层系统实际分配的内存大小我们很难直接进行计算。"><meta name="generator" content="曜彤.手记"><meta name="author" content="于航(曜彤)"><meta name="keywords" content="博客, C++, C, Rust, Web, Java, IT, 编程, 开发, Android, Python, MySQL, 科技, 黑客, 技术, Javascript, 云, 大数据, 计算, 机器学习, AI, 人工智能, 创业, 产品, 公司, WebAssembly, Wasm"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.jpg"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.jpg"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.jpg"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.jpg"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.jpg"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.jpg"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.jpg"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.jpg"><link rel="apple-touch-icon" sizes="196x196" href="/images/apple-touch-icon-196x196.jpg"><link rel="apple-touch-icon" sizes="310x310" href="/images/apple-touch-icon-310x310.jpg"><link href="/images/splash/iphone5_splash.png" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphone6_splash.png" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphoneplus_splash.png" media="(device-width: 621px) and (device-height: 1104px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/iphonex_splash.png" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/iphonexr_splash.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/iphonexsmax_splash.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3)" rel="apple-touch-startup-image"><link href="/images/splash/ipad_splash.png" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro1_splash.png" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro3_splash.png" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link href="/images/splash/ipadpro2_splash.png" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="128x128" href="/images/favicon-128.png"><link rel="icon" type="image/png" sizes="196x196" href="/images/favicon-196x196.png"><meta name="msapplication-TileColor" content="#FFFFFF"><meta name="msapplication-TileImage" content="mstile-144x144.png"><meta name="msapplication-square70x70logo" content="mstile-70x70.png"><meta name="msapplication-square150x150logo" content="mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="mstile-310x150.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"><link rel="manifest" href="/manifest.webmanifest"><link rel="alternate" type="application/atom+xml" title="Atom 0.3" href="/atom.xml"><link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body itemscope itemtype="https://schema.org/WebPage"><div class="canvas-containter"><span>X</span></div><header itemscope itemtype="https://schema.org/WPHeader"><div class="logo"></div><h1 class="title"><a href="/" alt="曜彤.手记" title="曜彤.手记" itemprop="headline">曜彤.手记</a><a title="Atom 0.3" target="__blank" href="/atom.xml" class="rss"><img src="/images/rss.png"></a></h1><p itemprop="description" class="description">随记，关于互联网技术、产品与创业</p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name" class="menu-item"><a href="/ " alt="首页" title="首页" itemprop="url">首页</a></li><li itemprop="name" class="menu-item"><a href="/articles" alt="文章" title="文章" itemprop="url">文章</a></li><li itemprop="name" class="menu-item"><a href="/notes" alt="记录" title="记录" itemprop="url">记录</a></li><li itemprop="name" class="menu-item"><a href="/readings" alt="阅读" title="阅读" itemprop="url">阅读</a></li><li itemprop="name" class="menu-item"><a href="/tags" alt="标签" title="标签" itemprop="url">标签</a></li><li itemprop="name" class="menu-item"><a href="/author" alt="关于" title="关于" itemprop="url">关于</a></li></ul></nav><p class="meta-icp"><a target="_blank" href="https://beian.miit.gov.cn/"><span>吉 ICP 备10004938-2号</span></a></p><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><script src="https://shadow.elemecdn.com/npm/zoomage.js@latest/dist/zoomage.min.js" type="text/javascript"></script><script src="https://shadow.elemecdn.com/npm/axios@0.18.0/dist/axios.min.js" type="text/javascript"></script><script src="/scripts/post.js" type="text/javascript"></script><div class="touch-top"><span></span></div><article post-id="92ca0adc41bab4cbe5a48db7546aede1" class="full"><h1 itemprop="headline" class="post-heading">Redis 源码之内存管理 - zmalloc / zfree</h1><div class="article-meta"><span class="post-meta"><br>Created on<time itemprop="dateCreated" datetime="2017-08-22T01:49:03.000Z"> 2017 / 08 / 22, 09:49:03</time></span><span class="page-tag-anchor"><a href="/tags/Redis" itemprop="url">#Redis</a>&nbsp;&nbsp;</span></div><br><p>之前在为 Eufa 添加本地缓存管理的功能时，基本的数据存储功能使用了简单的双向链表来实现，但由于在 Wasm32 架构上的最大可用内存只有 4GB，因此我们需要对本地内存的使用大小做一个限制，<strong>但如何才能够精确地获得应用所使用的内存大小呢？</strong>我们都知道，譬如 <code>malloc</code> 等标准库中的内存分配函数会根据当前的系统架构类型自动地进行4/8字节的内存对齐，因此对于应用在存储数据时底层系统实际分配的内存大小我们很难直接进行计算。</p>
<p>而为了解决这个问题，在这里我直接借鉴了 Redis 在其内存管理上的实现方式。如下所示，我们直接来看 Redis 源码（不是最新版本）中自定义的 zmalloc 函数，该函数与 malloc 等常规函数的使用方式完全一致，不同的在于其内部的具体实现细节。</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">zmalloc</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 分配内存；</span>
  <span class="token keyword">void</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>size <span class="token operator">+</span> PREFIX_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 分配失败抛出异常；</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ptr<span class="token punctuation">)</span> <span class="token function">zmalloc_oom_handler</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 系统是否可以使用”malloc_size“函数？</span>
<span class="token macro property">#<span class="token directive keyword">ifdef</span> HAVE_MALLOC_SIZE</span>
  <span class="token function">update_zmalloc_stat_alloc</span><span class="token punctuation">(</span><span class="token function">zmalloc_size</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> ptr<span class="token punctuation">;</span>
<span class="token macro property">#<span class="token directive keyword">else</span></span>
  <span class="token comment" spellcheck="true">// 在数据域保存分配数据的实际大小；</span>
  <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>size_t<span class="token operator">*</span><span class="token punctuation">)</span>ptr<span class="token punctuation">)</span> <span class="token operator">=</span> size<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 计算对齐后的内存使用大小，并更新”used_memory“变量；</span>
  <span class="token function">update_zmalloc_stat_alloc</span><span class="token punctuation">(</span>size <span class="token operator">+</span> PREFIX_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 返回数据体的初始位置；</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>ptr <span class="token operator">+</span> PREFIX_SIZE<span class="token punctuation">;</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其实，标准库中的 malloc 函数已经能够自动为分配的内存实现对齐，因此 zmalloc 方法在这里其主要目的是为了能够精确地计算每一次数据存储时所分配的内存大小。在每一次分配内存时，zmalloc 都会在该次分配的数据内存大小的基础上再加上一个 <strong>PREFIX_SIZE</strong> 大小的额外内存空间，这个 PREFIX_SIZE 宏代表了当前系统的最大内存寻址空间大小（size_t），其依赖于具体系统的类型不同而不同。这里我们可以简称这个 PREFIX_SIZE 大小的空间为一个存储单元的“数据头”部分。</p>
<p><img src="1.jpg" alt=""></p>
<p>如上图所示，通过 <code>*((size_t*)ptr) = size;</code> 语句，Redis 在当前分配内存块的前 PREFIX_SIZE 个字节，即数据头内存储了本次实际分配的数据块大小，而在后面 ”size“ 大小的内存空间中才真正存放了二进制的数据实体。在这里名为 <strong>update_zmalloc_stat_alloc</strong> 的函数在其内部会维护一个名为 <strong>used_memory</strong> 的全局变量，该变量累加了每次新分配的内存大小。函数在最后返回了一个偏移的指针，指向了当前分配内存的数据体部分。update_zmalloc_stat_alloc 函数的具体实现细节如下。</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> update_zmalloc_stat_alloc(__n) do { </span>
  size_t _n <span class="token operator">=</span> <span class="token punctuation">(</span>__n<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token comment" spellcheck="true">// 手动内存补齐；</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>_n<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> _n <span class="token operator">+</span><span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token punctuation">(</span>_n<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token function">atomicIncr</span><span class="token punctuation">(</span>used_memory<span class="token punctuation">,</span> __n<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里需要注意的重点是 <code>_n += sizeof(long)-(_n&amp;(sizeof(long)-1));</code> 这行语句。整个宏函数首先判断本次分配的内存大小是否为 sizeof(long) 大小的整数倍（64位机对应着8字节的内存对齐；32位机则对应着4字节的内存对齐），如果不是则通过我们之前给出的语句在该数据段后添加相应的占位空间来补足位数以满足内存对齐（4/8字节）的要求。最后的 atomicIncr 函数用来在保证线程安全的情况下更新全局的 used_memory 变量值。</p>
<p>而该版本 Redis 中内存释放与其内存分配的过程则正好相反。如下所示代码为对应 “zfree” 函数的实现细节。首先该函数通过 <code>(char*)ptr-PREFIX_SIZE</code> 语句（向内存低地址移动）指向了包含有该数据块实际占用大小的数据域首地址，然后通过 <code>*((size_t*)realptr)</code> 语句获得到了该数据块分配的真实内存大小（不包含内存对齐区域）。最后再通过 update_zmalloc_stat_free 函数来更新全局变量 used_memory 的值，并释放该段内存。</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">zfree</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token macro property">#<span class="token directive keyword">ifndef</span> HAVE_MALLOC_SIZE</span>
  <span class="token keyword">void</span> <span class="token operator">*</span>realptr<span class="token punctuation">;</span>
  size_t oldsize<span class="token punctuation">;</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token macro property">#<span class="token directive keyword">ifdef</span> HAVE_MALLOC_SIZE</span>
  <span class="token function">update_zmalloc_stat_free</span><span class="token punctuation">(</span><span class="token function">zmalloc_size</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property">#<span class="token directive keyword">else</span></span>
  realptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>ptr<span class="token operator">-</span>PREFIX_SIZE<span class="token punctuation">;</span>
  oldsize <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>size_t<span class="token operator">*</span><span class="token punctuation">)</span>realptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">update_zmalloc_stat_free</span><span class="token punctuation">(</span>oldsize<span class="token operator">+</span>PREFIX_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">free</span><span class="token punctuation">(</span>realptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property">#<span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如下所示，这里如果我们再来看 update_zmalloc_stat_free 函数的实现细节，你会发现它与之前的 update_zmalloc_stat_alloc 函数其执行过程类似。通过计算需要补足的内存字节大小，并从 used_memory 变量中减去相应大小的内存空间，即可实现对内存空间使用率的精确计算。</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> update_zmalloc_stat_free(__n) do { \
  size_t _n = (__n); \
  if (_n&amp;(sizeof(long)-1)) _n += sizeof(long)-(_n&amp;(sizeof(long)-1)); \
  atomicDecr(used_memory,__n); \
} while(0) </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后再来仔细回顾一下刚刚我们在 update_zmalloc_stat_alloc 函数中执行内存补齐操作的部分。在 Wasm32 架构中，sizeof(long) 的值是4，因此对应的补齐操作语句就变成了 <code>if(_n&amp;3) _n += 4 - (_n&amp;3);</code>，即需要满足4字节对齐。如果此时用户端有一个大小为”<strong>13字节</strong>“的数据需要存储，那么经过内存对齐处理，应用实际存放到内存中的数据大小便为：13 + 4 - 1 = 16 字节大小，内存对齐字节的计算过程可以参考下图。</p>
<p><img src="2.jpg" alt=""></p>
<p>以上便是 Redis 在其整体复杂设计实现过程中的一个十分细小但却精妙的设计点。</p>
<br><div class="article-bottom-meta"><span class="post-meta">Last built on<time itemprop="dateModified" datetime="2017-08-22T01:49:03.000Z"> 2021 / 04 / 02, 22:45:04</time></span></div></article><br><a name="comments"></a><div class="article-end-saparator"><span class="line"></span><span class="text">这是文章底线，下面是评论</span><span class="line"></span></div><div class="comments-display-container"><div class="placeholder"><i class="fa fa-battery-empty">&nbsp;&nbsp;暂无评论，欢迎勾搭 ：）</i></div></div><div class="dot-decoration"></div><div class="comments-input"><textarea name="comment" placeholder="请输入评论内容 ..."></textarea><div><input type="text" placeholder="请输入昵称 ..."><button class="submit-comment">发布</button></div></div><span class="next-post"><a href="/2017/07/20/Python-高级用法/" itemprop="url">Older Post ⇒</a></span><span class="prev-post"><a href="/2017/09/02/C-小记录/" itemprop="url">⇐ Next Post </a></span><br><br><br><br><br></main><script src="/scripts/index.js" type="text/javascript"></script></body></html>